
(function()
{
"use strict";
var d={};
d.TestCompound=function()
{
var bd=null;
var body=null;
var i=0;
var x=0;
var cd1=null;
var cd2=null;
var pd1=null;
var pd2=null;
var xf1=null;
var sd1=null;
var xf2=null;
var sd2=null;
var sd_bottom=null;
var sd_left=null;
var sd_right=null;
this.Test_constructor();
Main.m_aboutText.set_text("Compound Shapes");
bd;
body;
i;
x;
{
cd1=new Box2D.Collision.Shapes.b2CircleShape();
cd1.SetRadius(15.0/this.m_physScale);
cd1.SetLocalPosition(new Box2D.Common.Math.b2Vec2(-15.0/this.m_physScale,15.0/this.m_physScale));
cd2=new Box2D.Collision.Shapes.b2CircleShape();
cd2.SetRadius(15.0/this.m_physScale);
cd2.SetLocalPosition(new Box2D.Common.Math.b2Vec2(15.0/this.m_physScale,15.0/this.m_physScale));
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
for(i=0;i<5;++i)
{
x=320.0+Box2D.Common.Math.b2Math.RandomRange(-3.0,3.0);
bd.position.Set((x+150.0)/this.m_physScale,(31.5+75.0*-i+300.0)/this.m_physScale);
bd.angle=Box2D.Common.Math.b2Math.RandomRange(-Math.PI,Math.PI);
body=this.m_world.CreateBody(bd);
body.CreateFixture2(cd1,2.0);
body.CreateFixture2(cd2,0.0)
}
};
{
pd1=new Box2D.Collision.Shapes.b2PolygonShape();
pd1.SetAsBox(7.5/this.m_physScale,15.0/this.m_physScale);
pd2=new Box2D.Collision.Shapes.b2PolygonShape();
pd2.SetAsOrientedBox(7.5/this.m_physScale,15.0/this.m_physScale,new Box2D.Common.Math.b2Vec2(0.0,-15.0/this.m_physScale),0.5*Math.PI);
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
for(i=0;i<5;++i)
{
x=320.0+Box2D.Common.Math.b2Math.RandomRange(-3.0,3.0);
bd.position.Set((x-150.0)/this.m_physScale,(31.5+75.0*-i+300)/this.m_physScale);
bd.angle=Box2D.Common.Math.b2Math.RandomRange(-Math.PI,Math.PI);
body=this.m_world.CreateBody(bd);
body.CreateFixture2(pd1,2.0);
body.CreateFixture2(pd2,2.0)
}
};
{
xf1=new Box2D.Common.Math.b2Transform();
xf1.R.Set(0.3524*Math.PI);
xf1.position=Box2D.Common.Math.b2Math.MulMV(xf1.R,new Box2D.Common.Math.b2Vec2(1.0,0.0));
sd1=new Box2D.Collision.Shapes.b2PolygonShape();
sd1.SetAsArray([Box2D.Common.Math.b2Math.MulX(xf1,new Box2D.Common.Math.b2Vec2(-30.0/this.m_physScale,0.0)),Box2D.Common.Math.b2Math.MulX(xf1,new Box2D.Common.Math.b2Vec2(30.0/this.m_physScale,0.0)),Box2D.Common.Math.b2Math.MulX(xf1,new Box2D.Common.Math.b2Vec2(0.0,15.0/this.m_physScale))]);
xf2=new Box2D.Common.Math.b2Transform();
xf2.R.Set(-0.3524*Math.PI);
xf2.position=Box2D.Common.Math.b2Math.MulMV(xf2.R,new Box2D.Common.Math.b2Vec2(-30.0/this.m_physScale,0.0));
sd2=new Box2D.Collision.Shapes.b2PolygonShape();
sd2.SetAsArray([Box2D.Common.Math.b2Math.MulX(xf2,new Box2D.Common.Math.b2Vec2(-30.0/this.m_physScale,0.0)),Box2D.Common.Math.b2Math.MulX(xf2,new Box2D.Common.Math.b2Vec2(30.0/this.m_physScale,0.0)),Box2D.Common.Math.b2Math.MulX(xf2,new Box2D.Common.Math.b2Vec2(0.0,15.0/this.m_physScale))]);
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.fixedRotation=true;
for(i=0;i<5;++i)
{
x=320.0+Box2D.Common.Math.b2Math.RandomRange(-3.0,3.0);
bd.position.Set(x/this.m_physScale,(-61.5+55.0*-i+300)/this.m_physScale);
bd.angle=0.0;
body=this.m_world.CreateBody(bd);
body.CreateFixture2(sd1,2.0);
body.CreateFixture2(sd2,2.0)
}
};
{
sd_bottom=new Box2D.Collision.Shapes.b2PolygonShape();
sd_bottom.SetAsBox(45.0/this.m_physScale,4.5/this.m_physScale);
sd_left=new Box2D.Collision.Shapes.b2PolygonShape();
sd_left.SetAsOrientedBox(4.5/this.m_physScale,81.0/this.m_physScale,new Box2D.Common.Math.b2Vec2(-43.5/this.m_physScale,-70.5/this.m_physScale),-0.2);
sd_right=new Box2D.Collision.Shapes.b2PolygonShape();
sd_right.SetAsOrientedBox(4.5/this.m_physScale,81.0/this.m_physScale,new Box2D.Common.Math.b2Vec2(43.5/this.m_physScale,-70.5/this.m_physScale),0.2);
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set(320.0/this.m_physScale,300.0/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture2(sd_bottom,4.0);
body.CreateFixture2(sd_left,4.0);
body.CreateFixture2(sd_right,4.0)
};
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
};
flash.addDescription("TestBed.TestCompound",d,"TestBed.Test",s,null,["Main","Box2D.Collision.Shapes.b2CircleShape","Box2D.Common.Math.b2Vec2","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Common.Math.b2Math","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Common.Math.b2Transform"]);
}
());;
(function()
{
"use strict";
var d={};
d.TestRagdoll=function()
{
var circ=null;
var box=null;
var bd=null;
var jd=null;
var fixtureDef=null;
var i=0;
var startX=0;
var startY=0;
var head=null;
var torso1=null;
var torso2=null;
var torso3=null;
var upperArmL=null;
var upperArmR=null;
var lowerArmL=null;
var lowerArmR=null;
var upperLegL=null;
var upperLegR=null;
var lowerLegL=null;
var lowerLegR=null;
var j=0;
var k=0;
this.Test_constructor();
Main.m_aboutText.set_text("Ragdolls");
circ;
box;
bd=new Box2D.Dynamics.b2BodyDef();
jd=new Box2D.Dynamics.Joints.b2RevoluteJointDef();
fixtureDef=new Box2D.Dynamics.b2FixtureDef();
for(i=0;i<2;i++)
{
startX=70+Math.random()*20+480*i;
startY=20+Math.random()*50;
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
circ=new Box2D.Collision.Shapes.b2CircleShape(12.5/this.m_physScale);
fixtureDef.shape=circ;
fixtureDef.density=1.0;
fixtureDef.friction=0.4;
fixtureDef.restitution=0.3;
bd.position.Set(startX/this.m_physScale,startY/this.m_physScale);
head=this.m_world.CreateBody(bd);
head.CreateFixture(fixtureDef);
head.ApplyImpulse(new Box2D.Common.Math.b2Vec2(Math.random()*100-50,Math.random()*100-50),head.GetWorldCenter());
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(15/this.m_physScale,10/this.m_physScale);
fixtureDef.shape=box;
fixtureDef.density=1.0;
fixtureDef.friction=0.4;
fixtureDef.restitution=0.1;
bd.position.Set(startX/this.m_physScale,(startY+28)/this.m_physScale);
torso1=this.m_world.CreateBody(bd);
torso1.CreateFixture(fixtureDef);
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(15/this.m_physScale,10/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set(startX/this.m_physScale,(startY+43)/this.m_physScale);
torso2=this.m_world.CreateBody(bd);
torso2.CreateFixture(fixtureDef);
box.SetAsBox(15/this.m_physScale,10/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set(startX/this.m_physScale,(startY+58)/this.m_physScale);
torso3=this.m_world.CreateBody(bd);
torso3.CreateFixture(fixtureDef);
fixtureDef.density=1.0;
fixtureDef.friction=0.4;
fixtureDef.restitution=0.1;
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(18/this.m_physScale,6.5/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX-30)/this.m_physScale,(startY+20)/this.m_physScale);
upperArmL=this.m_world.CreateBody(bd);
upperArmL.CreateFixture(fixtureDef);
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(18/this.m_physScale,6.5/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX+30)/this.m_physScale,(startY+20)/this.m_physScale);
upperArmR=this.m_world.CreateBody(bd);
upperArmR.CreateFixture(fixtureDef);
fixtureDef.density=1.0;
fixtureDef.friction=0.4;
fixtureDef.restitution=0.1;
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(17/this.m_physScale,6/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX-57)/this.m_physScale,(startY+20)/this.m_physScale);
lowerArmL=this.m_world.CreateBody(bd);
lowerArmL.CreateFixture(fixtureDef);
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(17/this.m_physScale,6/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX+57)/this.m_physScale,(startY+20)/this.m_physScale);
lowerArmR=this.m_world.CreateBody(bd);
lowerArmR.CreateFixture(fixtureDef);
fixtureDef.density=1.0;
fixtureDef.friction=0.4;
fixtureDef.restitution=0.1;
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(7.5/this.m_physScale,22/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX-8)/this.m_physScale,(startY+85)/this.m_physScale);
upperLegL=this.m_world.CreateBody(bd);
upperLegL.CreateFixture(fixtureDef);
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(7.5/this.m_physScale,22/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX+8)/this.m_physScale,(startY+85)/this.m_physScale);
upperLegR=this.m_world.CreateBody(bd);
upperLegR.CreateFixture(fixtureDef);
fixtureDef.density=1.0;
fixtureDef.friction=0.4;
fixtureDef.restitution=0.1;
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(6/this.m_physScale,20/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX-8)/this.m_physScale,(startY+120)/this.m_physScale);
lowerLegL=this.m_world.CreateBody(bd);
lowerLegL.CreateFixture(fixtureDef);
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(6/this.m_physScale,20/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((startX+8)/this.m_physScale,(startY+120)/this.m_physScale);
lowerLegR=this.m_world.CreateBody(bd);
lowerLegR.CreateFixture(fixtureDef);
jd.enableLimit=true;
jd.lowerAngle=-40/(180/Math.PI);
jd.upperAngle=40/(180/Math.PI);
jd.Initialize(torso1,head,new Box2D.Common.Math.b2Vec2(startX/this.m_physScale,(startY+15)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-85/(180/Math.PI);
jd.upperAngle=130/(180/Math.PI);
jd.Initialize(torso1,upperArmL,new Box2D.Common.Math.b2Vec2((startX-18)/this.m_physScale,(startY+20)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-130/(180/Math.PI);
jd.upperAngle=85/(180/Math.PI);
jd.Initialize(torso1,upperArmR,new Box2D.Common.Math.b2Vec2((startX+18)/this.m_physScale,(startY+20)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-130/(180/Math.PI);
jd.upperAngle=10/(180/Math.PI);
jd.Initialize(upperArmL,lowerArmL,new Box2D.Common.Math.b2Vec2((startX-45)/this.m_physScale,(startY+20)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-10/(180/Math.PI);
jd.upperAngle=130/(180/Math.PI);
jd.Initialize(upperArmR,lowerArmR,new Box2D.Common.Math.b2Vec2((startX+45)/this.m_physScale,(startY+20)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-15/(180/Math.PI);
jd.upperAngle=15/(180/Math.PI);
jd.Initialize(torso1,torso2,new Box2D.Common.Math.b2Vec2(startX/this.m_physScale,(startY+35)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.Initialize(torso2,torso3,new Box2D.Common.Math.b2Vec2(startX/this.m_physScale,(startY+50)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-25/(180/Math.PI);
jd.upperAngle=45/(180/Math.PI);
jd.Initialize(torso3,upperLegL,new Box2D.Common.Math.b2Vec2((startX-8)/this.m_physScale,(startY+72)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-45/(180/Math.PI);
jd.upperAngle=25/(180/Math.PI);
jd.Initialize(torso3,upperLegR,new Box2D.Common.Math.b2Vec2((startX+8)/this.m_physScale,(startY+72)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-25/(180/Math.PI);
jd.upperAngle=115/(180/Math.PI);
jd.Initialize(upperLegL,lowerLegL,new Box2D.Common.Math.b2Vec2((startX-8)/this.m_physScale,(startY+105)/this.m_physScale));
this.m_world.CreateJoint(jd);
jd.lowerAngle=-115/(180/Math.PI);
jd.upperAngle=25/(180/Math.PI);
jd.Initialize(upperLegR,lowerLegR,new Box2D.Common.Math.b2Vec2((startX+8)/this.m_physScale,(startY+105)/this.m_physScale));
this.m_world.CreateJoint(jd)
}
bd.type=Box2D.Dynamics.b2Body.b2_staticBody;
fixtureDef.density=0.0;
fixtureDef.friction=0.4;
fixtureDef.restitution=0.3;
for(j=1;j<=10;j++)
{
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox((10*j)/this.m_physScale,10/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((10*j)/this.m_physScale,(150+20*j)/this.m_physScale);
head=this.m_world.CreateBody(bd);
head.CreateFixture(fixtureDef)
}
for(k=1;k<=10;k++)
{
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox((10*k)/this.m_physScale,10/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set((640-10*k)/this.m_physScale,(150+20*k)/this.m_physScale);
head=this.m_world.CreateBody(bd);
head.CreateFixture(fixtureDef)
}
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(30/this.m_physScale,40/this.m_physScale);
fixtureDef.shape=box;
bd.position.Set(320/this.m_physScale,320/this.m_physScale);
head=this.m_world.CreateBody(bd);
head.CreateFixture(fixtureDef);
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
};
flash.addDescription("TestBed.TestRagdoll",d,"TestBed.Test",s,null,["Main","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.Joints.b2RevoluteJointDef","Box2D.Dynamics.b2FixtureDef","Box2D.Dynamics.b2Body","Box2D.Collision.Shapes.b2CircleShape","Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2PolygonShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_radius=0;
d.m_top=0;
d.m_bottom=0;
d.m_state=0;
d.m_platform=null;
d.m_character=null;
d.TestOneSidedPlatform=function()
{
var bd=null;
var body=null;
var polygon=null;
var circle=null;
this.Test_constructor();
Main.m_aboutText.set_text("One Sided Platform\n"+"Press: (c) create a shape, (d) destroy a shape.");
bd;
body;
{
bd=new Box2D.Dynamics.b2BodyDef();
bd.position.Set(10.0,10.0);
body=this.m_world.CreateBody(bd);
polygon=Box2D.Collision.Shapes.b2PolygonShape.AsBox(3.0,0.5);
this.m_platform=body.CreateFixture2(polygon);
this.m_bottom=bd.position.y+0.5;
this.m_top=bd.position.y-0.5
};
{
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set(10.0,12.0);
body=this.m_world.CreateBody(bd);
this.m_radius=0.5;
circle=new Box2D.Collision.Shapes.b2CircleShape(this.m_radius);
this.m_character=body.CreateFixture2(circle,1.0);
this.m_state=TestBed.TestOneSidedPlatform.e_unknown
};
this.m_world.SetContactListener(new TestBed.ContactListener(this));
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
this.e_unknown=0;
this.e_above=1;
this.e_below=2;
};
flash.addDescription("TestBed.TestOneSidedPlatform",d,"TestBed.Test",s,null,["Main","Box2D.Dynamics.b2BodyDef","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.b2Body","Box2D.Collision.Shapes.b2CircleShape","TestBed.ContactListener"]);
}
());
(function()
{
"use strict";
var d={};
d.test=null;
d.ContactListener=function(test)
{
this.test=test;
};
d.PreSolve=function(contact,oldManifold)
{
var fixtureA=null;
var fixtureB=null;
var position=null;
fixtureA=contact.GetFixtureA();
fixtureB=contact.GetFixtureB();
if(fixtureA!=this.test.m_platform&&fixtureA!=this.test.m_character)
{
return
}
if(fixtureB!=this.test.m_platform&&fixtureB!=this.test.m_character)
{
return
}
position=this.test.m_character.GetBody().GetPosition();
if(position.y>this.test.m_top)
{
contact.SetEnabled(false)
}
};
flash.addDescription("TestBed.ContactListener",d,"Box2D.Dynamics.b2ContactListener",null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.TestCCD=function()
{
var bd=null;
var body=null;
var fixtureDef=null;
var sd_bottom=null;
var sd_left=null;
var sd_right=null;
var i=0;
var cd=null;
this.Test_constructor();
Main.m_aboutText.set_text("Continuous Collision Detection");
bd;
body;
fixtureDef=new Box2D.Dynamics.b2FixtureDef();
fixtureDef.density=4.0;
fixtureDef.restitution=1.4;
{
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.bullet=true;
bd.position.Set(150.0/this.m_physScale,100.0/this.m_physScale);
body=this.m_world.CreateBody(bd);
sd_bottom=new Box2D.Collision.Shapes.b2PolygonShape();
sd_bottom.SetAsBox(45.0/this.m_physScale,4.5/this.m_physScale);
fixtureDef.shape=sd_bottom;
body.CreateFixture(fixtureDef);
sd_left=new Box2D.Collision.Shapes.b2PolygonShape();
sd_left.SetAsOrientedBox(4.5/this.m_physScale,81.0/this.m_physScale,new Box2D.Common.Math.b2Vec2(-43.5/this.m_physScale,-70.5/this.m_physScale),-0.2);
fixtureDef.shape=sd_left;
body.CreateFixture(fixtureDef);
sd_right=new Box2D.Collision.Shapes.b2PolygonShape();
sd_right.SetAsOrientedBox(4.5/this.m_physScale,81.0/this.m_physScale,new Box2D.Common.Math.b2Vec2(43.5/this.m_physScale,-70.5/this.m_physScale),0.2);
fixtureDef.shape=sd_right;
body.CreateFixture(fixtureDef)
};
for(i=0;i<5;i++)
{
cd=new Box2D.Collision.Shapes.b2CircleShape((Math.random()*10+5)/this.m_physScale);
fixtureDef.shape=cd;
fixtureDef.friction=0.3;
fixtureDef.density=1.0;
fixtureDef.restitution=1.1;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.bullet=true;
bd.position.Set((Math.random()*300+250)/this.m_physScale,(Math.random()*320+20)/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fixtureDef)
}
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
};
flash.addDescription("TestBed.TestCCD",d,"TestBed.Test",s,null,["Main","Box2D.Dynamics.b2FixtureDef","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2CircleShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.TestBridge=function()
{
var ground=null;
var i=0;
var anchor=null;
var body=null;
var sd=null;
var fixtureDef=null;
var bd=null;
var jd=null;
var numPlanks=0;
var prevBody=null;
var bodyDef=null;
var boxShape=null;
var bodyDefC=null;
var circShape=null;
var j=0;
var bodyDefP=null;
var polyShape=null;
var vertices=null;
var vertexCount=0;
this.Test_constructor();
Main.m_aboutText.set_text("Bridge");
ground=this.m_world.GetGroundBody();
i;
anchor=new Box2D.Common.Math.b2Vec2();
body;
{
sd=new Box2D.Collision.Shapes.b2PolygonShape();
fixtureDef=new Box2D.Dynamics.b2FixtureDef();
sd.SetAsBox(24/this.m_physScale,5/this.m_physScale);
fixtureDef.shape=sd;
fixtureDef.density=20.0;
fixtureDef.friction=0.2;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
jd=new Box2D.Dynamics.Joints.b2RevoluteJointDef();
numPlanks=10;
jd.lowerAngle=-15/(180/Math.PI);
jd.upperAngle=15/(180/Math.PI);
jd.enableLimit=true;
prevBody=ground;
for(i=0;i<numPlanks;++i)
{
bd.position.Set((100+22+44*i)/this.m_physScale,250/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fixtureDef);
anchor.Set((100+44*i)/this.m_physScale,250/this.m_physScale);
jd.Initialize(prevBody,body,anchor);
this.m_world.CreateJoint(jd);
prevBody=body
}
anchor.Set((100+44*numPlanks)/this.m_physScale,250/this.m_physScale);
jd.Initialize(prevBody,ground,anchor);
this.m_world.CreateJoint(jd)
};
for(i=0;i<5;i++)
{
bodyDef=new Box2D.Dynamics.b2BodyDef();
bodyDef.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
boxShape=new Box2D.Collision.Shapes.b2PolygonShape();
fixtureDef.shape=boxShape;
fixtureDef.density=1.0;
fixtureDef.friction=0.3;
fixtureDef.restitution=0.1;
boxShape.SetAsBox((Math.random()*5+10)/this.m_physScale,(Math.random()*5+10)/this.m_physScale);
bodyDef.position.Set((Math.random()*400+120)/this.m_physScale,(Math.random()*150+50)/this.m_physScale);
bodyDef.angle=Math.random()*Math.PI;
body=this.m_world.CreateBody(bodyDef);
body.CreateFixture(fixtureDef)
}
for(i=0;i<5;i++)
{
bodyDefC=new Box2D.Dynamics.b2BodyDef();
bodyDefC.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
circShape=new Box2D.Collision.Shapes.b2CircleShape((Math.random()*5+10)/this.m_physScale);
fixtureDef.shape=circShape;
fixtureDef.density=1.0;
fixtureDef.friction=0.3;
fixtureDef.restitution=0.1;
bodyDefC.position.Set((Math.random()*400+120)/this.m_physScale,(Math.random()*150+50)/this.m_physScale);
bodyDefC.angle=Math.random()*Math.PI;
body=this.m_world.CreateBody(bodyDefC);
body.CreateFixture(fixtureDef)
}
j;
for(i=0;i<15;i++)
{
bodyDefP=new Box2D.Dynamics.b2BodyDef();
bodyDefP.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
polyShape=new Box2D.Collision.Shapes.b2PolygonShape();
vertices=new Array();
vertexCount;
if(Math.random()>0.66)
{
vertexCount=4;
for(j=0;j<vertexCount;++j)
{
vertices[j]=new Box2D.Common.Math.b2Vec2()
}
vertices[0].Set((-10-Math.random()*10)/this.m_physScale,(10+Math.random()*10)/this.m_physScale);
vertices[1].Set((-5-Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale);
vertices[2].Set((5+Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale);
vertices[3].Set((10+Math.random()*10)/this.m_physScale,(10+Math.random()*10)/this.m_physScale)
}
else if(Math.random()>0.5)
{
vertexCount=5;
for(j=0;j<vertexCount;++j)
{
vertices[j]=new Box2D.Common.Math.b2Vec2()
}
vertices[0].Set(0,(10+Math.random()*10)/this.m_physScale);
vertices[2].Set((-5-Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale);
vertices[3].Set((5+Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale);
vertices[1].Set((vertices[0].x+vertices[2].x),(vertices[0].y+vertices[2].y));
vertices[1].Multiply(Math.random()/2+0.8);
vertices[4].Set((vertices[3].x+vertices[0].x),(vertices[3].y+vertices[0].y));
vertices[4].Multiply(Math.random()/2+0.8)
}
else
{
vertexCount=3;
for(j=0;j<vertexCount;++j)
{
vertices[j]=new Box2D.Common.Math.b2Vec2()
}
vertices[0].Set(0,(10+Math.random()*10)/this.m_physScale);
vertices[1].Set((-5-Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale);
vertices[2].Set((5+Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale)
}
polyShape.SetAsArray(vertices,vertexCount);
fixtureDef.shape=polyShape;
fixtureDef.density=1.0;
fixtureDef.friction=0.3;
fixtureDef.restitution=0.1;
bodyDefP.position.Set((Math.random()*400+120)/this.m_physScale,(Math.random()*150+50)/this.m_physScale);
bodyDefP.angle=Math.random()*Math.PI;
body=this.m_world.CreateBody(bodyDefP);
body.CreateFixture(fixtureDef)
}
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
};
flash.addDescription("TestBed.TestBridge",d,"TestBed.Test",s,null,["Main","Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.b2FixtureDef","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Dynamics.Joints.b2RevoluteJointDef","Box2D.Collision.Shapes.b2CircleShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.laser=null;
d.TestRaycast=function()
{
var ground=null;
var box=null;
var fd=null;
var bd=null;
var circle=null;
var body=null;
this.Test_constructor();
Main.m_aboutText.set_text("Raycast");
this.m_world.SetGravity(new Box2D.Common.Math.b2Vec2(0,0));
ground=this.m_world.GetGroundBody();
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(30/this.m_physScale,4/this.m_physScale);
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=box;
fd.density=4;
fd.friction=0.4;
fd.restitution=0.3;
fd.userData="laser";
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set(320/this.m_physScale,150/this.m_physScale);
bd.position.Set(40/this.m_physScale,150/this.m_physScale);
this.laser=this.m_world.CreateBody(bd);
this.laser.CreateFixture(fd);
this.laser.SetAngle(0.5);
this.laser.SetAngle(Math.PI);
circle=new Box2D.Collision.Shapes.b2CircleShape(30/this.m_physScale);
fd.shape=circle;
fd.density=4;
fd.friction=0.4;
fd.restitution=0.3;
fd.userData="circle";
bd.position.Set(100/this.m_physScale,100/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fd);
};
d.Update=function()
{
var p1=null;
var p2=null;
var f=null;
var lambda=0;
var input=null;
var output=null;
this.Test_Update();
p1=this.laser.GetWorldPoint(new Box2D.Common.Math.b2Vec2(30.1/this.m_physScale,0));
p2=this.laser.GetWorldPoint(new Box2D.Common.Math.b2Vec2(130.1/this.m_physScale,0));
f=this.m_world.RayCastOne(p1,p2);
lambda=1;
if(f)
{
input=new Box2D.Collision.b2RayCastInput(p1,p2);
output=new Box2D.Collision.b2RayCastOutput();
f.RayCast(output,input);
lambda=output.fraction
}
this.m_sprite.get_graphics().lineStyle(1,0xff0000,1);
this.m_sprite.get_graphics().moveTo(p1.x*this.m_physScale,p1.y*this.m_physScale);
this.m_sprite.get_graphics().lineTo((p2.x*lambda+(1-lambda)*p1.x)*this.m_physScale,(p2.y*lambda+(1-lambda)*p1.y)*this.m_physScale);
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
this.prototype.Test_Update=this.__base__.prototype.Update;
};
flash.addDescription("TestBed.TestRaycast",d,"TestBed.Test",s,null,["Main","Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.b2FixtureDef","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Collision.Shapes.b2CircleShape","Box2D.Collision.b2RayCastInput","Box2D.Collision.b2RayCastOutput"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_gJoint1=null;
d.m_gJoint2=null;
d.m_gJoint3=null;
d.m_gJoint4=null;
d.m_gJoint5=null;
d.m_joint1=null;
d.m_joint2=null;
d.TestCrankGearsPulley=function()
{
var ground=null;
var body=null;
var circleBody=null;
var sd=null;
var bd=null;
var fixtureDef=null;
var rjd=null;
var prevBody=null;
var pjd=null;
var circle1=null;
var bd1=null;
var body1=null;
var jd1=null;
var circle2=null;
var bd2=null;
var body2=null;
var jd2=null;
var box=null;
var bd3=null;
var body3=null;
var jd3=null;
var jd4=null;
var jd5=null;
var pulleyDef=null;
var anchor1=null;
var anchor2=null;
var groundAnchor1=null;
var groundAnchor2=null;
var circ=null;
var ljd=null;
var fjd=null;
var wjd=null;
this.Test_constructor();
Main.m_aboutText.set_text("Joints");
ground=this.m_world.GetGroundBody();
body;
circleBody;
sd;
bd;
fixtureDef=new Box2D.Dynamics.b2FixtureDef();
{
sd=new Box2D.Collision.Shapes.b2PolygonShape();
sd.SetAsBox(7.5/this.m_physScale,30.0/this.m_physScale);
fixtureDef.shape=sd;
fixtureDef.density=1.0;
rjd=new Box2D.Dynamics.Joints.b2RevoluteJointDef();
prevBody=ground;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set(100.0/this.m_physScale,(360.0-105.0)/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fixtureDef);
rjd.Initialize(prevBody,body,new Box2D.Common.Math.b2Vec2(100.0/this.m_physScale,(360.0-75.0)/this.m_physScale));
rjd.motorSpeed=1.0*-Math.PI;
rjd.maxMotorTorque=5000.0;
rjd.enableMotor=true;
this.m_joint1=this.m_world.CreateJoint(rjd);
prevBody=body;
sd=new Box2D.Collision.Shapes.b2PolygonShape;
sd.SetAsBox(7.5/this.m_physScale,60.0/this.m_physScale);
fixtureDef.shape=sd;
bd.position.Set(100.0/this.m_physScale,(360.0-195.0)/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fixtureDef);
rjd.Initialize(prevBody,body,new Box2D.Common.Math.b2Vec2(100.0/this.m_physScale,(360.0-135.0)/this.m_physScale));
rjd.enableMotor=false;
this.m_world.CreateJoint(rjd);
prevBody=body;
sd=new Box2D.Collision.Shapes.b2PolygonShape();
sd.SetAsBox(22.5/this.m_physScale,22.5/this.m_physScale);
fixtureDef.shape=sd;
bd.position.Set(100.0/this.m_physScale,(360.0-255.0)/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fixtureDef);
rjd.Initialize(prevBody,body,new Box2D.Common.Math.b2Vec2(100.0/this.m_physScale,(360.0-255.0)/this.m_physScale));
this.m_world.CreateJoint(rjd);
pjd=new Box2D.Dynamics.Joints.b2PrismaticJointDef();
pjd.Initialize(ground,body,new Box2D.Common.Math.b2Vec2(100.0/this.m_physScale,(360.0-255.0)/this.m_physScale),new Box2D.Common.Math.b2Vec2(0.0,1.0));
pjd.maxMotorForce=500.0;
pjd.enableMotor=true;
this.m_joint2=this.m_world.CreateJoint(pjd);
sd=new Box2D.Collision.Shapes.b2PolygonShape();
sd.SetAsBox(22.5/this.m_physScale,22.5/this.m_physScale);
fixtureDef.shape=sd;
fixtureDef.density=2.0;
bd.position.Set(100.0/this.m_physScale,(360.0-345.0)/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fixtureDef)
};
circle1=new Box2D.Collision.Shapes.b2CircleShape(25/this.m_physScale);
fixtureDef.shape=circle1;
fixtureDef.density=5.0;
bd1=new Box2D.Dynamics.b2BodyDef();
bd1.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd1.position.Set(200/this.m_physScale,360/2/this.m_physScale);
body1=this.m_world.CreateBody(bd1);
body1.CreateFixture(fixtureDef);
jd1=new Box2D.Dynamics.Joints.b2RevoluteJointDef();
jd1.Initialize(ground,body1,bd1.position);
this.m_gJoint1=this.m_world.CreateJoint(jd1);
circle2=new Box2D.Collision.Shapes.b2CircleShape(50/this.m_physScale);
fixtureDef.shape=circle2;
fixtureDef.density=5.0;
bd2=new Box2D.Dynamics.b2BodyDef();
bd2.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd2.position.Set(275/this.m_physScale,360/2/this.m_physScale);
body2=this.m_world.CreateBody(bd2);
body2.CreateFixture(fixtureDef);
jd2=new Box2D.Dynamics.Joints.b2RevoluteJointDef();
jd2.Initialize(ground,body2,bd2.position);
this.m_gJoint2=this.m_world.CreateJoint(jd2);
box=new Box2D.Collision.Shapes.b2PolygonShape();
box.SetAsBox(10/this.m_physScale,100/this.m_physScale);
fixtureDef.shape=box;
fixtureDef.density=5.0;
bd3=new Box2D.Dynamics.b2BodyDef();
bd3.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd3.position.Set(335/this.m_physScale,360/2/this.m_physScale);
body3=this.m_world.CreateBody(bd3);
body3.CreateFixture(fixtureDef);
jd3=new Box2D.Dynamics.Joints.b2PrismaticJointDef();
jd3.Initialize(ground,body3,bd3.position,new Box2D.Common.Math.b2Vec2(0,1));
jd3.lowerTranslation=-25.0/this.m_physScale;
jd3.upperTranslation=100.0/this.m_physScale;
jd3.enableLimit=true;
this.m_gJoint3=this.m_world.CreateJoint(jd3);
jd4=new Box2D.Dynamics.Joints.b2GearJointDef();
jd4.bodyA=body1;
jd4.bodyB=body2;
jd4.joint1=this.m_gJoint1;
jd4.joint2=this.m_gJoint2;
jd4.ratio=circle2.GetRadius()/circle1.GetRadius();
this.m_gJoint4=this.m_world.CreateJoint(jd4);
jd5=new Box2D.Dynamics.Joints.b2GearJointDef();
jd5.bodyA=body2;
jd5.bodyB=body3;
jd5.joint1=this.m_gJoint2;
jd5.joint2=this.m_gJoint3;
jd5.ratio=-1.0/circle2.GetRadius();
this.m_gJoint5=this.m_world.CreateJoint(jd5);
sd=new Box2D.Collision.Shapes.b2PolygonShape();
sd.SetAsBox(50/this.m_physScale,20/this.m_physScale);
fixtureDef.shape=sd;
fixtureDef.density=5.0;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set(480/this.m_physScale,200/this.m_physScale);
body2=this.m_world.CreateBody(bd);
body2.CreateFixture(fixtureDef);
pulleyDef=new Box2D.Dynamics.Joints.b2PulleyJointDef();
anchor1=new Box2D.Common.Math.b2Vec2(335/this.m_physScale,180/this.m_physScale);
anchor2=new Box2D.Common.Math.b2Vec2(480/this.m_physScale,180/this.m_physScale);
groundAnchor1=new Box2D.Common.Math.b2Vec2(335/this.m_physScale,50/this.m_physScale);
groundAnchor2=new Box2D.Common.Math.b2Vec2(480/this.m_physScale,50/this.m_physScale);
pulleyDef.Initialize(body3,body2,groundAnchor1,groundAnchor2,anchor1,anchor2,2.0);
pulleyDef.maxLengthA=200/this.m_physScale;
pulleyDef.maxLengthB=150/this.m_physScale;
this.m_world.CreateJoint(pulleyDef);
circ=new Box2D.Collision.Shapes.b2CircleShape(40/this.m_physScale);
fixtureDef.shape=circ;
fixtureDef.friction=0.3;
fixtureDef.restitution=0.3;
fixtureDef.density=5.0;
bd.position.Set(485/this.m_physScale,100/this.m_physScale);
body1=circleBody=this.m_world.CreateBody(bd);
body1.CreateFixture(fixtureDef);
{
sd=new Box2D.Collision.Shapes.b2PolygonShape();
sd.SetAsBox(7.5/this.m_physScale,30.0/this.m_physScale);
fixtureDef.shape=sd;
fixtureDef.density=1.0;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set(500/this.m_physScale,500/2/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture(fixtureDef);
ljd=new Box2D.Dynamics.Joints.b2LineJointDef();
ljd.Initialize(ground,body,body.GetPosition(),new Box2D.Common.Math.b2Vec2(0.4,0.6));
ljd.lowerTranslation=-1;
ljd.upperTranslation=1;
ljd.enableLimit=true;
ljd.maxMotorForce=1;
ljd.motorSpeed=0;
ljd.enableMotor=true;
this.m_world.CreateJoint(ljd)
};
{
fjd=new Box2D.Dynamics.Joints.b2FrictionJointDef();
fjd.Initialize(circleBody,this.m_world.GetGroundBody(),circleBody.GetPosition());
fjd.collideConnected=true;
fjd.maxForce=200;
this.m_world.CreateJoint(fjd)
};
if(false)
{
wjd=new Box2D.Dynamics.Joints.b2WeldJointDef();
wjd.Initialize(circleBody,body,circleBody.GetPosition());
this.m_world.CreateJoint(wjd)
}
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
};
flash.addDescription("TestBed.TestCrankGearsPulley",d,"TestBed.Test",s,null,["Main","Box2D.Dynamics.b2FixtureDef","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.Joints.b2RevoluteJointDef","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2RevoluteJoint","Box2D.Dynamics.Joints.b2PrismaticJointDef","Box2D.Dynamics.Joints.b2PrismaticJoint","Box2D.Collision.Shapes.b2CircleShape","Box2D.Dynamics.Joints.b2GearJointDef","Box2D.Dynamics.Joints.b2GearJoint","Box2D.Dynamics.Joints.b2PulleyJointDef","Box2D.Dynamics.Joints.b2PulleyJoint","Box2D.Dynamics.Joints.b2LineJointDef","Box2D.Dynamics.Joints.b2FrictionJointDef","Box2D.Dynamics.Joints.b2WeldJointDef"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_body1=null;
d.m_velocity=null;
d.m_angularVelocity=0;
d.m_shape1=null;
d.m_shape2=null;
d.m_piece1=null;
d.m_piece2=null;
d.m_broke=false;
d.m_break=false;
d.TestBreakable=function()
{
this.m_velocity=new Box2D.Common.Math.b2Vec2();
this.m_shape1=new Box2D.Collision.Shapes.b2PolygonShape();
this.m_shape2=new Box2D.Collision.Shapes.b2PolygonShape();
var ground=null;
var bd=null;
this.Test_constructor();
Main.m_aboutText.set_text("Breakable");
this.m_world.SetContactListener(new TestBed.ContactListener(this));
ground=this.m_world.GetGroundBody();
{
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set(5.0,5.0);
bd.angle=0.25*Math.PI;
this.m_body1=this.m_world.CreateBody(bd);
this.m_shape1.SetAsOrientedBox(0.5,0.5,new Box2D.Common.Math.b2Vec2(-0.5,0.0));
this.m_piece1=this.m_body1.CreateFixture2(this.m_shape1,1.0);
this.m_shape2.SetAsOrientedBox(0.5,0.5,new Box2D.Common.Math.b2Vec2(0.5,0.0));
this.m_piece2=this.m_body1.CreateFixture2(this.m_shape2,1.0)
};
this.m_break=false;
this.m_broke=false;
};
d.Update=function()
{
this.Test_Update();
if(this.m_break)
{
this.Break();
this.m_broke=true;
this.m_break=false
}
if(this.m_broke==false)
{
this.m_velocity=this.m_body1.GetLinearVelocity();
this.m_angularVelocity=this.m_body1.GetAngularVelocity()
}
};
d.Break=function()
{
this.m_body1.SetLinearVelocity(this.m_velocity);
this.m_body1.SetAngularVelocity(this.m_angularVelocity);
this.m_body1.Split(flash.bindFunction(this,function(fixture)
{
return fixture!=this.m_piece1;
}
));
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
this.prototype.Test_Update=this.__base__.prototype.Update;
};
flash.addDescription("TestBed.TestBreakable",d,"TestBed.Test",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2PolygonShape","Main","TestBed.ContactListener","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body"]);
}
());
(function()
{
"use strict";
var d={};
d.test=null;
d.ContactListener=function(test)
{
this.test=test;
};
d.PostSolve=function(contact,impulse)
{
var count=0;
var maxImpulse=0;
var i=0;
if(this.test.m_broke)
{
return
}
count=contact.GetManifold().m_pointCount;
maxImpulse=0.0;
for(i=0;i<count;i++)
{
maxImpulse=Box2D.Common.Math.b2Math.Max(maxImpulse,impulse.normalImpulses[i])
}
if(maxImpulse>50)
{
this.test.m_break=true
}
};
flash.addDescription("TestBed.ContactListener",d,"Box2D.Dynamics.b2ContactListener",null,null,["Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.tScale=0;
d.m_offset=null;
d.m_chassis=null;
d.m_wheel=null;
d.m_motorJoint=null;
d.m_motorOn=false;
d.m_motorSpeed=0;
d.TestTheoJansen=function()
{
this.m_offset=new Box2D.Common.Math.b2Vec2();
this.m_motorOn=true;
var pivot=null;
var pd=null;
var cd=null;
var fd=null;
var bd=null;
var body=null;
var i=0;
var jd=null;
var po=null;
var wheelAnchor=null;
this.Test_constructor();
Main.m_aboutText.set_text("Theo Jansen Walker");
this.tScale=this.m_physScale*2;
this.m_offset.Set(120.0/this.m_physScale,250/this.m_physScale);
this.m_motorSpeed=-2.0;
this.m_motorOn=true;
pivot=new Box2D.Common.Math.b2Vec2(0.0,-24.0/this.tScale);
pd;
cd;
fd;
bd;
body;
for(i=0;i<40;++i)
{
cd=new Box2D.Collision.Shapes.b2CircleShape(7.5/this.tScale);
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position.Set((Math.random()*620+10)/this.m_physScale,350/this.m_physScale);
body=this.m_world.CreateBody(bd);
body.CreateFixture2(cd,1.0)
}
{
pd=new Box2D.Collision.Shapes.b2PolygonShape();
pd.SetAsBox(75/this.tScale,30/this.tScale);
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=pd;
fd.density=1.0;
fd.filter.groupIndex=-1;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position=Box2D.Common.Math.b2Math.AddVV(pivot,this.m_offset);
this.m_chassis=this.m_world.CreateBody(bd);
this.m_chassis.CreateFixture(fd)
};
{
cd=new Box2D.Collision.Shapes.b2CircleShape(48/this.tScale);
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=cd;
fd.density=1.0;
fd.filter.groupIndex=-1;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.position=Box2D.Common.Math.b2Math.AddVV(pivot,this.m_offset);
this.m_wheel=this.m_world.CreateBody(bd);
this.m_wheel.CreateFixture(fd)
};
{
jd=new Box2D.Dynamics.Joints.b2RevoluteJointDef();
po=pivot.Copy();
po.Add(this.m_offset);
jd.Initialize(this.m_wheel,this.m_chassis,po);
jd.collideConnected=false;
jd.motorSpeed=this.m_motorSpeed;
jd.maxMotorTorque=400.0;
jd.enableMotor=this.m_motorOn;
this.m_motorJoint=this.m_world.CreateJoint(jd)
};
wheelAnchor;
wheelAnchor=new Box2D.Common.Math.b2Vec2(0.0,24.0/this.tScale);
wheelAnchor.Add(pivot);
this.CreateLeg(-1.0,wheelAnchor);
this.CreateLeg(1.0,wheelAnchor);
this.m_wheel.SetPositionAndAngle(this.m_wheel.GetPosition(),120.0*Math.PI/180.0);
this.CreateLeg(-1.0,wheelAnchor);
this.CreateLeg(1.0,wheelAnchor);
this.m_wheel.SetPositionAndAngle(this.m_wheel.GetPosition(),-120.0*Math.PI/180.0);
this.CreateLeg(-1.0,wheelAnchor);
this.CreateLeg(1.0,wheelAnchor);
};
d.Update=function()
{
if(General.Input.isKeyPressed(65))
{
this.m_chassis.SetAwake(true);
this.m_motorJoint.SetMotorSpeed(-this.m_motorSpeed)
}
if(General.Input.isKeyPressed(83))
{
this.m_chassis.SetAwake(true);
this.m_motorJoint.SetMotorSpeed(0.0)
}
if(General.Input.isKeyPressed(68))
{
this.m_chassis.SetAwake(true);
this.m_motorJoint.SetMotorSpeed(this.m_motorSpeed)
}
if(General.Input.isKeyPressed(77))
{
this.m_chassis.SetAwake(true);
this.m_motorJoint.EnableMotor(!this.m_motorJoint.IsMotorEnabled())
}
this.Test_Update();
};
d.CreateLeg=function(s,wheelAnchor)
{
var p1=null;
var p2=null;
var p3=null;
var p4=null;
var p5=null;
var p6=null;
var sd1=null;
var sd2=null;
var fd1=null;
var fd2=null;
var bd1=null;
var bd2=null;
var body1=null;
var body2=null;
var djd=null;
var rjd=null;
p1=new Box2D.Common.Math.b2Vec2(162*s/this.tScale,183/this.tScale);
p2=new Box2D.Common.Math.b2Vec2(216*s/this.tScale,36/this.tScale);
p3=new Box2D.Common.Math.b2Vec2(129*s/this.tScale,57/this.tScale);
p4=new Box2D.Common.Math.b2Vec2(93*s/this.tScale,-24/this.tScale);
p5=new Box2D.Common.Math.b2Vec2(180*s/this.tScale,-45/this.tScale);
p6=new Box2D.Common.Math.b2Vec2(75*s/this.tScale,-111/this.tScale);
sd1=new Box2D.Collision.Shapes.b2PolygonShape();
sd2=new Box2D.Collision.Shapes.b2PolygonShape();
fd1=new Box2D.Dynamics.b2FixtureDef();
fd2=new Box2D.Dynamics.b2FixtureDef();
fd1.shape=sd1;
fd2.shape=sd2;
fd1.filter.groupIndex=-1;
fd2.filter.groupIndex=-1;
fd1.density=1.0;
fd2.density=1.0;
if(s>0.0)
{
sd1.SetAsArray([p3,p2,p1]);
sd2.SetAsArray([Box2D.Common.Math.b2Math.SubtractVV(p6,p4),Box2D.Common.Math.b2Math.SubtractVV(p5,p4),new Box2D.Common.Math.b2Vec2()])
}
else
{
sd1.SetAsArray([p2,p3,p1]);
sd2.SetAsArray([Box2D.Common.Math.b2Math.SubtractVV(p5,p4),Box2D.Common.Math.b2Math.SubtractVV(p6,p4),new Box2D.Common.Math.b2Vec2()])
}
bd1=new Box2D.Dynamics.b2BodyDef();
bd1.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd2=new Box2D.Dynamics.b2BodyDef();
bd2.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd1.position.SetV(this.m_offset);
bd2.position=Box2D.Common.Math.b2Math.AddVV(p4,this.m_offset);
bd1.angularDamping=10.0;
bd2.angularDamping=10.0;
body1=this.m_world.CreateBody(bd1);
body2=this.m_world.CreateBody(bd2);
body1.CreateFixture(fd1);
body2.CreateFixture(fd2);
djd=new Box2D.Dynamics.Joints.b2DistanceJointDef();
djd.dampingRatio=0.5;
djd.frequencyHz=10.0;
djd.Initialize(body1,body2,Box2D.Common.Math.b2Math.AddVV(p2,this.m_offset),Box2D.Common.Math.b2Math.AddVV(p5,this.m_offset));
this.m_world.CreateJoint(djd);
djd.Initialize(body1,body2,Box2D.Common.Math.b2Math.AddVV(p3,this.m_offset),Box2D.Common.Math.b2Math.AddVV(p4,this.m_offset));
this.m_world.CreateJoint(djd);
djd.Initialize(body1,this.m_wheel,Box2D.Common.Math.b2Math.AddVV(p3,this.m_offset),Box2D.Common.Math.b2Math.AddVV(wheelAnchor,this.m_offset));
this.m_world.CreateJoint(djd);
djd.Initialize(body2,this.m_wheel,Box2D.Common.Math.b2Math.AddVV(p6,this.m_offset),Box2D.Common.Math.b2Math.AddVV(wheelAnchor,this.m_offset));
this.m_world.CreateJoint(djd);
rjd=new Box2D.Dynamics.Joints.b2RevoluteJointDef();
rjd.Initialize(body2,this.m_chassis,Box2D.Common.Math.b2Math.AddVV(p4,this.m_offset));
this.m_world.CreateJoint(rjd);
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
this.prototype.Test_Update=this.__base__.prototype.Update;
};
flash.addDescription("TestBed.TestTheoJansen",d,"TestBed.Test",s,null,["Box2D.Common.Math.b2Vec2","Main","Box2D.Collision.Shapes.b2CircleShape","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.b2FixtureDef","Box2D.Common.Math.b2Math","Box2D.Dynamics.Joints.b2RevoluteJointDef","Box2D.Dynamics.Joints.b2RevoluteJoint","General.Input","Box2D.Dynamics.Joints.b2DistanceJointDef"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_world=null;
d.m_bomb=null;
d.m_mouseJoint=null;
d.m_velocityIterations=0;
d.m_positionIterations=0;
d.m_timeStep=0;
d.m_physScale=0;
d.m_sprite=null;
d.mousePVec=null;
d.Test=function()
{
this.m_velocityIterations=10;
this.m_positionIterations=10;
this.m_timeStep=1.0/30.0;
this.m_physScale=30;
this.mousePVec=new Box2D.Common.Math.b2Vec2();
var worldAABB=null;
var gravity=null;
var doSleep=false;
var dbgDraw=null;
var wall=null;
var wallBd=null;
var wallB=null;
this.m_sprite=Main.m_sprite;
worldAABB=new Box2D.Collision.b2AABB();
worldAABB.lowerBound.Set(-1000.0,-1000.0);
worldAABB.upperBound.Set(1000.0,1000.0);
gravity=new Box2D.Common.Math.b2Vec2(0.0,10.0);
doSleep=true;
this.m_world=new Box2D.Dynamics.b2World(gravity,doSleep);
this.m_world.SetWarmStarting(true);
dbgDraw=new Box2D.Dynamics.b2DebugDraw();
dbgDraw.SetSprite(this.m_sprite);
dbgDraw.SetDrawScale(30.0);
dbgDraw.SetFillAlpha(0.3);
dbgDraw.SetLineThickness(1.0);
dbgDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit|Box2D.Dynamics.b2DebugDraw.e_jointBit);
this.m_world.SetDebugDraw(dbgDraw);
wall=new Box2D.Collision.Shapes.b2PolygonShape();
wallBd=new Box2D.Dynamics.b2BodyDef();
wallB;
wallBd.position.Set(-95/this.m_physScale,360/this.m_physScale/2);
wall.SetAsBox(100/this.m_physScale,400/this.m_physScale/2);
wallB=this.m_world.CreateBody(wallBd);
wallB.CreateFixture2(wall);
wallBd.position.Set((640+95)/this.m_physScale,360/this.m_physScale/2);
wallB=this.m_world.CreateBody(wallBd);
wallB.CreateFixture2(wall);
wallBd.position.Set(640/this.m_physScale/2,-95/this.m_physScale);
wall.SetAsBox(680/this.m_physScale/2,100/this.m_physScale);
wallB=this.m_world.CreateBody(wallBd);
wallB.CreateFixture2(wall);
wallBd.position.Set(640/this.m_physScale/2,(360+95)/this.m_physScale);
wallB=this.m_world.CreateBody(wallBd);
wallB.CreateFixture2(wall);
};
d.Update=function()
{
var physStart=0;
this.UpdateMouseWorld();
this.MouseDestroy();
this.MouseDrag();
physStart=flash.utils.getTimer();
this.m_world.Step(this.m_timeStep,this.m_velocityIterations,this.m_positionIterations);
this.m_world.ClearForces();
Main.m_fpsCounter.updatePhys(physStart);
this.m_world.DrawDebugData();
};
d.UpdateMouseWorld=function()
{
TestBed.Test.mouseXWorldPhys=(General.Input.mouseX)/this.m_physScale;
TestBed.Test.mouseYWorldPhys=(General.Input.mouseY)/this.m_physScale;
TestBed.Test.mouseXWorld=(General.Input.mouseX);
TestBed.Test.mouseYWorld=(General.Input.mouseY);
};
d.MouseDrag=function()
{
var body=null;
var md=null;
var p2=null;
if(General.Input.mouseDown&&!this.m_mouseJoint)
{
body=this.GetBodyAtMouse();
if(body)
{
md=new Box2D.Dynamics.Joints.b2MouseJointDef();
md.bodyA=this.m_world.GetGroundBody();
md.bodyB=body;
md.target.Set(TestBed.Test.mouseXWorldPhys,TestBed.Test.mouseYWorldPhys);
md.collideConnected=true;
md.maxForce=300.0*body.GetMass();
this.m_mouseJoint=this.m_world.CreateJoint(md);
body.SetAwake(true)
}
}
if(!General.Input.mouseDown)
{
if(this.m_mouseJoint)
{
this.m_world.DestroyJoint(this.m_mouseJoint);
this.m_mouseJoint=null
}
}
if(this.m_mouseJoint)
{
p2=new Box2D.Common.Math.b2Vec2(TestBed.Test.mouseXWorldPhys,TestBed.Test.mouseYWorldPhys);
this.m_mouseJoint.SetTarget(p2)
}
};
d.MouseDestroy=function()
{
var body=null;
if(!General.Input.mouseDown&&General.Input.isKeyPressed(68))
{
body=this.GetBodyAtMouse(true);
if(body)
{
this.m_world.DestroyBody(body);
return
}
}
};
d.GetBodyAtMouse=function(includeStatic)
{
if(includeStatic==undefined)includeStatic=false;
var aabb=null;
var body=null;
var fixture=null;
this.mousePVec.Set(TestBed.Test.mouseXWorldPhys,TestBed.Test.mouseYWorldPhys);
aabb=new Box2D.Collision.b2AABB();
aabb.lowerBound.Set(TestBed.Test.mouseXWorldPhys-0.001,TestBed.Test.mouseYWorldPhys-0.001);
aabb.upperBound.Set(TestBed.Test.mouseXWorldPhys+0.001,TestBed.Test.mouseYWorldPhys+0.001);
body=null;
fixture;
var GetBodyCallback=flash.bindFunction(this,function(fixture)
{
var shape=null;
var inside=false;
shape=fixture.GetShape();
if(fixture.GetBody().GetType()!=Box2D.Dynamics.b2Body.b2_staticBody||includeStatic)
{
inside=shape.TestPoint(fixture.GetBody().GetTransform(),this.mousePVec);
if(inside)
{
body=fixture.GetBody();
return false
}
}
return true;
}
);
this.m_world.QueryAABB(GetBodyCallback,aabb);
return body;
};
var s={};
s.__init__=function()
{
this.mouseXWorldPhys=0;
this.mouseYWorldPhys=0;
this.mouseXWorld=0;
this.mouseYWorld=0;
};
flash.addDescription("TestBed.Test",d,null,s,null,["Box2D.Common.Math.b2Vec2","Main","Box2D.Collision.b2AABB","Box2D.Dynamics.b2World","Box2D.Dynamics.b2DebugDraw","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.b2BodyDef","General.Input","Box2D.Dynamics.Joints.b2MouseJointDef","Box2D.Dynamics.Joints.b2MouseJoint","Box2D.Dynamics.b2Body"]);
}
());;
(function()
{
"use strict";
var d={};
d.TestStack=function()
{
var fd=null;
var sd=null;
var bd=null;
var b=null;
var i=0;
var vxs=null;
var cd=null;
this.Test_constructor();
Main.m_aboutText.set_text("Stacked Boxes");
fd=new Box2D.Dynamics.b2FixtureDef();
sd=new Box2D.Collision.Shapes.b2PolygonShape();
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
b;
fd.density=1.0;
fd.friction=0.5;
fd.restitution=0.1;
fd.shape=sd;
i;
for(i=0;i<10;i++)
{
sd.SetAsBox((10)/this.m_physScale,(10)/this.m_physScale);
bd.position.Set((640/2+100)/this.m_physScale,(360-5-i*25)/this.m_physScale);
b=this.m_world.CreateBody(bd);
b.CreateFixture(fd)
}
for(i=0;i<10;i++)
{
sd.SetAsBox((10)/this.m_physScale,(10)/this.m_physScale);
bd.position.Set((640/2-0+Math.random()*0.02-0.01)/this.m_physScale,(360-5-i*25)/this.m_physScale);
b=this.m_world.CreateBody(bd);
b.CreateFixture(fd)
}
for(i=0;i<10;i++)
{
sd.SetAsBox((10)/this.m_physScale,(10)/this.m_physScale);
bd.position.Set((640/2+200+Math.random()*0.02-0.01)/this.m_physScale,(360-5-i*25)/this.m_physScale);
b=this.m_world.CreateBody(bd);
b.CreateFixture(fd)
}
vxs=[new Box2D.Common.Math.b2Vec2(0,0),new Box2D.Common.Math.b2Vec2(0,-100/this.m_physScale),new Box2D.Common.Math.b2Vec2(200/this.m_physScale,0)];
;sd.SetAsArray(vxs,vxs.length);
fd.density=0;
bd.type=Box2D.Dynamics.b2Body.b2_staticBody;
bd.userData="ramp";
bd.position.Set(0,360/this.m_physScale);
b=this.m_world.CreateBody(bd);
b.CreateFixture(fd);
cd=new Box2D.Collision.Shapes.b2CircleShape();
cd.m_radius=40/this.m_physScale;
fd.density=2;
fd.restitution=0.2;
fd.friction=0.5;
fd.shape=cd;
bd.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
bd.userData="ball";
bd.position.Set(50/this.m_physScale,100/this.m_physScale);
b=this.m_world.CreateBody(bd);
b.CreateFixture(fd);
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
};
flash.addDescription("TestBed.TestStack",d,"TestBed.Test",s,null,["Main","Box2D.Dynamics.b2FixtureDef","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2CircleShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_bodies=null;
d.m_controller=null;
d.TestBuoyancy=function()
{
this.m_bodies=new Array();
var bc=null;
var ground=null;
var i=0;
var anchor=null;
var body=null;
var fd=null;
var bodyDef=null;
var boxDef=null;
var bodyDefC=null;
var circDef=null;
var bodyDefP=null;
var polyDef=null;
var array=null;
var t0=null;
this.Test_constructor();
bc=new Box2D.Dynamics.Controllers.b2BuoyancyController();
this.m_controller=bc;
bc.normal.Set(0,-1);
bc.offset=-200/this.m_physScale;
bc.density=2.0;
bc.linearDrag=5;
bc.angularDrag=2;
ground=this.m_world.GetGroundBody();
i;
anchor=new Box2D.Common.Math.b2Vec2();
body;
fd;
for(i=0;i<5;i++)
{
bodyDef=new Box2D.Dynamics.b2BodyDef();
bodyDef.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
boxDef=new Box2D.Collision.Shapes.b2PolygonShape();
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=boxDef;
fd.density=1.0;
fd.friction=0.3;
fd.restitution=0.1;
boxDef.SetAsBox((Math.random()*5+10)/this.m_physScale,(Math.random()*5+10)/this.m_physScale);
bodyDef.position.Set((Math.random()*400+120)/this.m_physScale,(Math.random()*150+50)/this.m_physScale);
bodyDef.angle=Math.random()*Math.PI;
body=this.m_world.CreateBody(bodyDef);
body.CreateFixture(fd);
this.m_bodies.push(body)
}
for(i=0;i<5;i++)
{
bodyDefC=new Box2D.Dynamics.b2BodyDef();
bodyDefC.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
circDef=new Box2D.Collision.Shapes.b2CircleShape((Math.random()*5+10)/this.m_physScale);
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=circDef;
fd.density=1.0;
fd.friction=0.3;
fd.restitution=0.1;
bodyDefC.position.Set((Math.random()*400+120)/this.m_physScale,(Math.random()*150+50)/this.m_physScale);
bodyDefC.angle=Math.random()*Math.PI;
body=this.m_world.CreateBody(bodyDefC);
body.CreateFixture(fd);
this.m_bodies.push(body)
}
for(i=0;i<15;i++)
{
bodyDefP=new Box2D.Dynamics.b2BodyDef();
bodyDefP.type=Box2D.Dynamics.b2Body.b2_dynamicBody;
polyDef=new Box2D.Collision.Shapes.b2PolygonShape();
if(Math.random()>0.66)
{
polyDef.SetAsArray([new Box2D.Common.Math.b2Vec2((-10-Math.random()*10)/this.m_physScale,(10+Math.random()*10)/this.m_physScale),new Box2D.Common.Math.b2Vec2((-5-Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale),new Box2D.Common.Math.b2Vec2((5+Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale),new Box2D.Common.Math.b2Vec2((10+Math.random()*10)/this.m_physScale,(10+Math.random()*10)/this.m_physScale)])
}
else if(Math.random()>0.5)
{
array=[];
;array[0]=new Box2D.Common.Math.b2Vec2(0,(10+Math.random()*10)/this.m_physScale);
array[2]=new Box2D.Common.Math.b2Vec2((-5-Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale);
array[3]=new Box2D.Common.Math.b2Vec2((5+Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale);
array[1]=new Box2D.Common.Math.b2Vec2((array[0].x+array[2].x),(array[0].y+array[2].y));
array[1].Multiply(Math.random()/2+0.8);
array[4]=new Box2D.Common.Math.b2Vec2((array[3].x+array[0].x),(array[3].y+array[0].y));
array[4].Multiply(Math.random()/2+0.8);
polyDef.SetAsArray(array)
}
else
{
polyDef.SetAsArray([new Box2D.Common.Math.b2Vec2(0,(10+Math.random()*10)/this.m_physScale),new Box2D.Common.Math.b2Vec2((-5-Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale),new Box2D.Common.Math.b2Vec2((5+Math.random()*10)/this.m_physScale,(-10-Math.random()*10)/this.m_physScale)])
}
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=polyDef;
fd.density=1.0;
fd.friction=0.3;
fd.restitution=0.1;
bodyDefP.position.Set((Math.random()*400+120)/this.m_physScale,(Math.random()*150+50)/this.m_physScale);
bodyDefP.angle=Math.random()*Math.PI;
body=this.m_world.CreateBody(bodyDefP);
body.CreateFixture(fd);
this.m_bodies.push(body)
}
boxDef.SetAsBox(40/this.m_physScale,10/this.m_physScale);
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=boxDef;
fd.density=3.0;
bodyDef.position.Set(50/this.m_physScale,300/this.m_physScale);
bodyDef.angle=0;
body=this.m_world.CreateBody(bodyDef);
body.CreateFixture(fd);
this.m_bodies.push(body);
bodyDef.position.Set(300/this.m_physScale,300/this.m_physScale);
body=this.m_world.CreateBody(bodyDef);
circDef=new Box2D.Collision.Shapes.b2CircleShape(7/this.m_physScale);
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=circDef;
fd.density=2;
circDef.m_p.Set(30/this.m_physScale,0/this.m_physScale);
body.CreateFixture(fd);
circDef.m_p.Set(-30/this.m_physScale,0/this.m_physScale);
body.CreateFixture(fd);
circDef.m_p.Set(0/this.m_physScale,30/this.m_physScale);
body.CreateFixture(fd);
circDef.m_p.Set(0/this.m_physScale,-30/this.m_physScale);
body.CreateFixture(fd);
fd=new Box2D.Dynamics.b2FixtureDef();
fd.shape=boxDef;
fd.density=2.0;
boxDef.SetAsBox(30/this.m_physScale,2/this.m_physScale);
body.CreateFixture(fd);
fd.density=2.0;
boxDef.SetAsBox(2/this.m_physScale,30/this.m_physScale);
body.CreateFixture(fd);
this.m_bodies.push(body);
for(t0 in this.m_bodies)
{
body=this.m_bodies[t0];
this.m_controller.AddBody(body)
}
this.m_world.AddController(this.m_controller);
Main.m_aboutText.set_text("Buoyancy");
};
d.Update=function()
{
this.Test_Update();
this.m_sprite.get_graphics().lineStyle(1,0x0000ff,1);
this.m_sprite.get_graphics().moveTo(5,200);
this.m_sprite.get_graphics().lineTo(635,200);
this.m_sprite.get_graphics().lineStyle();
this.m_sprite.get_graphics().beginFill(0x0000ff,0.2);
this.m_sprite.get_graphics().moveTo(5,200);
this.m_sprite.get_graphics().lineTo(635,200);
this.m_sprite.get_graphics().lineTo(635,355);
this.m_sprite.get_graphics().lineTo(5,355);
this.m_sprite.get_graphics().endFill();
};
var s={};
s.__init__=function()
{
this.prototype.Test_constructor=this.__base__;
this.prototype.Test_Update=this.__base__.prototype.Update;
};
flash.addDescription("TestBed.TestBuoyancy",d,"TestBed.Test",s,null,["Box2D.Dynamics.Controllers.b2BuoyancyController","Box2D.Common.Math.b2Vec2","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.b2Body","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Dynamics.b2FixtureDef","Box2D.Collision.Shapes.b2CircleShape","Main"]);
}
());;
(function()
{
"use strict";
var d={};
d.Input=function(stageMc)
{
var i=0;
var j=0;
General.Input.m_stageMc=stageMc;
General.Input.ascii=new Array(222);
this.fillAscii();
General.Input.keyState=new Array(222);
General.Input.keyArr=new Array();
for(i=0;i<222;i++)
{
General.Input.keyState[i]=0;
if(General.Input.ascii[i]!=undefined)
{
General.Input.keyArr.push(i)
}
}
General.Input.bufferSize=5;
General.Input.keyBuffer=new Array(General.Input.bufferSize);
for(j=0;j<General.Input.bufferSize;j++)
{
General.Input.keyBuffer[j]=new Array(0,0)
}
stageMc.get_stage().addEventListener(flash.events.KeyboardEvent.KEY_DOWN,flash.bindFunction(this,this.keyPress),false,0,true);
stageMc.get_stage().addEventListener(flash.events.KeyboardEvent.KEY_UP,flash.bindFunction(this,this.keyRelease),false,0,true);
stageMc.get_stage().addEventListener(flash.events.MouseEvent.MOUSE_DOWN,flash.bindFunction(this,this.mousePress),false,0,true);
stageMc.get_stage().addEventListener(flash.events.MouseEvent.CLICK,flash.bindFunction(this,this.mouseRelease),false,0,true);
stageMc.get_stage().addEventListener(flash.events.MouseEvent.MOUSE_MOVE,flash.bindFunction(this,this.mouseMove),false,0,true);
stageMc.get_stage().addEventListener(flash.events.Event.MOUSE_LEAVE,flash.bindFunction(this,this.mouseLeave),false,0,true);
General.Input.mouse.get_graphics().lineStyle(0.1,0,100);
General.Input.mouse.get_graphics().moveTo(0,0);
General.Input.mouse.get_graphics().lineTo(0,0.1);
};
d.fillAscii=function()
{
General.Input.ascii[65]="A";
General.Input.ascii[66]="B";
General.Input.ascii[67]="C";
General.Input.ascii[68]="D";
General.Input.ascii[69]="E";
General.Input.ascii[70]="F";
General.Input.ascii[71]="G";
General.Input.ascii[72]="H";
General.Input.ascii[73]="I";
General.Input.ascii[74]="J";
General.Input.ascii[75]="K";
General.Input.ascii[76]="L";
General.Input.ascii[77]="M";
General.Input.ascii[78]="N";
General.Input.ascii[79]="O";
General.Input.ascii[80]="P";
General.Input.ascii[81]="Q";
General.Input.ascii[82]="R";
General.Input.ascii[83]="S";
General.Input.ascii[84]="T";
General.Input.ascii[85]="U";
General.Input.ascii[86]="V";
General.Input.ascii[87]="W";
General.Input.ascii[88]="X";
General.Input.ascii[89]="Y";
General.Input.ascii[90]="Z";
General.Input.ascii[48]="0";
General.Input.ascii[49]="1";
General.Input.ascii[50]="2";
General.Input.ascii[51]="3";
General.Input.ascii[52]="4";
General.Input.ascii[53]="5";
General.Input.ascii[54]="6";
General.Input.ascii[55]="7";
General.Input.ascii[56]="8";
General.Input.ascii[57]="9";
General.Input.ascii[32]="Spacebar";
General.Input.ascii[17]="Ctrl";
General.Input.ascii[16]="Shift";
General.Input.ascii[192]="~";
General.Input.ascii[38]="up";
General.Input.ascii[40]="down";
General.Input.ascii[37]="left";
General.Input.ascii[39]="right";
General.Input.ascii[96]="Numpad 0";
General.Input.ascii[97]="Numpad 1";
General.Input.ascii[98]="Numpad 2";
General.Input.ascii[99]="Numpad 3";
General.Input.ascii[100]="Numpad 4";
General.Input.ascii[101]="Numpad 5";
General.Input.ascii[102]="Numpad 6";
General.Input.ascii[103]="Numpad 7";
General.Input.ascii[104]="Numpad 8";
General.Input.ascii[105]="Numpad 9";
General.Input.ascii[111]="Numpad /";
General.Input.ascii[106]="Numpad *";
General.Input.ascii[109]="Numpad -";
General.Input.ascii[107]="Numpad +";
General.Input.ascii[110]="Numpad .";
General.Input.ascii[45]="Insert";
General.Input.ascii[46]="Delete";
General.Input.ascii[33]="Page Up";
General.Input.ascii[34]="Page Down";
General.Input.ascii[35]="End";
General.Input.ascii[36]="Home";
General.Input.ascii[112]="F1";
General.Input.ascii[113]="F2";
General.Input.ascii[114]="F3";
General.Input.ascii[115]="F4";
General.Input.ascii[116]="F5";
General.Input.ascii[117]="F6";
General.Input.ascii[118]="F7";
General.Input.ascii[119]="F8";
General.Input.ascii[188]=",";
General.Input.ascii[190]=".";
General.Input.ascii[186]=";";
General.Input.ascii[222]="'";
General.Input.ascii[219]="[";
General.Input.ascii[221]="]";
General.Input.ascii[189]="-";
General.Input.ascii[187]="+";
General.Input.ascii[220]="\\";
General.Input.ascii[191]="/";
General.Input.ascii[9]="TAB";
General.Input.ascii[8]="Backspace";
};
d.mousePress=function(e)
{
General.Input.mousePressed=true;
General.Input.mouseDown=true;
General.Input.mouseDragX=0;
General.Input.mouseDragY=0;
};
d.mouseRelease=function(e)
{
General.Input.mouseDown=false;
General.Input.mouseReleased=true;
};
d.mouseLeave=function(e)
{
General.Input.mouseReleased=General.Input.mouseDown;
General.Input.mouseDown=false;
};
d.mouseMove=function(e)
{
if(General.Input.mouseDown!=e.get_buttonDown())
{
General.Input.mouseDown=e.get_buttonDown();
General.Input.mouseReleased=!e.get_buttonDown();
General.Input.mousePressed=e.get_buttonDown();
General.Input.mouseDragX=0;
General.Input.mouseDragY=0
}
General.Input.mouseX=e.get_stageX()-General.Input.m_stageMc.get_x();
General.Input.mouseY=e.get_stageY()-General.Input.m_stageMc.get_y();
General.Input.mouseOffsetX=General.Input.mouseX-General.Input.mouse.get_x();
General.Input.mouseOffsetY=General.Input.mouseY-General.Input.mouse.get_y();
if(General.Input.mouseDown)
{
General.Input.mouseDragX+=General.Input.mouseOffsetX;
General.Input.mouseDragY+=General.Input.mouseOffsetY
}
General.Input.mouse.set_x(General.Input.mouseX);
General.Input.mouse.set_y(General.Input.mouseY);
};
d.keyPress=function(e)
{
General.Input.keyState[e.get_keyCode()]=Math.max(General.Input.keyState[e.get_keyCode()],1);
General.Input.lastKey=e.get_keyCode();
};
d.keyRelease=function(e)
{
var i=0;
General.Input.keyState[e.get_keyCode()]=-1;
for(i=General.Input.bufferSize-1;i>0;i--)
{
General.Input.keyBuffer[i]=General.Input.keyBuffer[i-1]
}
General.Input.keyBuffer[0]=[e.get_keyCode(),0];
;
};
var s={};
s.__init__=function()
{
this.ascii=null;
this.lastKey=0;
this.timeSinceLastKey=0;
this.mouseDown=false;
this.mouseReleased=false;
this.mousePressed=false;
this.mouseOver=false;
this.mouseX=0;
this.mouseY=0;
this.mouseOffsetX=0;
this.mouseOffsetY=0;
this.mouseDragX=0;
this.mouseDragY=0;
this.mouse=new flash.display.Sprite();
this.m_stageMc=null;
this.keyState=null;
this.keyArr=null;
this.keyBuffer=null;
this.bufferSize=0;
};
s.update=function()
{
var i=0;
var j=0;
for(i=0;i<General.Input.keyArr.length;i++)
{
if(General.Input.keyState[General.Input.keyArr[i]]!=0)
{
General.Input.keyState[General.Input.keyArr[i]]++
}
}
for(j=0;j<General.Input.bufferSize;j++)
{
General.Input.keyBuffer[j][1]++
}
General.Input.mouseReleased=false;
General.Input.mousePressed=false;
General.Input.mouseOver=false;
};
s.getKeyHold=function(k)
{
k=flash.int(k);
return Math.max(0,General.Input.keyState[k]);
};
s.isKeyDown=function(k)
{
k=flash.int(k);
return(General.Input.keyState[k]>0);
};
s.isKeyPressed=function(k)
{
k=flash.int(k);
General.Input.timeSinceLastKey=0;
return(General.Input.keyState[k]==1);
};
s.isKeyReleased=function(k)
{
k=flash.int(k);
return(General.Input.keyState[k]==-1);
};
s.isKeyInBuffer=function(k,i,t)
{
k=flash.int(k);
i=flash.int(i);
t=flash.int(t);
return(General.Input.keyBuffer[i][0]==k&&General.Input.keyBuffer[i][1]<=t);
};
s.getKeyString=function(k)
{
k=flash.uint(k);
return General.Input.ascii[k];
};
flash.addDescription("General.Input",d,null,s,null,["flash.display.Sprite","flash.events.KeyboardEvent","flash.events.MouseEvent","flash.events.Event"]);
}
());;
(function()
{
"use strict";
var d={};
d.FRateLimiter=function()
{
};
var s={};
s.__init__=function()
{
this.oldT=flash.utils.getTimer();
this.newT=General.FRateLimiter.oldT;
};
s.limitFrame=function(maxFPS)
{
maxFPS=flash.uint(maxFPS);
var fTime=0;
fTime=flash.uint(1000/maxFPS);
while(Math.abs(General.FRateLimiter.newT-General.FRateLimiter.oldT)<fTime)
{
General.FRateLimiter.newT=flash.utils.getTimer()
}
General.FRateLimiter.oldT=flash.utils.getTimer();
};
flash.addDescription("General.FRateLimiter",d,null,s,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.textBox=null;
d.textBox2=null;
d.textBox3=null;
d.mfpsCount=0;
d.mfpsCount2=0;
d.avgCount=0;
d.avgCount2=0;
d.oldT=0;
d.FpsCounter=function()
{
this.avgCount=30;
this.avgCount2=30;
this.Sprite_constructor();
this.textBox=new flash.text.TextField();
this.textBox.set_text("...");
this.textBox.set_textColor(0xaa1144);
this.textBox.set_selectable(false);
this.textBox2=new flash.text.TextField();
this.textBox2.set_text("...");
this.textBox2.set_width(150);
this.textBox2.set_textColor(0xaa1144);
this.textBox2.set_selectable(false);
this.textBox2.set_y(15);
this.textBox3=new flash.text.TextField();
this.textBox3.set_text("...");
this.textBox3.set_textColor(0xaa1144);
this.textBox3.set_selectable(false);
this.textBox3.set_y(30);
this.oldT=flash.utils.getTimer();
this.addChild(this.textBox);
this.addChild(this.textBox2);
this.addChild(this.textBox3);
};
d.update=function()
{
var newT=0;
var f1=0;
newT=flash.utils.getTimer();
f1=newT-this.oldT;
this.mfpsCount+=f1;
if(this.avgCount<1)
{
this.textBox.set_text(String(Math.round(1000/(this.mfpsCount/30))+" fps average"));
this.avgCount=30;
this.mfpsCount=0
}
this.avgCount--;
this.oldT=flash.utils.getTimer();
this.textBox3.set_text(Math.round(flash.system.System.get_totalMemory()/(1024*1024))+" MB used");
};
d.updatePhys=function(oldT2)
{
oldT2=flash.uint(oldT2);
var newT=0;
var f1=0;
newT=flash.utils.getTimer();
f1=newT-oldT2;
this.mfpsCount2+=f1;
if(this.avgCount2<1)
{
this.textBox2.set_text(String("Physics step: "+Math.round(this.mfpsCount2/30)+" ms ("+Math.round(1000/(this.mfpsCount2/30))+" fps)"));
this.avgCount2=30;
this.mfpsCount2=0
}
this.avgCount2--;
};
d.updateEnd=function()
{
};
var s={};
s.__init__=function()
{
this.prototype.Sprite_constructor=this.__base__;
};
flash.addDescription("General.FpsCounter",d,"flash.display.Sprite",s,null,["flash.text.TextField","flash.system.System"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_currId=0;
d.m_input=null;
d.Main=function()
{
var instructions_text=null;
var instructions_text_format=null;
var m_aboutTextFormat=null;
this.MovieClip_constructor();
this.addEventListener(flash.events.Event.ENTER_FRAME,flash.bindFunction(this,this.update),false,0,true);
Main.m_fpsCounter.set_x(7);
Main.m_fpsCounter.set_y(5);
this.addChildAt(Main.m_fpsCounter,0);
Main.m_sprite=new flash.display.Sprite();
this.addChild(Main.m_sprite);
this.m_input=new General.Input(Main.m_sprite);
instructions_text=new flash.text.TextField();
instructions_text_format=new flash.text.TextFormat("Arial",16,0xffffff,false,false,false);
instructions_text_format.set_align(flash.text.TextFormatAlign.RIGHT);
instructions_text.set_defaultTextFormat(instructions_text_format);
instructions_text.set_x(140);
instructions_text.set_y(4.5);
instructions_text.set_width(495);
instructions_text.set_height(82);
instructions_text.set_text(["Box2DFlashAS3 2.0.1","'Left'/'Right' arrows to go to previous/next example.","'D' + mouse to delete object / 'R' to reset."].join('\n'));
this.addChild(instructions_text);
Main.m_aboutText=new flash.text.TextField();
m_aboutTextFormat=new flash.text.TextFormat("Arial",16,0x00CCFF,true,false,false);
m_aboutTextFormat.set_align(flash.text.TextFormatAlign.RIGHT);
Main.m_aboutText.set_defaultTextFormat(m_aboutTextFormat);
Main.m_aboutText.set_x(334);
Main.m_aboutText.set_y(71);
Main.m_aboutText.set_width(300);
Main.m_aboutText.set_height(30);
this.addChild(Main.m_aboutText);
instructions_text.set_mouseEnabled(false);
Main.m_aboutText.set_mouseEnabled(false);
};
d.update=function(e)
{
var tests=null;
var testCount=0;
Main.m_sprite.get_graphics().clear();
if(General.Input.isKeyPressed(39))
{
this.m_currId++;
Main.m_currTest=null
}
else if(General.Input.isKeyPressed(37))
{
this.m_currId--;
Main.m_currTest=null
}
else if(General.Input.isKeyPressed(82))
{
Main.m_currTest=null
}
tests=[TestBed.TestRagdoll,TestBed.TestCompound,TestBed.TestCrankGearsPulley,TestBed.TestBridge,TestBed.TestStack,TestBed.TestCCD,TestBed.TestTheoJansen,TestBed.TestBuoyancy,TestBed.TestOneSidedPlatform,TestBed.TestBreakable,TestBed.TestRaycast,null];
;tests.length-=1;
testCount=tests.length;
this.m_currId=(this.m_currId+testCount)%testCount;
if(!Main.m_currTest)
{
switch(this.m_currId)
{
default:
Main.m_currTest=new tests[this.m_currId]()
}
}
Main.m_currTest.Update();
General.Input.update();
Main.m_fpsCounter.update();
General.FRateLimiter.limitFrame(30);
};
var s={};
s.__init__=function()
{
this.prototype.MovieClip_constructor=this.__base__;
this.m_fpsCounter=new General.FpsCounter();
this.m_currTest=null;
this.m_sprite=null;
this.m_aboutText=null;
};
flash.addDescription("Main",d,"flash.display.MovieClip",s,null,["General.FpsCounter","flash.events.Event","flash.display.Sprite","General.Input","flash.text.TextField","flash.text.TextFormat","flash.text.TextFormatAlign","TestBed.TestRagdoll","TestBed.TestCompound","TestBed.TestCrankGearsPulley","TestBed.TestBridge","TestBed.TestStack","TestBed.TestCCD","TestBed.TestTheoJansen","TestBed.TestBuoyancy","TestBed.TestOneSidedPlatform","TestBed.TestBreakable","TestBed.TestRaycast","General.FRateLimiter"]);
}
());;
(function()
{
"use strict";
var d={};
d.dt=0;
d.inv_dt=0;
d.dtRatio=0;
d.velocityIterations=0;
d.positionIterations=0;
d.warmStarting=false;
d.Set=function(step)
{
this.dt=step.dt;
this.inv_dt=step.inv_dt;
this.positionIterations=step.positionIterations;
this.velocityIterations=step.velocityIterations;
this.warmStarting=step.warmStarting;
};
d.b2TimeStep=function()
{
};
flash.addDescription("Box2D.Dynamics.b2TimeStep",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.SayGoodbyeJoint=function(joint)
{
};
d.SayGoodbyeFixture=function(fixture)
{
};
d.b2DestructionListener=function()
{
};
flash.addDescription("Box2D.Dynamics.b2DestructionListener",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.m_flags=0;
d.m_contactManager=null;
d.m_bodyList=null;
d.m_contactList=null;
d.m_contactCount=0;
d.m_groundBody=null;
d.s_stack=null;
d.m_contactSolver=null;
d.m_island=null;
d.m_jointList=null;
d.m_bodyCount=0;
d.m_jointCount=0;
d.m_controllerList=null;
d.m_controllerCount=0;
d.m_gravity=null;
d.m_allowSleep=false;
d.m_destructionListener=null;
d.m_debugDraw=null;
d.m_inv_dt0=0;
d.b2World=function(gravity,doSleep)
{
this.m_contactManager=new Box2D.Dynamics.b2ContactManager();
this.s_stack=new Array();
this.m_contactSolver=new Box2D.Dynamics.Contacts.b2ContactSolver();
this.m_island=new Box2D.Dynamics.b2Island();
var bd=null;
this.m_destructionListener=null;
this.m_debugDraw=null;
this.m_bodyList=null;
this.m_contactList=null;
this.m_jointList=null;
this.m_controllerList=null;
this.m_bodyCount=0;
this.m_contactCount=0;
this.m_jointCount=0;
this.m_controllerCount=0;
Box2D.Dynamics.b2World.m_warmStarting=true;
Box2D.Dynamics.b2World.m_continuousPhysics=true;
this.m_allowSleep=doSleep;
this.m_gravity=gravity;
this.m_inv_dt0=0.0;
this.m_contactManager.m_world=this;
bd=new Box2D.Dynamics.b2BodyDef();
this.m_groundBody=this.CreateBody(bd);
};
d.SetDestructionListener=function(listener)
{
this.m_destructionListener=listener;
};
d.SetContactFilter=function(filter)
{
this.m_contactManager.m_contactFilter=filter;
};
d.SetContactListener=function(listener)
{
this.m_contactManager.m_contactListener=listener;
};
d.SetDebugDraw=function(debugDraw)
{
this.m_debugDraw=debugDraw;
};
d.SetBroadPhase=function(broadPhase)
{
var oldBroadPhase=null;
var b=null;
var f=null;
oldBroadPhase=this.m_contactManager.m_broadPhase;
this.m_contactManager.m_broadPhase=broadPhase;
for(b=this.m_bodyList;b;b=b.m_next)
{
for(f=b.m_fixtureList;f;f=f.m_next)
{
f.m_proxy=broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy),f)
}
}
};
d.Validate=function()
{
this.m_contactManager.m_broadPhase.Validate();
};
d.GetProxyCount=function()
{
return this.m_contactManager.m_broadPhase.GetProxyCount();
};
d.CreateBody=function(def)
{
var b=null;
if(this.IsLocked()==true)
{
return null
}
b=new Box2D.Dynamics.b2Body(def,this);
b.m_prev=null;
b.m_next=this.m_bodyList;
if(this.m_bodyList)
{
this.m_bodyList.m_prev=b
}
this.m_bodyList=b;
++this.m_bodyCount;
return b;
};
d.DestroyBody=function(b)
{
var jn=null;
var jn0=null;
var coe=null;
var coe0=null;
var ce=null;
var ce0=null;
var f=null;
var f0=null;
if(this.IsLocked()==true)
{
return
}
jn=b.m_jointList;
while(jn)
{
jn0=jn;
jn=jn.next;
if(this.m_destructionListener)
{
this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
}
this.DestroyJoint(jn0.joint)
}
coe=b.m_controllerList;
while(coe)
{
coe0=coe;
coe=coe.nextController;
coe0.controller.RemoveBody(b)
}
ce=b.m_contactList;
while(ce)
{
ce0=ce;
ce=ce.next;
this.m_contactManager.Destroy(ce0.contact)
}
b.m_contactList=null;
f=b.m_fixtureList;
while(f)
{
f0=f;
f=f.m_next;
if(this.m_destructionListener)
{
this.m_destructionListener.SayGoodbyeFixture(f0)
}
f0.DestroyProxy(this.m_contactManager.m_broadPhase);
f0.Destroy()
}
b.m_fixtureList=null;
b.m_fixtureCount=0;
if(b.m_prev)
{
b.m_prev.m_next=b.m_next
}
if(b.m_next)
{
b.m_next.m_prev=b.m_prev
}
if(b==this.m_bodyList)
{
this.m_bodyList=b.m_next
}
;--this.m_bodyCount;
};
d.CreateJoint=function(def)
{
var j=null;
var bodyA=null;
var bodyB=null;
var edge=null;
j=Box2D.Dynamics.Joints.b2Joint.Create(def,null);
j.m_prev=null;
j.m_next=this.m_jointList;
if(this.m_jointList)
{
this.m_jointList.m_prev=j
}
this.m_jointList=j;
++this.m_jointCount;
j.m_edgeA.joint=j;
j.m_edgeA.other=j.m_bodyB;
j.m_edgeA.prev=null;
j.m_edgeA.next=j.m_bodyA.m_jointList;
if(j.m_bodyA.m_jointList)
{
j.m_bodyA.m_jointList.prev=j.m_edgeA
}
j.m_bodyA.m_jointList=j.m_edgeA;
j.m_edgeB.joint=j;
j.m_edgeB.other=j.m_bodyA;
j.m_edgeB.prev=null;
j.m_edgeB.next=j.m_bodyB.m_jointList;
if(j.m_bodyB.m_jointList)
{
j.m_bodyB.m_jointList.prev=j.m_edgeB
}
j.m_bodyB.m_jointList=j.m_edgeB;
bodyA=def.bodyA;
bodyB=def.bodyB;
if(def.collideConnected==false)
{
edge=bodyB.GetContactList();
while(edge)
{
if(edge.other==bodyA)
{
edge.contact.FlagForFiltering()
}
edge=edge.next
}
}
return j;
};
d.DestroyJoint=function(j)
{
var collideConnected=false;
var bodyA=null;
var bodyB=null;
var edge=null;
collideConnected=j.m_collideConnected;
if(j.m_prev)
{
j.m_prev.m_next=j.m_next
}
if(j.m_next)
{
j.m_next.m_prev=j.m_prev
}
if(j==this.m_jointList)
{
this.m_jointList=j.m_next
}
bodyA=j.m_bodyA;
bodyB=j.m_bodyB;
bodyA.SetAwake(true);
bodyB.SetAwake(true);
if(j.m_edgeA.prev)
{
j.m_edgeA.prev.next=j.m_edgeA.next
}
if(j.m_edgeA.next)
{
j.m_edgeA.next.prev=j.m_edgeA.prev
}
if(j.m_edgeA==bodyA.m_jointList)
{
bodyA.m_jointList=j.m_edgeA.next
}
j.m_edgeA.prev=null;
j.m_edgeA.next=null;
if(j.m_edgeB.prev)
{
j.m_edgeB.prev.next=j.m_edgeB.next
}
if(j.m_edgeB.next)
{
j.m_edgeB.next.prev=j.m_edgeB.prev
}
if(j.m_edgeB==bodyB.m_jointList)
{
bodyB.m_jointList=j.m_edgeB.next
}
j.m_edgeB.prev=null;
j.m_edgeB.next=null;
Box2D.Dynamics.Joints.b2Joint.Destroy(j,null);
--this.m_jointCount;
if(collideConnected==false)
{
edge=bodyB.GetContactList();
while(edge)
{
if(edge.other==bodyA)
{
edge.contact.FlagForFiltering()
}
edge=edge.next
}
}
};
d.AddController=function(c)
{
c.m_next=this.m_controllerList;
c.m_prev=null;
this.m_controllerList=c;
c.m_world=this;
this.m_controllerCount++;
return c;
};
d.RemoveController=function(c)
{
if(c.m_prev)
{
c.m_prev.m_next=c.m_next
}
if(c.m_next)
{
c.m_next.m_prev=c.m_prev
}
if(this.m_controllerList==c)
{
this.m_controllerList=c.m_next
}
this.m_controllerCount--;
};
d.CreateController=function(controller)
{
if(controller.m_world!=this)
{
throw new Error("Controller can only be a member of one world")
}
controller.m_next=this.m_controllerList;
controller.m_prev=null;
if(this.m_controllerList)
{
this.m_controllerList.m_prev=controller
}
this.m_controllerList=controller;
++this.m_controllerCount;
controller.m_world=this;
return controller;
};
d.DestroyController=function(controller)
{
controller.Clear();
if(controller.m_next)
{
controller.m_next.m_prev=controller.m_prev
}
if(controller.m_prev)
{
controller.m_prev.m_next=controller.m_next
}
if(controller==this.m_controllerList)
{
this.m_controllerList=controller.m_next
}
--this.m_controllerCount;
};
d.SetWarmStarting=function(flag)
{
Box2D.Dynamics.b2World.m_warmStarting=flag;
};
d.SetContinuousPhysics=function(flag)
{
Box2D.Dynamics.b2World.m_continuousPhysics=flag;
};
d.GetBodyCount=function()
{
return this.m_bodyCount;
};
d.GetJointCount=function()
{
return this.m_jointCount;
};
d.GetContactCount=function()
{
return this.m_contactCount;
};
d.SetGravity=function(gravity)
{
this.m_gravity=gravity;
};
d.GetGravity=function()
{
return this.m_gravity;
};
d.GetGroundBody=function()
{
return this.m_groundBody;
};
d.Step=function(dt,velocityIterations,positionIterations)
{
velocityIterations=flash.int(velocityIterations);
positionIterations=flash.int(positionIterations);
var step=null;
if(this.m_flags&Box2D.Dynamics.b2World.e_newFixture)
{
this.m_contactManager.FindNewContacts();
this.m_flags&=~Box2D.Dynamics.b2World.e_newFixture
}
this.m_flags|=Box2D.Dynamics.b2World.e_locked;
step=Box2D.Dynamics.b2World.s_timestep2;
step.dt=dt;
step.velocityIterations=velocityIterations;
step.positionIterations=positionIterations;
if(dt>0.0)
{
step.inv_dt=1.0/dt
}
else
{
step.inv_dt=0.0
}
step.dtRatio=this.m_inv_dt0*dt;
step.warmStarting=Box2D.Dynamics.b2World.m_warmStarting;
this.m_contactManager.Collide();
if(step.dt>0.0)
{
this.Solve(step)
}
if(Box2D.Dynamics.b2World.m_continuousPhysics&&step.dt>0.0)
{
this.SolveTOI(step)
}
if(step.dt>0.0)
{
this.m_inv_dt0=step.inv_dt
}
this.m_flags&=~Box2D.Dynamics.b2World.e_locked;
};
d.ClearForces=function()
{
var body=null;
for(body=this.m_bodyList;body;body=body.m_next)
{
body.m_force.SetZero();
body.m_torque=0.0
}
};
d.DrawDebugData=function()
{
var flags=0;
var i=0;
var b=null;
var f=null;
var s=null;
var j=null;
var bp=null;
var invQ=null;
var x1=null;
var x2=null;
var xf=null;
var b1=null;
var b2=null;
var vs=null;
var color=null;
var c=null;
var contact=null;
var fixtureA=null;
var fixtureB=null;
var cA=null;
var cB=null;
var aabb=null;
if(this.m_debugDraw==null)
{
return
}
this.m_debugDraw.m_sprite.get_graphics().clear();
flags=this.m_debugDraw.GetFlags();
i;
b;
f;
s;
j;
bp;
invQ=new Box2D.Common.Math.b2Vec2;
x1=new Box2D.Common.Math.b2Vec2;
x2=new Box2D.Common.Math.b2Vec2;
xf;
b1=new Box2D.Collision.b2AABB();
b2=new Box2D.Collision.b2AABB();
vs=[new Box2D.Common.Math.b2Vec2(),new Box2D.Common.Math.b2Vec2(),new Box2D.Common.Math.b2Vec2(),new Box2D.Common.Math.b2Vec2()];
;color=new Box2D.Common.b2Color(0,0,0);
if(flags&Box2D.Dynamics.b2DebugDraw.e_shapeBit)
{
for(b=this.m_bodyList;b;b=b.m_next)
{
xf=b.m_xf;
for(f=b.GetFixtureList();f;f=f.m_next)
{
s=f.GetShape();
if(b.IsActive()==false)
{
color.Set(0.5,0.5,0.3);
this.DrawShape(s,xf,color)
}
else if(b.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
color.Set(0.5,0.9,0.5);
this.DrawShape(s,xf,color)
}
else if(b.GetType()==Box2D.Dynamics.b2Body.b2_kinematicBody)
{
color.Set(0.5,0.5,0.9);
this.DrawShape(s,xf,color)
}
else if(b.IsAwake()==false)
{
color.Set(0.6,0.6,0.6);
this.DrawShape(s,xf,color)
}
else
{
color.Set(0.9,0.7,0.7);
this.DrawShape(s,xf,color)
}
}
}
}
if(flags&Box2D.Dynamics.b2DebugDraw.e_jointBit)
{
for(j=this.m_jointList;j;j=j.m_next)
{
this.DrawJoint(j)
}
}
if(flags&Box2D.Dynamics.b2DebugDraw.e_controllerBit)
{
for(c=this.m_controllerList;c;c=c.m_next)
{
c.Draw(this.m_debugDraw)
}
}
if(flags&Box2D.Dynamics.b2DebugDraw.e_pairBit)
{
color.Set(0.3,0.9,0.9);
for(contact=this.m_contactManager.m_contactList;contact;contact=contact.GetNext())
{
fixtureA=contact.GetFixtureA();
fixtureB=contact.GetFixtureB();
cA=fixtureA.GetAABB().GetCenter();
cB=fixtureB.GetAABB().GetCenter();
this.m_debugDraw.DrawSegment(cA,cB,color)
}
}
if(flags&Box2D.Dynamics.b2DebugDraw.e_aabbBit)
{
bp=this.m_contactManager.m_broadPhase;
vs=[new Box2D.Common.Math.b2Vec2(),new Box2D.Common.Math.b2Vec2(),new Box2D.Common.Math.b2Vec2(),new Box2D.Common.Math.b2Vec2()];
;for(b=this.m_bodyList;b;b=b.GetNext())
{
if(b.IsActive()==false)
{
continue;
;
}
for(f=b.GetFixtureList();f;f=f.GetNext())
{
aabb=bp.GetFatAABB(f.m_proxy);
vs[0].Set(aabb.lowerBound.x,aabb.lowerBound.y);
vs[1].Set(aabb.upperBound.x,aabb.lowerBound.y);
vs[2].Set(aabb.upperBound.x,aabb.upperBound.y);
vs[3].Set(aabb.lowerBound.x,aabb.upperBound.y);
this.m_debugDraw.DrawPolygon(vs,4,color)
}
}
}
if(flags&Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit)
{
for(b=this.m_bodyList;b;b=b.m_next)
{
xf=Box2D.Dynamics.b2World.s_xf;
xf.R=b.m_xf.R;
xf.position=b.GetWorldCenter();
this.m_debugDraw.DrawTransform(xf)
}
}
};
d.QueryAABB=function(callback,aabb)
{
var broadPhase=null;
broadPhase=this.m_contactManager.m_broadPhase;
var WorldQueryWrapper=flash.bindFunction(this,function(proxy)
{
return callback(broadPhase.GetUserData(proxy));
}
);
broadPhase.Query(WorldQueryWrapper,aabb);
};
d.QueryShape=function(callback,shape,transform)
{
if(transform==undefined)transform=null;
var broadPhase=null;
var aabb=null;
if(transform==null)
{
transform=new Box2D.Common.Math.b2Transform();
transform.SetIdentity()
}
broadPhase=this.m_contactManager.m_broadPhase;
var WorldQueryWrapper=flash.bindFunction(this,function(proxy)
{
var fixture=null;
fixture=broadPhase.GetUserData(proxy);
if(Box2D.Collision.Shapes.b2Shape.TestOverlap(shape,transform,fixture.GetShape(),fixture.GetBody().GetTransform()))
{
return callback(fixture)
}
return true;
}
);
aabb=new Box2D.Collision.b2AABB();
shape.ComputeAABB(aabb,transform);
broadPhase.Query(WorldQueryWrapper,aabb);
};
d.QueryPoint=function(callback,p)
{
var broadPhase=null;
var aabb=null;
broadPhase=this.m_contactManager.m_broadPhase;
var WorldQueryWrapper=flash.bindFunction(this,function(proxy)
{
var fixture=null;
fixture=broadPhase.GetUserData(proxy);
if(fixture.TestPoint(p))
{
return callback(fixture)
}
return true;
}
);
aabb=new Box2D.Collision.b2AABB();
aabb.lowerBound.Set(p.x-Box2D.Common.b2Settings.b2_linearSlop,p.y-Box2D.Common.b2Settings.b2_linearSlop);
aabb.upperBound.Set(p.x+Box2D.Common.b2Settings.b2_linearSlop,p.y+Box2D.Common.b2Settings.b2_linearSlop);
broadPhase.Query(WorldQueryWrapper,aabb);
};
d.RayCast=function(callback,point1,point2)
{
var broadPhase=null;
var output=null;
var input=null;
broadPhase=this.m_contactManager.m_broadPhase;
output=new Box2D.Collision.b2RayCastOutput;
var RayCastWrapper=flash.bindFunction(this,function(input,proxy)
{
var userData=null;
var fixture=null;
var hit=false;
var fraction=0;
var point=null;
userData=broadPhase.GetUserData(proxy);
fixture=userData;
hit=fixture.RayCast(output,input);
if(hit)
{
fraction=output.fraction;
point=new Box2D.Common.Math.b2Vec2((1.0-fraction)*point1.x+fraction*point2.x,(1.0-fraction)*point1.y+fraction*point2.y);
return callback(fixture,point,output.normal,fraction)
}
return input.maxFraction;
}
);
input=new Box2D.Collision.b2RayCastInput(point1,point2);
broadPhase.RayCast(RayCastWrapper,input);
};
d.RayCastOne=function(point1,point2)
{
var result=null;
result;
var RayCastOneWrapper=flash.bindFunction(this,function(fixture,point,normal,fraction)
{
result=fixture;
return fraction;
}
);
this.RayCast(RayCastOneWrapper,point1,point2);
return result;
};
d.RayCastAll=function(point1,point2)
{
var result=null;
var RayCastAllWrapper=null;
result=new Array();
RayCastAllWrapper=flash.bindFunction(this,function(fixture,point,normal,fraction)
{
result[result.length]=fixture;
return 1;
}
);
;this.RayCast(flash.bindFunction(null,RayCastAllWrapper),point1,point2);
return result;
};
d.GetBodyList=function()
{
return this.m_bodyList;
};
d.GetJointList=function()
{
return this.m_jointList;
};
d.GetContactList=function()
{
return this.m_contactList;
};
d.IsLocked=function()
{
return(this.m_flags&Box2D.Dynamics.b2World.e_locked)>0;
};
d.Solve=function(step)
{
var b=null;
var controller=null;
var island=null;
var c=null;
var j=null;
var stackSize=0;
var stack=null;
var seed=null;
var stackCount=0;
var other=null;
var ce=null;
var jn=null;
var i=0;
b;
for(controller=this.m_controllerList;controller;controller=controller.m_next)
{
controller.Step(step)
}
island=this.m_island;
island.Initialize(this.m_bodyCount,this.m_contactCount,this.m_jointCount,null,this.m_contactManager.m_contactListener,this.m_contactSolver);
for(b=this.m_bodyList;b;b=b.m_next)
{
b.m_flags&=~Box2D.Dynamics.b2Body.e_islandFlag
}
for(c=this.m_contactList;c;c=c.m_next)
{
c.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_islandFlag
}
for(j=this.m_jointList;j;j=j.m_next)
{
j.m_islandFlag=false
}
stackSize=this.m_bodyCount;
stack=this.s_stack;
for(seed=this.m_bodyList;seed;seed=seed.m_next)
{
if(seed.m_flags&Box2D.Dynamics.b2Body.e_islandFlag)
{
continue;
;
}
if(seed.IsAwake()==false||seed.IsActive()==false)
{
continue;
;
}
if(seed.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
continue;
;
}
island.Clear();
stackCount=0;
stack[stackCount++]=seed;
seed.m_flags|=Box2D.Dynamics.b2Body.e_islandFlag;
while(stackCount>0)
{
b=stack[--stackCount];
island.AddBody(b);
if(b.IsAwake()==false)
{
b.SetAwake(true)
}
if(b.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
continue;
;
}
other;
for(ce=b.m_contactList;ce;ce=ce.next)
{
if(ce.contact.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_islandFlag)
{
continue;
;
}
if(ce.contact.IsSensor()==true||ce.contact.IsEnabled()==false||ce.contact.IsTouching()==false)
{
continue;
;
}
island.AddContact(ce.contact);
ce.contact.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_islandFlag;
other=ce.other;
if(other.m_flags&Box2D.Dynamics.b2Body.e_islandFlag)
{
continue;
;
}
stack[stackCount++]=other;
other.m_flags|=Box2D.Dynamics.b2Body.e_islandFlag
}
for(jn=b.m_jointList;jn;jn=jn.next)
{
if(jn.joint.m_islandFlag==true)
{
continue;
;
}
other=jn.other;
if(other.IsActive()==false)
{
continue;
;
}
island.AddJoint(jn.joint);
jn.joint.m_islandFlag=true;
if(other.m_flags&Box2D.Dynamics.b2Body.e_islandFlag)
{
continue;
;
}
stack[stackCount++]=other;
other.m_flags|=Box2D.Dynamics.b2Body.e_islandFlag
}
}
island.Solve(step,this.m_gravity,this.m_allowSleep);
for(i=0;i<island.m_bodyCount;++i)
{
b=island.m_bodies[i];
if(b.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
b.m_flags&=~Box2D.Dynamics.b2Body.e_islandFlag
}
}
}
for(i=0;i<stack.length;++i)
{
if(!stack[i])
{
break
}
;stack[i]=null
}
for(b=this.m_bodyList;b;b=b.m_next)
{
if(b.IsAwake()==false||b.IsActive()==false)
{
continue;
;
}
if(b.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
continue;
;
}
b.SynchronizeFixtures()
}
this.m_contactManager.FindNewContacts();
};
d.SolveTOI=function(step)
{
var b=null;
var fA=null;
var fB=null;
var bA=null;
var bB=null;
var cEdge=null;
var j=null;
var island=null;
var queue=null;
var c=null;
var minContact=null;
var minTOI=0;
var toi=0;
var t0=0;
var seed=null;
var queueStart=0;
var queueSize=0;
var other=null;
var jEdge=null;
var subStep=null;
var i=0;
b;
fA;
fB;
bA;
bB;
cEdge;
j;
island=this.m_island;
island.Initialize(this.m_bodyCount,Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland,Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland,null,this.m_contactManager.m_contactListener,this.m_contactSolver);
queue=Box2D.Dynamics.b2World.s_queue;
for(b=this.m_bodyList;b;b=b.m_next)
{
b.m_flags&=~Box2D.Dynamics.b2Body.e_islandFlag;
b.m_sweep.t0=0.0
}
c;
for(c=this.m_contactList;c;c=c.m_next)
{
c.m_flags&=~(Box2D.Dynamics.Contacts.b2Contact.e_toiFlag|Box2D.Dynamics.Contacts.b2Contact.e_islandFlag)
}
for(j=this.m_jointList;j;j=j.m_next)
{
j.m_islandFlag=false
}
while(true)
{
minContact=null;
minTOI=1.0;
for(c=this.m_contactList;c;c=c.m_next)
{
if(c.IsSensor()==true||c.IsEnabled()==false||c.IsContinuous()==false)
{
continue;
;
}
toi=1.0;
if(c.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_toiFlag)
{
toi=c.m_toi
}
else
{
fA=c.m_fixtureA;
fB=c.m_fixtureB;
bA=fA.m_body;
bB=fB.m_body;
if((bA.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody||bA.IsAwake()==false)&&(bB.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody||bB.IsAwake()==false))
{
continue;
;
}
t0=bA.m_sweep.t0;
if(bA.m_sweep.t0<bB.m_sweep.t0)
{
t0=bB.m_sweep.t0;
bA.m_sweep.Advance(t0)
}
else if(bB.m_sweep.t0<bA.m_sweep.t0)
{
t0=bA.m_sweep.t0;
bB.m_sweep.Advance(t0)
}
toi=c.ComputeTOI(bA.m_sweep,bB.m_sweep);
Box2D.Common.b2Settings.b2Assert(0.0<=toi&&toi<=1.0);
if(toi>0.0&&toi<1.0)
{
toi=(1.0-toi)*t0+toi;
if(toi>1)
{
toi=1
}
}
c.m_toi=toi;
c.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_toiFlag
}
if(Number.MIN_VALUE<toi&&toi<minTOI)
{
minContact=c;
minTOI=toi
}
}
if(minContact==null||1.0-100.0*Number.MIN_VALUE<minTOI)
{
break;
;
}
fA=minContact.m_fixtureA;
fB=minContact.m_fixtureB;
bA=fA.m_body;
bB=fB.m_body;
Box2D.Dynamics.b2World.s_backupA.Set(bA.m_sweep);
Box2D.Dynamics.b2World.s_backupB.Set(bB.m_sweep);
bA.Advance(minTOI);
bB.Advance(minTOI);
minContact.Update(this.m_contactManager.m_contactListener);
minContact.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_toiFlag;
if(minContact.IsSensor()==true||minContact.IsEnabled()==false)
{
bA.m_sweep.Set(Box2D.Dynamics.b2World.s_backupA);
bB.m_sweep.Set(Box2D.Dynamics.b2World.s_backupB);
bA.SynchronizeTransform();
bB.SynchronizeTransform();
continue;
;
}
if(minContact.IsTouching()==false)
{
continue;
;
}
seed=bA;
if(seed.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
seed=bB
}
island.Clear();
queueStart=0;
queueSize=0;
queue[queueStart+queueSize++]=seed;
seed.m_flags|=Box2D.Dynamics.b2Body.e_islandFlag;
while(queueSize>0)
{
b=queue[queueStart++];
--queueSize;
island.AddBody(b);
if(b.IsAwake()==false)
{
b.SetAwake(true)
}
if(b.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
continue;
;
}
for(cEdge=b.m_contactList;cEdge;cEdge=cEdge.next)
{
if(island.m_contactCount==island.m_contactCapacity)
{
break;
;
}
if(cEdge.contact.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_islandFlag)
{
continue;
;
}
if(cEdge.contact.IsSensor()==true||cEdge.contact.IsEnabled()==false||cEdge.contact.IsTouching()==false)
{
continue;
;
}
island.AddContact(cEdge.contact);
cEdge.contact.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_islandFlag;
other=cEdge.other;
if(other.m_flags&Box2D.Dynamics.b2Body.e_islandFlag)
{
continue;
;
}
if(other.GetType()!=Box2D.Dynamics.b2Body.b2_staticBody)
{
other.Advance(minTOI);
other.SetAwake(true)
}
queue[queueStart+queueSize]=other;
++queueSize;
other.m_flags|=Box2D.Dynamics.b2Body.e_islandFlag
}
for(jEdge=b.m_jointList;jEdge;jEdge=jEdge.next)
{
if(island.m_jointCount==island.m_jointCapacity)
{
continue
}
;if(jEdge.joint.m_islandFlag==true)
{
continue
}
;other=jEdge.other;
if(other.IsActive()==false)
{
continue;
;
}
island.AddJoint(jEdge.joint);
jEdge.joint.m_islandFlag=true;
if(other.m_flags&Box2D.Dynamics.b2Body.e_islandFlag)
{
continue
}
;if(other.GetType()!=Box2D.Dynamics.b2Body.b2_staticBody)
{
other.Advance(minTOI);
other.SetAwake(true)
}
queue[queueStart+queueSize]=other;
++queueSize;
other.m_flags|=Box2D.Dynamics.b2Body.e_islandFlag
}
}
subStep=Box2D.Dynamics.b2World.s_timestep;
subStep.warmStarting=false;
subStep.dt=(1.0-minTOI)*step.dt;
subStep.inv_dt=1.0/subStep.dt;
subStep.dtRatio=0.0;
subStep.velocityIterations=step.velocityIterations;
subStep.positionIterations=step.positionIterations;
island.SolveTOI(subStep);
i;
for(i=0;i<island.m_bodyCount;++i)
{
b=island.m_bodies[i];
b.m_flags&=~Box2D.Dynamics.b2Body.e_islandFlag;
if(b.IsAwake()==false)
{
continue;
;
}
if(b.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
continue;
;
}
b.SynchronizeFixtures();
for(cEdge=b.m_contactList;cEdge;cEdge=cEdge.next)
{
cEdge.contact.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_toiFlag
}
}
for(i=0;i<island.m_contactCount;++i)
{
c=island.m_contacts[i];
c.m_flags&=~(Box2D.Dynamics.Contacts.b2Contact.e_toiFlag|Box2D.Dynamics.Contacts.b2Contact.e_islandFlag)
}
for(i=0;i<island.m_jointCount;++i)
{
j=island.m_joints[i];
j.m_islandFlag=false
}
this.m_contactManager.FindNewContacts()
}
};
d.DrawJoint=function(joint)
{
var b1=null;
var b2=null;
var xf1=null;
var xf2=null;
var x1=null;
var x2=null;
var p1=null;
var p2=null;
var color=null;
var pulley=null;
var s1=null;
var s2=null;
b1=joint.GetBodyA();
b2=joint.GetBodyB();
xf1=b1.m_xf;
xf2=b2.m_xf;
x1=xf1.position;
x2=xf2.position;
p1=joint.GetAnchorA();
p2=joint.GetAnchorB();
color=Box2D.Dynamics.b2World.s_jointColor;
switch(joint.m_type)
{
case Box2D.Dynamics.Joints.b2Joint.e_distanceJoint:
this.m_debugDraw.DrawSegment(p1,p2,color);
break;
;case Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint:
{
pulley=(joint);
s1=pulley.GetGroundAnchorA();
s2=pulley.GetGroundAnchorB();
this.m_debugDraw.DrawSegment(s1,p1,color);
this.m_debugDraw.DrawSegment(s2,p2,color);
this.m_debugDraw.DrawSegment(s1,s2,color)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_mouseJoint:
this.m_debugDraw.DrawSegment(p1,p2,color);
break;
;default:
if(b1!=this.m_groundBody)
{
this.m_debugDraw.DrawSegment(x1,p1,color)
}
this.m_debugDraw.DrawSegment(p1,p2,color);
if(b2!=this.m_groundBody)
{
this.m_debugDraw.DrawSegment(x2,p2,color)
}
}
};
d.DrawShape=function(shape,xf,color)
{
var circle=null;
var center=null;
var radius=0;
var axis=null;
var i=0;
var poly=null;
var vertexCount=0;
var localVertices=null;
var vertices=null;
var edge=null;
switch(shape.m_type)
{
case Box2D.Collision.Shapes.b2Shape.e_circleShape:
{
circle=(shape);
center=Box2D.Common.Math.b2Math.MulX(xf,circle.m_p);
radius=circle.m_radius;
axis=xf.R.col1;
this.m_debugDraw.DrawSolidCircle(center,radius,axis,color)
};
break;
;case Box2D.Collision.Shapes.b2Shape.e_polygonShape:
{
i;
poly=(shape);
vertexCount=poly.GetVertexCount();
localVertices=poly.GetVertices();
vertices=new Array();
for(i=0;i<vertexCount;++i)
{
vertices[i]=Box2D.Common.Math.b2Math.MulX(xf,localVertices[i])
}
this.m_debugDraw.DrawSolidPolygon(vertices,vertexCount,color)
};
break;
;case Box2D.Collision.Shapes.b2Shape.e_edgeShape:
{
edge=shape;
this.m_debugDraw.DrawSegment(Box2D.Common.Math.b2Math.MulX(xf,edge.GetVertex1()),Box2D.Common.Math.b2Math.MulX(xf,edge.GetVertex2()),color)
};
break;
;
}
};
var s={};
s.__init__=function()
{
this.e_newFixture=0x0001;
this.e_locked=0x0002;
this.s_timestep2=new Box2D.Dynamics.b2TimeStep();
this.s_xf=new Box2D.Common.Math.b2Transform();
this.s_backupA=new Box2D.Common.Math.b2Sweep();
this.s_backupB=new Box2D.Common.Math.b2Sweep();
this.s_timestep=new Box2D.Dynamics.b2TimeStep();
this.s_queue=new Array();
this.s_jointColor=new Box2D.Common.b2Color(0.5,0.8,0.8);
this.m_warmStarting=false;
this.m_continuousPhysics=false;
};
flash.addDescription("Box2D.Dynamics.b2World",d,null,s,null,["Box2D.Dynamics.b2TimeStep","Box2D.Common.Math.b2Transform","Box2D.Common.Math.b2Sweep","Box2D.Dynamics.b2Body","Box2D.Common.b2Color","Box2D.Dynamics.b2ContactManager","Box2D.Dynamics.Contacts.b2ContactSolver","Box2D.Dynamics.b2Island","Box2D.Dynamics.b2BodyDef","Box2D.Dynamics.Joints.b2Joint","Error","Box2D.Common.Math.b2Vec2","Box2D.Collision.b2AABB","Box2D.Dynamics.b2DebugDraw","Box2D.Dynamics.b2Fixture","Box2D.Collision.Shapes.b2Shape","Box2D.Common.b2Settings","Box2D.Collision.b2RayCastOutput","Box2D.Collision.b2RayCastInput","Box2D.Dynamics.Contacts.b2Contact","Box2D.Dynamics.Joints.b2PulleyJoint","Box2D.Collision.Shapes.b2CircleShape","Box2D.Common.Math.b2Math","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Collision.Shapes.b2EdgeShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.shape=null;
d.userData=null;
d.friction=0;
d.restitution=0;
d.density=0;
d.isSensor=false;
d.filter=null;
d.b2FixtureDef=function()
{
this.filter=new Box2D.Dynamics.b2FilterData();
this.shape=null;
this.userData=null;
this.friction=0.2;
this.restitution=0.0;
this.density=0.0;
this.filter.categoryBits=0x0001;
this.filter.maskBits=0xFFFF;
this.filter.groupIndex=0;
this.isSensor=false;
};
flash.addDescription("Box2D.Dynamics.b2FixtureDef",d,null,null,null,["Box2D.Dynamics.b2FilterData"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_aabb=null;
d.m_density=0;
d.m_next=null;
d.m_body=null;
d.m_shape=null;
d.m_friction=0;
d.m_restitution=0;
d.m_proxy=null;
d.m_filter=null;
d.m_isSensor=false;
d.m_userData=null;
d.m_massData=null;
d.b2Fixture=function()
{
this.m_filter=new Box2D.Dynamics.b2FilterData();
this.m_aabb=new Box2D.Collision.b2AABB();
this.m_userData=null;
this.m_body=null;
this.m_next=null;
this.m_shape=null;
this.m_density=0.0;
this.m_friction=0.0;
this.m_restitution=0.0;
};
d.GetType=function()
{
return this.m_shape.GetType();
};
d.GetShape=function()
{
return this.m_shape;
};
d.SetSensor=function(sensor)
{
var edge=null;
var contact=null;
var fixtureA=null;
var fixtureB=null;
if(this.m_isSensor==sensor)
{
return
}
this.m_isSensor=sensor;
if(this.m_body==null)
{
return
}
edge=this.m_body.GetContactList();
while(edge)
{
contact=edge.contact;
fixtureA=contact.GetFixtureA();
fixtureB=contact.GetFixtureB();
if(fixtureA==this||fixtureB==this)
{
contact.SetSensor(fixtureA.IsSensor()||fixtureB.IsSensor())
}
edge=edge.next
}
};
d.IsSensor=function()
{
return this.m_isSensor;
};
d.SetFilterData=function(filter)
{
var edge=null;
var contact=null;
var fixtureA=null;
var fixtureB=null;
this.m_filter=filter.Copy();
if(this.m_body)
{
return
}
edge=this.m_body.GetContactList();
while(edge)
{
contact=edge.contact;
fixtureA=contact.GetFixtureA();
fixtureB=contact.GetFixtureB();
if(fixtureA==this||fixtureB==this)
{
contact.FlagForFiltering()
}
edge=edge.next
}
};
d.GetFilterData=function()
{
return this.m_filter.Copy();
};
d.GetBody=function()
{
return this.m_body;
};
d.GetNext=function()
{
return this.m_next;
};
d.GetUserData=function()
{
return this.m_userData;
};
d.SetUserData=function(data)
{
this.m_userData=data;
};
d.TestPoint=function(p)
{
return this.m_shape.TestPoint(this.m_body.GetTransform(),p);
};
d.RayCast=function(output,input)
{
return this.m_shape.RayCast(output,input,this.m_body.GetTransform());
};
d.GetMassData=function(massData)
{
if(massData==undefined)massData=null;
if(massData==null)
{
massData=new Box2D.Collision.Shapes.b2MassData()
}
this.m_shape.ComputeMass(massData,this.m_density);
return massData;
};
d.SetDensity=function(density)
{
this.m_density=density;
};
d.GetDensity=function()
{
return this.m_density;
};
d.GetFriction=function()
{
return this.m_friction;
};
d.SetFriction=function(friction)
{
this.m_friction=friction;
};
d.GetRestitution=function()
{
return this.m_restitution;
};
d.SetRestitution=function(restitution)
{
this.m_restitution=restitution;
};
d.GetAABB=function()
{
return this.m_aabb;
};
d.Create=function(body,xf,def)
{
this.m_userData=def.userData;
this.m_friction=def.friction;
this.m_restitution=def.restitution;
this.m_body=body;
this.m_next=null;
this.m_filter=def.filter.Copy();
this.m_isSensor=def.isSensor;
this.m_shape=def.shape.Copy();
this.m_density=def.density;
};
d.Destroy=function()
{
this.m_shape=null;
};
d.CreateProxy=function(broadPhase,xf)
{
this.m_shape.ComputeAABB(this.m_aabb,xf);
this.m_proxy=broadPhase.CreateProxy(this.m_aabb,this);
};
d.DestroyProxy=function(broadPhase)
{
if(this.m_proxy==null)
{
return
}
broadPhase.DestroyProxy(this.m_proxy);
this.m_proxy=null;
};
d.Synchronize=function(broadPhase,transform1,transform2)
{
var aabb1=null;
var aabb2=null;
var displacement=null;
if(!this.m_proxy)
{
return
}
aabb1=new Box2D.Collision.b2AABB();
aabb2=new Box2D.Collision.b2AABB();
this.m_shape.ComputeAABB(aabb1,transform1);
this.m_shape.ComputeAABB(aabb2,transform2);
this.m_aabb.Combine(aabb1,aabb2);
displacement=Box2D.Common.Math.b2Math.SubtractVV(transform2.position,transform1.position);
broadPhase.MoveProxy(this.m_proxy,this.m_aabb,displacement);
};
flash.addDescription("Box2D.Dynamics.b2Fixture",d,null,null,null,["Box2D.Dynamics.b2FilterData","Box2D.Collision.b2AABB","Box2D.Collision.Shapes.b2MassData","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.createFcn=null;
d.destroyFcn=null;
d.primary=false;
d.pool=null;
d.poolCount=0;
d.b2ContactRegister=function()
{
};
flash.addDescription("Box2D.Dynamics.Contacts.b2ContactRegister",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.Reset=function(fixtureA,fixtureB)
{
if(fixtureA==undefined)fixtureA=null;
if(fixtureB==undefined)fixtureB=null;
this.b2Contact_Reset(fixtureA,fixtureB);
Box2D.Common.b2Settings.b2Assert(fixtureA.GetType()==Box2D.Collision.Shapes.b2Shape.e_polygonShape);
Box2D.Common.b2Settings.b2Assert(fixtureB.GetType()==Box2D.Collision.Shapes.b2Shape.e_circleShape);
};
d.Evaluate=function()
{
var bA=null;
var bB=null;
bA=this.m_fixtureA.m_body;
bB=this.m_fixtureB.m_body;
Box2D.Collision.b2Collision.CollidePolygonAndCircle(this.m_manifold,this.m_fixtureA.GetShape(),bA.m_xf,this.m_fixtureB.GetShape(),bB.m_xf);
};
d.b2PolyAndCircleContact=function()
{
this.b2Contact_constructor();
};
var s={};
s.__init__=function()
{
this.prototype.b2Contact_constructor=this.__base__;
this.prototype.b2Contact_Reset=this.__base__.prototype.Reset;
};
s.Create=function(allocator)
{
return new Box2D.Dynamics.Contacts.b2PolyAndCircleContact();
};
s.Destroy=function(contact,allocator)
{
};
flash.addDescription("Box2D.Dynamics.Contacts.b2PolyAndCircleContact",d,"Box2D.Dynamics.Contacts.b2Contact",s,null,["Box2D.Dynamics.Contacts.b2PolyAndCircleContact","Box2D.Common.b2Settings","Box2D.Collision.Shapes.b2Shape","Box2D.Collision.b2Collision","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Collision.Shapes.b2CircleShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.Reset=function(fixtureA,fixtureB)
{
if(fixtureA==undefined)fixtureA=null;
if(fixtureB==undefined)fixtureB=null;
this.b2Contact_Reset(fixtureA,fixtureB);
};
d.Evaluate=function()
{
var bA=null;
var bB=null;
bA=this.m_fixtureA.GetBody();
bB=this.m_fixtureB.GetBody();
this.b2CollideEdgeAndCircle(this.m_manifold,this.m_fixtureA.GetShape(),bA.m_xf,this.m_fixtureB.GetShape(),bB.m_xf);
};
d.b2CollideEdgeAndCircle=function(manifold,edge,xf1,circle,xf2)
{
};
d.b2EdgeAndCircleContact=function()
{
this.b2Contact_constructor();
};
var s={};
s.__init__=function()
{
this.prototype.b2Contact_constructor=this.__base__;
this.prototype.b2Contact_Reset=this.__base__.prototype.Reset;
};
s.Create=function(allocator)
{
return new Box2D.Dynamics.Contacts.b2EdgeAndCircleContact();
};
s.Destroy=function(contact,allocator)
{
};
flash.addDescription("Box2D.Dynamics.Contacts.b2EdgeAndCircleContact",d,"Box2D.Dynamics.Contacts.b2Contact",s,null,["Box2D.Dynamics.Contacts.b2EdgeAndCircleContact","Box2D.Collision.Shapes.b2EdgeShape","Box2D.Collision.Shapes.b2CircleShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.other=null;
d.contact=null;
d.prev=null;
d.next=null;
d.b2ContactEdge=function()
{
};
flash.addDescription("Box2D.Dynamics.Contacts.b2ContactEdge",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.m_constraints=null;
d.m_step=null;
d.m_allocator=null;
d.m_constraintCount=0;
d.b2ContactSolver=function()
{
this.m_constraints=new Array();
this.m_step=new Box2D.Dynamics.b2TimeStep();
};
d.Initialize=function(step,contacts,contactCount,allocator)
{
contactCount=flash.int(contactCount);
var contact=null;
var i=0;
var tVec=null;
var tMat=null;
var fixtureA=null;
var fixtureB=null;
var shapeA=null;
var shapeB=null;
var radiusA=0;
var radiusB=0;
var bodyA=null;
var bodyB=null;
var manifold=null;
var friction=0;
var restitution=0;
var vAX=0;
var vAY=0;
var vBX=0;
var vBY=0;
var wA=0;
var wB=0;
var normalX=0;
var normalY=0;
var cc=null;
var k=0;
var cp=null;
var ccp=null;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var rnA=0;
var rnB=0;
var kNormal=0;
var kEqualized=0;
var tangentX=0;
var tangentY=0;
var rtA=0;
var rtB=0;
var kTangent=0;
var tX=0;
var tY=0;
var vRel=0;
var ccp1=null;
var ccp2=null;
var invMassA=0;
var invIA=0;
var invMassB=0;
var invIB=0;
var rn1A=0;
var rn1B=0;
var rn2A=0;
var rn2B=0;
var k11=0;
var k22=0;
var k12=0;
var k_maxConditionNumber=0;
contact;
this.m_step.Set(step);
this.m_allocator=allocator;
i;
tVec;
tMat;
this.m_constraintCount=contactCount;
while(this.m_constraints.length<this.m_constraintCount)
{
this.m_constraints[this.m_constraints.length]=new Box2D.Dynamics.Contacts.b2ContactConstraint()
}
for(i=0;i<contactCount;++i)
{
contact=contacts[i];
fixtureA=contact.m_fixtureA;
fixtureB=contact.m_fixtureB;
shapeA=fixtureA.m_shape;
shapeB=fixtureB.m_shape;
radiusA=shapeA.m_radius;
radiusB=shapeB.m_radius;
bodyA=fixtureA.m_body;
bodyB=fixtureB.m_body;
manifold=contact.GetManifold();
friction=Box2D.Common.b2Settings.b2MixFriction(fixtureA.GetFriction(),fixtureB.GetFriction());
restitution=Box2D.Common.b2Settings.b2MixRestitution(fixtureA.GetRestitution(),fixtureB.GetRestitution());
vAX=bodyA.m_linearVelocity.x;
vAY=bodyA.m_linearVelocity.y;
vBX=bodyB.m_linearVelocity.x;
vBY=bodyB.m_linearVelocity.y;
wA=bodyA.m_angularVelocity;
wB=bodyB.m_angularVelocity;
Box2D.Common.b2Settings.b2Assert(manifold.m_pointCount>0);
Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.Initialize(manifold,bodyA.m_xf,radiusA,bodyB.m_xf,radiusB);
normalX=Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_normal.x;
normalY=Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_normal.y;
cc=this.m_constraints[i];
cc.bodyA=bodyA;
cc.bodyB=bodyB;
cc.manifold=manifold;
cc.normal.x=normalX;
cc.normal.y=normalY;
cc.pointCount=manifold.m_pointCount;
cc.friction=friction;
cc.restitution=restitution;
cc.localPlaneNormal.x=manifold.m_localPlaneNormal.x;
cc.localPlaneNormal.y=manifold.m_localPlaneNormal.y;
cc.localPoint.x=manifold.m_localPoint.x;
cc.localPoint.y=manifold.m_localPoint.y;
cc.radius=radiusA+radiusB;
cc.type=manifold.m_type;
for(k=0;k<cc.pointCount;++k)
{
cp=manifold.m_points[k];
ccp=cc.points[k];
ccp.normalImpulse=cp.m_normalImpulse;
ccp.tangentImpulse=cp.m_tangentImpulse;
ccp.localPoint.SetV(cp.m_localPoint);
rAX=ccp.rA.x=Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[k].x-bodyA.m_sweep.c.x;
rAY=ccp.rA.y=Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[k].y-bodyA.m_sweep.c.y;
rBX=ccp.rB.x=Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[k].x-bodyB.m_sweep.c.x;
rBY=ccp.rB.y=Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[k].y-bodyB.m_sweep.c.y;
rnA=rAX*normalY-rAY*normalX;
rnB=rBX*normalY-rBY*normalX;
rnA*=rnA;
rnB*=rnB;
kNormal=bodyA.m_invMass+bodyB.m_invMass+bodyA.m_invI*rnA+bodyB.m_invI*rnB;
ccp.normalMass=1.0/kNormal;
kEqualized=bodyA.m_mass*bodyA.m_invMass+bodyB.m_mass*bodyB.m_invMass;
kEqualized+=bodyA.m_mass*bodyA.m_invI*rnA+bodyB.m_mass*bodyB.m_invI*rnB;
ccp.equalizedMass=1.0/kEqualized;
tangentX=normalY;
tangentY=-normalX;
rtA=rAX*tangentY-rAY*tangentX;
rtB=rBX*tangentY-rBY*tangentX;
rtA*=rtA;
rtB*=rtB;
kTangent=bodyA.m_invMass+bodyB.m_invMass+bodyA.m_invI*rtA+bodyB.m_invI*rtB;
ccp.tangentMass=1.0/kTangent;
ccp.velocityBias=0.0;
tX=vBX+(-wB*rBY)-vAX-(-wA*rAY);
tY=vBY+(wB*rBX)-vAY-(wA*rAX);
vRel=cc.normal.x*tX+cc.normal.y*tY;
if(vRel<-Box2D.Common.b2Settings.b2_velocityThreshold)
{
ccp.velocityBias+=-cc.restitution*vRel
}
}
if(cc.pointCount==2)
{
ccp1=cc.points[0];
ccp2=cc.points[1];
invMassA=bodyA.m_invMass;
invIA=bodyA.m_invI;
invMassB=bodyB.m_invMass;
invIB=bodyB.m_invI;
rn1A=ccp1.rA.x*normalY-ccp1.rA.y*normalX;
rn1B=ccp1.rB.x*normalY-ccp1.rB.y*normalX;
rn2A=ccp2.rA.x*normalY-ccp2.rA.y*normalX;
rn2B=ccp2.rB.x*normalY-ccp2.rB.y*normalX;
k11=invMassA+invMassB+invIA*rn1A*rn1A+invIB*rn1B*rn1B;
k22=invMassA+invMassB+invIA*rn2A*rn2A+invIB*rn2B*rn2B;
k12=invMassA+invMassB+invIA*rn1A*rn2A+invIB*rn1B*rn2B;
k_maxConditionNumber=100.0;
if(k11*k11<k_maxConditionNumber*(k11*k22-k12*k12))
{
cc.K.col1.Set(k11,k12);
cc.K.col2.Set(k12,k22);
cc.K.GetInverse(cc.normalMass)
}
else
{
cc.pointCount=1
}
}
}
};
d.InitVelocityConstraints=function(step)
{
var tVec=null;
var tVec2=null;
var tMat=null;
var i=0;
var c=null;
var bodyA=null;
var bodyB=null;
var invMassA=0;
var invIA=0;
var invMassB=0;
var invIB=0;
var normalX=0;
var normalY=0;
var tangentX=0;
var tangentY=0;
var tX=0;
var j=0;
var tCount=0;
var ccp=null;
var PX=0;
var PY=0;
var ccp2=null;
tVec;
tVec2;
tMat;
for(i=0;i<this.m_constraintCount;++i)
{
c=this.m_constraints[i];
bodyA=c.bodyA;
bodyB=c.bodyB;
invMassA=bodyA.m_invMass;
invIA=bodyA.m_invI;
invMassB=bodyB.m_invMass;
invIB=bodyB.m_invI;
normalX=c.normal.x;
normalY=c.normal.y;
tangentX=normalY;
tangentY=-normalX;
tX;
j;
tCount;
if(step.warmStarting)
{
tCount=c.pointCount;
for(j=0;j<tCount;++j)
{
ccp=c.points[j];
ccp.normalImpulse*=step.dtRatio;
ccp.tangentImpulse*=step.dtRatio;
PX=ccp.normalImpulse*normalX+ccp.tangentImpulse*tangentX;
PY=ccp.normalImpulse*normalY+ccp.tangentImpulse*tangentY;
bodyA.m_angularVelocity-=invIA*(ccp.rA.x*PY-ccp.rA.y*PX);
bodyA.m_linearVelocity.x-=invMassA*PX;
bodyA.m_linearVelocity.y-=invMassA*PY;
bodyB.m_angularVelocity+=invIB*(ccp.rB.x*PY-ccp.rB.y*PX);
bodyB.m_linearVelocity.x+=invMassB*PX;
bodyB.m_linearVelocity.y+=invMassB*PY
}
}
else
{
tCount=c.pointCount;
for(j=0;j<tCount;++j)
{
ccp2=c.points[j];
ccp2.normalImpulse=0.0;
ccp2.tangentImpulse=0.0
}
}
}
};
d.SolveVelocityConstraints=function()
{
var j=0;
var ccp=null;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var dvX=0;
var dvY=0;
var vn=0;
var vt=0;
var lambda=0;
var maxFriction=0;
var newImpulse=0;
var PX=0;
var PY=0;
var dX=0;
var dY=0;
var P1X=0;
var P1Y=0;
var P2X=0;
var P2Y=0;
var tMat=null;
var tVec=null;
var i=0;
var c=null;
var bodyA=null;
var bodyB=null;
var wA=0;
var wB=0;
var vA=null;
var vB=null;
var invMassA=0;
var invIA=0;
var invMassB=0;
var invIB=0;
var normalX=0;
var normalY=0;
var tangentX=0;
var tangentY=0;
var friction=0;
var tX=0;
var tCount=0;
var cp1=null;
var cp2=null;
var aX=0;
var aY=0;
var dv1X=0;
var dv1Y=0;
var dv2X=0;
var dv2Y=0;
var vn1=0;
var vn2=0;
var bX=0;
var bY=0;
var k_errorTol=0;
var xX=0;
var xY=0;
j;
ccp;
rAX;
rAY;
rBX;
rBY;
dvX;
dvY;
vn;
vt;
lambda;
maxFriction;
newImpulse;
PX;
PY;
dX;
dY;
P1X;
P1Y;
P2X;
P2Y;
tMat;
tVec;
for(i=0;i<this.m_constraintCount;++i)
{
c=this.m_constraints[i];
bodyA=c.bodyA;
bodyB=c.bodyB;
wA=bodyA.m_angularVelocity;
wB=bodyB.m_angularVelocity;
vA=bodyA.m_linearVelocity;
vB=bodyB.m_linearVelocity;
invMassA=bodyA.m_invMass;
invIA=bodyA.m_invI;
invMassB=bodyB.m_invMass;
invIB=bodyB.m_invI;
normalX=c.normal.x;
normalY=c.normal.y;
tangentX=normalY;
tangentY=-normalX;
friction=c.friction;
tX;
for(j=0;j<c.pointCount;j++)
{
ccp=c.points[j];
dvX=vB.x-wB*ccp.rB.y-vA.x+wA*ccp.rA.y;
dvY=vB.y+wB*ccp.rB.x-vA.y-wA*ccp.rA.x;
vt=dvX*tangentX+dvY*tangentY;
lambda=ccp.tangentMass*-vt;
maxFriction=friction*ccp.normalImpulse;
newImpulse=Box2D.Common.Math.b2Math.Clamp(ccp.tangentImpulse+lambda,-maxFriction,maxFriction);
lambda=newImpulse-ccp.tangentImpulse;
PX=lambda*tangentX;
PY=lambda*tangentY;
vA.x-=invMassA*PX;
vA.y-=invMassA*PY;
wA-=invIA*(ccp.rA.x*PY-ccp.rA.y*PX);
vB.x+=invMassB*PX;
vB.y+=invMassB*PY;
wB+=invIB*(ccp.rB.x*PY-ccp.rB.y*PX);
ccp.tangentImpulse=newImpulse
}
tCount=c.pointCount;
if(c.pointCount==1)
{
ccp=c.points[0];
dvX=vB.x+(-wB*ccp.rB.y)-vA.x-(-wA*ccp.rA.y);
dvY=vB.y+(wB*ccp.rB.x)-vA.y-(wA*ccp.rA.x);
vn=dvX*normalX+dvY*normalY;
lambda=-ccp.normalMass*(vn-ccp.velocityBias);
newImpulse=ccp.normalImpulse+lambda;
newImpulse=newImpulse>0?newImpulse:0.0;
lambda=newImpulse-ccp.normalImpulse;
PX=lambda*normalX;
PY=lambda*normalY;
vA.x-=invMassA*PX;
vA.y-=invMassA*PY;
wA-=invIA*(ccp.rA.x*PY-ccp.rA.y*PX);
vB.x+=invMassB*PX;
vB.y+=invMassB*PY;
wB+=invIB*(ccp.rB.x*PY-ccp.rB.y*PX);
ccp.normalImpulse=newImpulse
}
else
{
cp1=c.points[0];
cp2=c.points[1];
aX=cp1.normalImpulse;
aY=cp2.normalImpulse;
dv1X=vB.x-wB*cp1.rB.y-vA.x+wA*cp1.rA.y;
dv1Y=vB.y+wB*cp1.rB.x-vA.y-wA*cp1.rA.x;
dv2X=vB.x-wB*cp2.rB.y-vA.x+wA*cp2.rA.y;
dv2Y=vB.y+wB*cp2.rB.x-vA.y-wA*cp2.rA.x;
vn1=dv1X*normalX+dv1Y*normalY;
vn2=dv2X*normalX+dv2Y*normalY;
bX=vn1-cp1.velocityBias;
bY=vn2-cp2.velocityBias;
tMat=c.K;
bX-=tMat.col1.x*aX+tMat.col2.x*aY;
bY-=tMat.col1.y*aX+tMat.col2.y*aY;
k_errorTol=0.001;
while(true)
{
tMat=c.normalMass;
xX=-(tMat.col1.x*bX+tMat.col2.x*bY);
xY=-(tMat.col1.y*bX+tMat.col2.y*bY);
if(xX>=0.0&&xY>=0.0)
{
dX=xX-aX;
dY=xY-aY;
P1X=dX*normalX;
P1Y=dX*normalY;
P2X=dY*normalX;
P2Y=dY*normalY;
vA.x-=invMassA*(P1X+P2X);
vA.y-=invMassA*(P1Y+P2Y);
wA-=invIA*(cp1.rA.x*P1Y-cp1.rA.y*P1X+cp2.rA.x*P2Y-cp2.rA.y*P2X);
vB.x+=invMassB*(P1X+P2X);
vB.y+=invMassB*(P1Y+P2Y);
wB+=invIB*(cp1.rB.x*P1Y-cp1.rB.y*P1X+cp2.rB.x*P2Y-cp2.rB.y*P2X);
cp1.normalImpulse=xX;
cp2.normalImpulse=xY;
break;
;
}
xX=-cp1.normalMass*bX;
xY=0.0;
vn1=0.0;
vn2=c.K.col1.y*xX+bY;
if(xX>=0.0&&vn2>=0.0)
{
dX=xX-aX;
dY=xY-aY;
P1X=dX*normalX;
P1Y=dX*normalY;
P2X=dY*normalX;
P2Y=dY*normalY;
vA.x-=invMassA*(P1X+P2X);
vA.y-=invMassA*(P1Y+P2Y);
wA-=invIA*(cp1.rA.x*P1Y-cp1.rA.y*P1X+cp2.rA.x*P2Y-cp2.rA.y*P2X);
vB.x+=invMassB*(P1X+P2X);
vB.y+=invMassB*(P1Y+P2Y);
wB+=invIB*(cp1.rB.x*P1Y-cp1.rB.y*P1X+cp2.rB.x*P2Y-cp2.rB.y*P2X);
cp1.normalImpulse=xX;
cp2.normalImpulse=xY;
break;
;
}
xX=0.0;
xY=-cp2.normalMass*bY;
vn1=c.K.col2.x*xY+bX;
vn2=0.0;
if(xY>=0.0&&vn1>=0.0)
{
dX=xX-aX;
dY=xY-aY;
P1X=dX*normalX;
P1Y=dX*normalY;
P2X=dY*normalX;
P2Y=dY*normalY;
vA.x-=invMassA*(P1X+P2X);
vA.y-=invMassA*(P1Y+P2Y);
wA-=invIA*(cp1.rA.x*P1Y-cp1.rA.y*P1X+cp2.rA.x*P2Y-cp2.rA.y*P2X);
vB.x+=invMassB*(P1X+P2X);
vB.y+=invMassB*(P1Y+P2Y);
wB+=invIB*(cp1.rB.x*P1Y-cp1.rB.y*P1X+cp2.rB.x*P2Y-cp2.rB.y*P2X);
cp1.normalImpulse=xX;
cp2.normalImpulse=xY;
break;
;
}
xX=0.0;
xY=0.0;
vn1=bX;
vn2=bY;
if(vn1>=0.0&&vn2>=0.0)
{
dX=xX-aX;
dY=xY-aY;
P1X=dX*normalX;
P1Y=dX*normalY;
P2X=dY*normalX;
P2Y=dY*normalY;
vA.x-=invMassA*(P1X+P2X);
vA.y-=invMassA*(P1Y+P2Y);
wA-=invIA*(cp1.rA.x*P1Y-cp1.rA.y*P1X+cp2.rA.x*P2Y-cp2.rA.y*P2X);
vB.x+=invMassB*(P1X+P2X);
vB.y+=invMassB*(P1Y+P2Y);
wB+=invIB*(cp1.rB.x*P1Y-cp1.rB.y*P1X+cp2.rB.x*P2Y-cp2.rB.y*P2X);
cp1.normalImpulse=xX;
cp2.normalImpulse=xY;
break;
;
}
break;
;
}
}
bodyA.m_angularVelocity=wA;
bodyB.m_angularVelocity=wB
}
};
d.FinalizeVelocityConstraints=function()
{
var i=0;
var c=null;
var m=null;
var j=0;
var point1=null;
var point2=null;
for(i=0;i<this.m_constraintCount;++i)
{
c=this.m_constraints[i];
m=c.manifold;
for(j=0;j<c.pointCount;++j)
{
point1=m.m_points[j];
point2=c.points[j];
point1.m_normalImpulse=point2.normalImpulse;
point1.m_tangentImpulse=point2.tangentImpulse
}
}
};
d.SolvePositionConstraints=function(baumgarte)
{
var minSeparation=0;
var i=0;
var c=null;
var bodyA=null;
var bodyB=null;
var invMassA=0;
var invIA=0;
var invMassB=0;
var invIB=0;
var normal=null;
var j=0;
var ccp=null;
var point=null;
var separation=0;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var C=0;
var impulse=0;
var PX=0;
var PY=0;
minSeparation=0.0;
for(i=0;i<this.m_constraintCount;i++)
{
c=this.m_constraints[i];
bodyA=c.bodyA;
bodyB=c.bodyB;
invMassA=bodyA.m_mass*bodyA.m_invMass;
invIA=bodyA.m_mass*bodyA.m_invI;
invMassB=bodyB.m_mass*bodyB.m_invMass;
invIB=bodyB.m_mass*bodyB.m_invI;
Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.Initialize(c);
normal=Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_normal;
for(j=0;j<c.pointCount;j++)
{
ccp=c.points[j];
point=Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_points[j];
separation=Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_separations[j];
rAX=point.x-bodyA.m_sweep.c.x;
rAY=point.y-bodyA.m_sweep.c.y;
rBX=point.x-bodyB.m_sweep.c.x;
rBY=point.y-bodyB.m_sweep.c.y;
minSeparation=minSeparation<separation?minSeparation:separation;
C=Box2D.Common.Math.b2Math.Clamp(baumgarte*(separation+Box2D.Common.b2Settings.b2_linearSlop),-Box2D.Common.b2Settings.b2_maxLinearCorrection,0.0);
impulse=-ccp.equalizedMass*C;
PX=impulse*normal.x;
PY=impulse*normal.y;
bodyA.m_sweep.c.x-=invMassA*PX;
bodyA.m_sweep.c.y-=invMassA*PY;
bodyA.m_sweep.a-=invIA*(rAX*PY-rAY*PX);
bodyA.SynchronizeTransform();
bodyB.m_sweep.c.x+=invMassB*PX;
bodyB.m_sweep.c.y+=invMassB*PY;
bodyB.m_sweep.a+=invIB*(rBX*PY-rBY*PX);
bodyB.SynchronizeTransform()
}
}
return minSeparation>-1.5*Box2D.Common.b2Settings.b2_linearSlop;
};
var s={};
s.__init__=function()
{
this.s_worldManifold=new Box2D.Collision.b2WorldManifold();
this.s_psm=new Box2D.Dynamics.Contacts.b2PositionSolverManifold();
};
flash.addDescription("Box2D.Dynamics.Contacts.b2ContactSolver",d,null,s,null,["Box2D.Collision.b2WorldManifold","Box2D.Dynamics.Contacts.b2PositionSolverManifold","Box2D.Dynamics.Contacts.b2ContactConstraint","Box2D.Dynamics.b2TimeStep","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.Reset=function(fixtureA,fixtureB)
{
if(fixtureA==undefined)fixtureA=null;
if(fixtureB==undefined)fixtureB=null;
this.b2Contact_Reset(fixtureA,fixtureB);
Box2D.Common.b2Settings.b2Assert(fixtureA.GetType()==Box2D.Collision.Shapes.b2Shape.e_polygonShape);
Box2D.Common.b2Settings.b2Assert(fixtureB.GetType()==Box2D.Collision.Shapes.b2Shape.e_edgeShape);
};
d.Evaluate=function()
{
var bA=null;
var bB=null;
bA=this.m_fixtureA.GetBody();
bB=this.m_fixtureB.GetBody();
this.b2CollidePolyAndEdge(this.m_manifold,this.m_fixtureA.GetShape(),bA.m_xf,this.m_fixtureB.GetShape(),bB.m_xf);
};
d.b2CollidePolyAndEdge=function(manifold,polygon,xf1,edge,xf2)
{
};
d.b2PolyAndEdgeContact=function()
{
this.b2Contact_constructor();
};
var s={};
s.__init__=function()
{
this.prototype.b2Contact_constructor=this.__base__;
this.prototype.b2Contact_Reset=this.__base__.prototype.Reset;
};
s.Create=function(allocator)
{
return new Box2D.Dynamics.Contacts.b2PolyAndEdgeContact();
};
s.Destroy=function(contact,allocator)
{
};
flash.addDescription("Box2D.Dynamics.Contacts.b2PolyAndEdgeContact",d,"Box2D.Dynamics.Contacts.b2Contact",s,null,["Box2D.Dynamics.Contacts.b2PolyAndEdgeContact","Box2D.Common.b2Settings","Box2D.Collision.Shapes.b2Shape","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Collision.Shapes.b2EdgeShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.points=null;
d.localPlaneNormal=null;
d.localPoint=null;
d.normal=null;
d.normalMass=null;
d.K=null;
d.bodyA=null;
d.bodyB=null;
d.type=0;
d.radius=0;
d.friction=0;
d.restitution=0;
d.pointCount=0;
d.manifold=null;
d.b2ContactConstraint=function()
{
this.localPlaneNormal=new Box2D.Common.Math.b2Vec2();
this.localPoint=new Box2D.Common.Math.b2Vec2();
this.normal=new Box2D.Common.Math.b2Vec2();
this.normalMass=new Box2D.Common.Math.b2Mat22();
this.K=new Box2D.Common.Math.b2Mat22();
var i=0;
this.points=new Array();
for(i=0;i<Box2D.Common.b2Settings.b2_maxManifoldPoints;i++)
{
this.points[i]=new Box2D.Dynamics.Contacts.b2ContactConstraintPoint()
}
};
flash.addDescription("Box2D.Dynamics.Contacts.b2ContactConstraint",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Mat22","Box2D.Dynamics.Contacts.b2ContactConstraintPoint","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.Reset=function(fixtureA,fixtureB)
{
if(fixtureA==undefined)fixtureA=null;
if(fixtureB==undefined)fixtureB=null;
this.b2Contact_Reset(fixtureA,fixtureB);
};
d.Evaluate=function()
{
var bA=null;
var bB=null;
bA=this.m_fixtureA.GetBody();
bB=this.m_fixtureB.GetBody();
Box2D.Collision.b2Collision.CollideCircles(this.m_manifold,this.m_fixtureA.GetShape(),bA.m_xf,this.m_fixtureB.GetShape(),bB.m_xf);
};
d.b2CircleContact=function()
{
this.b2Contact_constructor();
};
var s={};
s.__init__=function()
{
this.prototype.b2Contact_constructor=this.__base__;
this.prototype.b2Contact_Reset=this.__base__.prototype.Reset;
};
s.Create=function(allocator)
{
return new Box2D.Dynamics.Contacts.b2CircleContact();
};
s.Destroy=function(contact,allocator)
{
};
flash.addDescription("Box2D.Dynamics.Contacts.b2CircleContact",d,"Box2D.Dynamics.Contacts.b2Contact",s,null,["Box2D.Dynamics.Contacts.b2CircleContact","Box2D.Collision.b2Collision","Box2D.Collision.Shapes.b2CircleShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_flags=0;
d.m_prev=null;
d.m_next=null;
d.m_nodeA=null;
d.m_nodeB=null;
d.m_fixtureA=null;
d.m_fixtureB=null;
d.m_manifold=null;
d.m_oldManifold=null;
d.m_toi=0;
d.b2Contact=function()
{
this.m_nodeA=new Box2D.Dynamics.Contacts.b2ContactEdge();
this.m_nodeB=new Box2D.Dynamics.Contacts.b2ContactEdge();
this.m_manifold=new Box2D.Collision.b2Manifold();
this.m_oldManifold=new Box2D.Collision.b2Manifold();
};
d.GetManifold=function()
{
return this.m_manifold;
};
d.GetWorldManifold=function(worldManifold)
{
var bodyA=null;
var bodyB=null;
var shapeA=null;
var shapeB=null;
bodyA=this.m_fixtureA.GetBody();
bodyB=this.m_fixtureB.GetBody();
shapeA=this.m_fixtureA.GetShape();
shapeB=this.m_fixtureB.GetShape();
worldManifold.Initialize(this.m_manifold,bodyA.GetTransform(),shapeA.m_radius,bodyB.GetTransform(),shapeB.m_radius);
};
d.IsTouching=function()
{
return(this.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag)==Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag;
};
d.IsContinuous=function()
{
return(this.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag)==Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag;
};
d.SetSensor=function(sensor)
{
if(sensor)
{
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag
}
else
{
this.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag
}
};
d.IsSensor=function()
{
return(this.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag)==Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag;
};
d.SetEnabled=function(flag)
{
if(flag)
{
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag
}
else
{
this.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag
}
};
d.IsEnabled=function()
{
return(this.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag)==Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag;
};
d.GetNext=function()
{
return this.m_next;
};
d.GetFixtureA=function()
{
return this.m_fixtureA;
};
d.GetFixtureB=function()
{
return this.m_fixtureB;
};
d.FlagForFiltering=function()
{
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_filterFlag;
};
d.Reset=function(fixtureA,fixtureB)
{
if(fixtureA==undefined)fixtureA=null;
if(fixtureB==undefined)fixtureB=null;
var bodyA=null;
var bodyB=null;
this.m_flags=Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag;
if(!fixtureA||!fixtureB)
{
this.m_fixtureA=null;
this.m_fixtureB=null;
return
}
if(fixtureA.IsSensor()||fixtureB.IsSensor())
{
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag
}
bodyA=fixtureA.GetBody();
bodyB=fixtureB.GetBody();
if(bodyA.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody||bodyA.IsBullet()||bodyB.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody||bodyB.IsBullet())
{
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag
}
this.m_fixtureA=fixtureA;
this.m_fixtureB=fixtureB;
this.m_manifold.m_pointCount=0;
this.m_prev=null;
this.m_next=null;
this.m_nodeA.contact=null;
this.m_nodeA.prev=null;
this.m_nodeA.next=null;
this.m_nodeA.other=null;
this.m_nodeB.contact=null;
this.m_nodeB.prev=null;
this.m_nodeB.next=null;
this.m_nodeB.other=null;
};
d.Update=function(listener)
{
var tManifold=null;
var touching=false;
var wasTouching=false;
var bodyA=null;
var bodyB=null;
var aabbOverlap=false;
var shapeA=null;
var shapeB=null;
var xfA=null;
var xfB=null;
var i=0;
var mp2=null;
var id2=null;
var j=0;
var mp1=null;
tManifold=this.m_oldManifold;
this.m_oldManifold=this.m_manifold;
this.m_manifold=tManifold;
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag;
touching=false;
wasTouching=(this.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag)==Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag;
bodyA=this.m_fixtureA.m_body;
bodyB=this.m_fixtureB.m_body;
aabbOverlap=this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
if(this.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag)
{
if(aabbOverlap)
{
shapeA=this.m_fixtureA.GetShape();
shapeB=this.m_fixtureB.GetShape();
xfA=bodyA.GetTransform();
xfB=bodyB.GetTransform();
touching=Box2D.Collision.Shapes.b2Shape.TestOverlap(shapeA,xfA,shapeB,xfB)
}
this.m_manifold.m_pointCount=0
}
else
{
if(bodyA.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody||bodyA.IsBullet()||bodyB.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody||bodyB.IsBullet())
{
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag
}
else
{
this.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag
}
if(aabbOverlap)
{
this.Evaluate();
touching=this.m_manifold.m_pointCount>0;
for(i=0;i<this.m_manifold.m_pointCount;++i)
{
mp2=this.m_manifold.m_points[i];
mp2.m_normalImpulse=0.0;
mp2.m_tangentImpulse=0.0;
id2=mp2.m_id;
for(j=0;j<this.m_oldManifold.m_pointCount;++j)
{
mp1=this.m_oldManifold.m_points[j];
if(mp1.m_id.get_key()==id2.get_key())
{
mp2.m_normalImpulse=mp1.m_normalImpulse;
mp2.m_tangentImpulse=mp1.m_tangentImpulse;
break;
;
}
}
}
}
else
{
this.m_manifold.m_pointCount=0
}
if(touching!=wasTouching)
{
bodyA.SetAwake(true);
bodyB.SetAwake(true)
}
}
if(touching)
{
this.m_flags|=Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag
}
else
{
this.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag
}
if(wasTouching==false&&touching==true)
{
listener.BeginContact(this)
}
if(wasTouching==true&&touching==false)
{
listener.EndContact(this)
}
if((this.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag)==0)
{
listener.PreSolve(this,this.m_oldManifold)
}
};
d.Evaluate=function()
{
};
d.ComputeTOI=function(sweepA,sweepB)
{
Box2D.Dynamics.Contacts.b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
Box2D.Dynamics.Contacts.b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
Box2D.Dynamics.Contacts.b2Contact.s_input.sweepA=sweepA;
Box2D.Dynamics.Contacts.b2Contact.s_input.sweepB=sweepB;
Box2D.Dynamics.Contacts.b2Contact.s_input.tolerance=Box2D.Common.b2Settings.b2_linearSlop;
return Box2D.Collision.b2TimeOfImpact.TimeOfImpact(Box2D.Dynamics.Contacts.b2Contact.s_input);
};
var s={};
s.__init__=function()
{
this.e_sensorFlag=0x0001;
this.e_continuousFlag=0x0002;
this.e_islandFlag=0x0004;
this.e_toiFlag=0x0008;
this.e_touchingFlag=0x0010;
this.e_enabledFlag=0x0020;
this.e_filterFlag=0x0040;
this.s_input=new Box2D.Collision.b2TOIInput();
};
flash.addDescription("Box2D.Dynamics.Contacts.b2Contact",d,null,s,null,["Box2D.Collision.b2TOIInput","Box2D.Dynamics.Contacts.b2ContactEdge","Box2D.Collision.b2Manifold","Box2D.Dynamics.b2Body","Box2D.Collision.Shapes.b2Shape","Box2D.Common.b2Settings","Box2D.Collision.b2TimeOfImpact"]);
}
());;
(function()
{
"use strict";
var d={};
d.localPoint=null;
d.rA=null;
d.rB=null;
d.normalImpulse=0;
d.tangentImpulse=0;
d.normalMass=0;
d.tangentMass=0;
d.equalizedMass=0;
d.velocityBias=0;
d.b2ContactConstraintPoint=function()
{
this.localPoint=new Box2D.Common.Math.b2Vec2();
this.rA=new Box2D.Common.Math.b2Vec2();
this.rB=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Dynamics.Contacts.b2ContactConstraintPoint",d,null,null,null,["Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_normal=null;
d.m_points=null;
d.m_separations=null;
d.b2PositionSolverManifold=function()
{
var i=0;
this.m_normal=new Box2D.Common.Math.b2Vec2();
this.m_separations=new Array();
this.m_points=new Array();
for(i=0;i<Box2D.Common.b2Settings.b2_maxManifoldPoints;i++)
{
this.m_points[i]=new Box2D.Common.Math.b2Vec2()
}
};
d.Initialize=function(cc)
{
var i=0;
var clipPointX=0;
var clipPointY=0;
var tMat=null;
var tVec=null;
var planePointX=0;
var planePointY=0;
var pointAX=0;
var pointAY=0;
var pointBX=0;
var pointBY=0;
var dX=0;
var dY=0;
var d2=0;
var d=0;
Box2D.Common.b2Settings.b2Assert(cc.pointCount>0);
i;
clipPointX;
clipPointY;
tMat;
tVec;
planePointX;
planePointY;
switch(cc.type)
{
case Box2D.Collision.b2Manifold.e_circles:
{
tMat=cc.bodyA.m_xf.R;
tVec=cc.localPoint;
pointAX=cc.bodyA.m_xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointAY=cc.bodyA.m_xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tMat=cc.bodyB.m_xf.R;
tVec=cc.points[0].localPoint;
pointBX=cc.bodyB.m_xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointBY=cc.bodyB.m_xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
dX=pointBX-pointAX;
dY=pointBY-pointAY;
d2=dX*dX+dY*dY;
if(d2>Number.MIN_VALUE*Number.MIN_VALUE)
{
d=Math.sqrt(d2);
this.m_normal.x=dX/d;
this.m_normal.y=dY/d
}
else
{
this.m_normal.x=1.0;
this.m_normal.y=0.0
}
this.m_points[0].x=0.5*(pointAX+pointBX);
this.m_points[0].y=0.5*(pointAY+pointBY);
this.m_separations[0]=dX*this.m_normal.x+dY*this.m_normal.y-cc.radius
};
break;
;case Box2D.Collision.b2Manifold.e_faceA:
{
tMat=cc.bodyA.m_xf.R;
tVec=cc.localPlaneNormal;
this.m_normal.x=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
this.m_normal.y=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tMat=cc.bodyA.m_xf.R;
tVec=cc.localPoint;
planePointX=cc.bodyA.m_xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
planePointY=cc.bodyA.m_xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tMat=cc.bodyB.m_xf.R;
for(i=0;i<cc.pointCount;++i)
{
tVec=cc.points[i].localPoint;
clipPointX=cc.bodyB.m_xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
clipPointY=cc.bodyB.m_xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
this.m_separations[i]=(clipPointX-planePointX)*this.m_normal.x+(clipPointY-planePointY)*this.m_normal.y-cc.radius;
this.m_points[i].x=clipPointX;
this.m_points[i].y=clipPointY
}
};
break;
;case Box2D.Collision.b2Manifold.e_faceB:
{
tMat=cc.bodyB.m_xf.R;
tVec=cc.localPlaneNormal;
this.m_normal.x=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
this.m_normal.y=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tMat=cc.bodyB.m_xf.R;
tVec=cc.localPoint;
planePointX=cc.bodyB.m_xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
planePointY=cc.bodyB.m_xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tMat=cc.bodyA.m_xf.R;
for(i=0;i<cc.pointCount;++i)
{
tVec=cc.points[i].localPoint;
clipPointX=cc.bodyA.m_xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
clipPointY=cc.bodyA.m_xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
this.m_separations[i]=(clipPointX-planePointX)*this.m_normal.x+(clipPointY-planePointY)*this.m_normal.y-cc.radius;
this.m_points[i].Set(clipPointX,clipPointY)
}
this.m_normal.x*=-1;
this.m_normal.y*=-1
};
break;
;
}
};
var s={};
s.__init__=function()
{
this.circlePointA=new Box2D.Common.Math.b2Vec2();
this.circlePointB=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Dynamics.Contacts.b2PositionSolverManifold",d,null,s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.b2Settings","Box2D.Collision.b2Manifold"]);
}
());;
(function()
{
"use strict";
var d={};
d.Reset=function(fixtureA,fixtureB)
{
if(fixtureA==undefined)fixtureA=null;
if(fixtureB==undefined)fixtureB=null;
this.b2Contact_Reset(fixtureA,fixtureB);
};
d.Evaluate=function()
{
var bA=null;
var bB=null;
bA=this.m_fixtureA.GetBody();
bB=this.m_fixtureB.GetBody();
Box2D.Collision.b2Collision.CollidePolygons(this.m_manifold,this.m_fixtureA.GetShape(),bA.m_xf,this.m_fixtureB.GetShape(),bB.m_xf);
};
d.b2PolygonContact=function()
{
this.b2Contact_constructor();
};
var s={};
s.__init__=function()
{
this.prototype.b2Contact_constructor=this.__base__;
this.prototype.b2Contact_Reset=this.__base__.prototype.Reset;
};
s.Create=function(allocator)
{
return new Box2D.Dynamics.Contacts.b2PolygonContact();
};
s.Destroy=function(contact,allocator)
{
};
flash.addDescription("Box2D.Dynamics.Contacts.b2PolygonContact",d,"Box2D.Dynamics.Contacts.b2Contact",s,null,["Box2D.Dynamics.Contacts.b2PolygonContact","Box2D.Collision.b2Collision","Box2D.Collision.Shapes.b2PolygonShape"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_registers=null;
d.m_allocator=null;
d.b2ContactFactory=function(allocator)
{
this.m_allocator=allocator;
this.InitializeRegisters();
};
d.AddType=function(createFcn,destroyFcn,type1,type2)
{
type1=flash.int(type1);
type2=flash.int(type2);
this.m_registers[type1][type2].createFcn=createFcn;
this.m_registers[type1][type2].destroyFcn=destroyFcn;
this.m_registers[type1][type2].primary=true;
if(type1!=type2)
{
this.m_registers[type2][type1].createFcn=createFcn;
this.m_registers[type2][type1].destroyFcn=destroyFcn;
this.m_registers[type2][type1].primary=false
}
};
d.InitializeRegisters=function()
{
var i=0;
var j=0;
this.m_registers=new Array();
for(i=0;i<Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount;i++)
{
this.m_registers[i]=new Array();
for(j=0;j<Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount;j++)
{
this.m_registers[i][j]=new Box2D.Dynamics.Contacts.b2ContactRegister()
}
}
this.AddType(flash.bindFunction(Box2D.Dynamics.Contacts.b2CircleContact,Box2D.Dynamics.Contacts.b2CircleContact.Create),flash.bindFunction(Box2D.Dynamics.Contacts.b2CircleContact,Box2D.Dynamics.Contacts.b2CircleContact.Destroy),Box2D.Collision.Shapes.b2Shape.e_circleShape,Box2D.Collision.Shapes.b2Shape.e_circleShape);
this.AddType(flash.bindFunction(Box2D.Dynamics.Contacts.b2PolyAndCircleContact,Box2D.Dynamics.Contacts.b2PolyAndCircleContact.Create),flash.bindFunction(Box2D.Dynamics.Contacts.b2PolyAndCircleContact,Box2D.Dynamics.Contacts.b2PolyAndCircleContact.Destroy),Box2D.Collision.Shapes.b2Shape.e_polygonShape,Box2D.Collision.Shapes.b2Shape.e_circleShape);
this.AddType(flash.bindFunction(Box2D.Dynamics.Contacts.b2PolygonContact,Box2D.Dynamics.Contacts.b2PolygonContact.Create),flash.bindFunction(Box2D.Dynamics.Contacts.b2PolygonContact,Box2D.Dynamics.Contacts.b2PolygonContact.Destroy),Box2D.Collision.Shapes.b2Shape.e_polygonShape,Box2D.Collision.Shapes.b2Shape.e_polygonShape);
this.AddType(flash.bindFunction(Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,Box2D.Dynamics.Contacts.b2EdgeAndCircleContact.Create),flash.bindFunction(Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,Box2D.Dynamics.Contacts.b2EdgeAndCircleContact.Destroy),Box2D.Collision.Shapes.b2Shape.e_edgeShape,Box2D.Collision.Shapes.b2Shape.e_circleShape);
this.AddType(flash.bindFunction(Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,Box2D.Dynamics.Contacts.b2PolyAndEdgeContact.Create),flash.bindFunction(Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,Box2D.Dynamics.Contacts.b2PolyAndEdgeContact.Destroy),Box2D.Collision.Shapes.b2Shape.e_polygonShape,Box2D.Collision.Shapes.b2Shape.e_edgeShape);
};
d.Create=function(fixtureA,fixtureB)
{
var type1=0;
var type2=0;
var reg=null;
var c=null;
var createFcn=null;
type1=fixtureA.GetType();
type2=fixtureB.GetType();
reg=this.m_registers[type1][type2];
c;
if(reg.pool)
{
c=reg.pool;
reg.pool=c.m_next;
reg.poolCount--;
c.Reset(fixtureA,fixtureB);
return c
}
createFcn=flash.bindFunction(reg,reg.createFcn);
if(createFcn!=null)
{
if(reg.primary)
{
c=createFcn(this.m_allocator);
c.Reset(fixtureA,fixtureB);
return c
}
else
{
c=createFcn(this.m_allocator);
c.Reset(fixtureB,fixtureA);
return c
}
}
else
{
return null
}
};
d.Destroy=function(contact)
{
var type1=0;
var type2=0;
var reg=null;
var destroyFcn=null;
if(contact.m_manifold.m_pointCount>0)
{
contact.m_fixtureA.m_body.SetAwake(true);
contact.m_fixtureB.m_body.SetAwake(true)
}
type1=contact.m_fixtureA.GetType();
type2=contact.m_fixtureB.GetType();
reg=this.m_registers[type1][type2];
if(true)
{
reg.poolCount++;
contact.m_next=reg.pool;
reg.pool=contact
}
destroyFcn=flash.bindFunction(reg,reg.destroyFcn);
destroyFcn(contact,this.m_allocator);
};
flash.addDescription("Box2D.Dynamics.Contacts.b2ContactFactory",d,null,null,null,["Box2D.Dynamics.Contacts.b2ContactRegister","Box2D.Collision.Shapes.b2Shape","Box2D.Dynamics.Contacts.b2CircleContact","Box2D.Dynamics.Contacts.b2PolyAndCircleContact","Box2D.Dynamics.Contacts.b2PolygonContact","Box2D.Dynamics.Contacts.b2EdgeAndCircleContact","Box2D.Dynamics.Contacts.b2PolyAndEdgeContact"]);
}
());;
(function()
{
"use strict";
var d={};
d.groundAnchorA=null;
d.groundAnchorB=null;
d.localAnchorA=null;
d.localAnchorB=null;
d.lengthA=0;
d.maxLengthA=0;
d.lengthB=0;
d.maxLengthB=0;
d.ratio=0;
d.b2PulleyJointDef=function()
{
this.groundAnchorA=new Box2D.Common.Math.b2Vec2();
this.groundAnchorB=new Box2D.Common.Math.b2Vec2();
this.localAnchorA=new Box2D.Common.Math.b2Vec2();
this.localAnchorB=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint;
this.groundAnchorA.Set(-1.0,1.0);
this.groundAnchorB.Set(1.0,1.0);
this.localAnchorA.Set(-1.0,0.0);
this.localAnchorB.Set(1.0,0.0);
this.lengthA=0.0;
this.maxLengthA=0.0;
this.lengthB=0.0;
this.maxLengthB=0.0;
this.ratio=1.0;
this.collideConnected=true;
};
d.Initialize=function(bA,bB,gaA,gaB,anchorA,anchorB,r)
{
var d1X=0;
var d1Y=0;
var d2X=0;
var d2Y=0;
var C=0;
this.bodyA=bA;
this.bodyB=bB;
this.groundAnchorA.SetV(gaA);
this.groundAnchorB.SetV(gaB);
this.localAnchorA=this.bodyA.GetLocalPoint(anchorA);
this.localAnchorB=this.bodyB.GetLocalPoint(anchorB);
d1X=anchorA.x-gaA.x;
d1Y=anchorA.y-gaA.y;
this.lengthA=Math.sqrt(d1X*d1X+d1Y*d1Y);
d2X=anchorB.x-gaB.x;
d2Y=anchorB.y-gaB.y;
this.lengthB=Math.sqrt(d2X*d2X+d2Y*d2Y);
this.ratio=r;
C=this.lengthA+this.ratio*this.lengthB;
this.maxLengthA=C-this.ratio*Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength;
this.maxLengthB=(C-Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength)/this.ratio;
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2PulleyJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint","Box2D.Dynamics.Joints.b2PulleyJoint"]);
}
());;
(function()
{
"use strict";
var d={};
d.localAnchorA=null;
d.localAnchorB=null;
d.localAxisA=null;
d.enableLimit=false;
d.lowerTranslation=0;
d.upperTranslation=0;
d.enableMotor=false;
d.maxMotorForce=0;
d.motorSpeed=0;
d.b2LineJointDef=function()
{
this.localAnchorA=new Box2D.Common.Math.b2Vec2();
this.localAnchorB=new Box2D.Common.Math.b2Vec2();
this.localAxisA=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_lineJoint;
this.localAxisA.Set(1.0,0.0);
this.enableLimit=false;
this.lowerTranslation=0.0;
this.upperTranslation=0.0;
this.enableMotor=false;
this.maxMotorForce=0.0;
this.motorSpeed=0.0;
};
d.Initialize=function(bA,bB,anchor,axis)
{
this.bodyA=bA;
this.bodyB=bB;
this.localAnchorA=this.bodyA.GetLocalPoint(anchor);
this.localAnchorB=this.bodyB.GetLocalPoint(anchor);
this.localAxisA=this.bodyA.GetLocalVector(axis);
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2LineJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.localAnchorA=null;
d.localAnchorB=null;
d.localAxisA=null;
d.referenceAngle=0;
d.enableLimit=false;
d.lowerTranslation=0;
d.upperTranslation=0;
d.enableMotor=false;
d.maxMotorForce=0;
d.motorSpeed=0;
d.b2PrismaticJointDef=function()
{
this.localAnchorA=new Box2D.Common.Math.b2Vec2();
this.localAnchorB=new Box2D.Common.Math.b2Vec2();
this.localAxisA=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint;
this.localAxisA.Set(1.0,0.0);
this.referenceAngle=0.0;
this.enableLimit=false;
this.lowerTranslation=0.0;
this.upperTranslation=0.0;
this.enableMotor=false;
this.maxMotorForce=0.0;
this.motorSpeed=0.0;
};
d.Initialize=function(bA,bB,anchor,axis)
{
this.bodyA=bA;
this.bodyB=bB;
this.localAnchorA=this.bodyA.GetLocalPoint(anchor);
this.localAnchorB=this.bodyB.GetLocalPoint(anchor);
this.localAxisA=this.bodyA.GetLocalVector(axis);
this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle();
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2PrismaticJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.joint1=null;
d.joint2=null;
d.ratio=0;
d.b2GearJointDef=function()
{
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_gearJoint;
this.joint1=null;
this.joint2=null;
this.ratio=1.0;
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2GearJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.target=null;
d.maxForce=0;
d.frequencyHz=0;
d.dampingRatio=0;
d.b2MouseJointDef=function()
{
this.target=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_mouseJoint;
this.maxForce=0.0;
this.frequencyHz=5.0;
this.dampingRatio=0.7;
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2MouseJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_localAnchorA=null;
d.m_localAnchorB=null;
d.m_referenceAngle=0;
d.m_impulse=null;
d.m_mass=null;
d.b2WeldJoint=function(def)
{
this.m_localAnchorA=new Box2D.Common.Math.b2Vec2();
this.m_localAnchorB=new Box2D.Common.Math.b2Vec2();
this.m_impulse=new Box2D.Common.Math.b2Vec3();
this.m_mass=new Box2D.Common.Math.b2Mat33();
this.b2Joint_constructor(def);
this.m_localAnchorA.SetV(def.localAnchorA);
this.m_localAnchorB.SetV(def.localAnchorB);
this.m_referenceAngle=def.referenceAngle;
this.m_impulse.SetZero();
this.m_mass=new Box2D.Common.Math.b2Mat33();
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*this.m_impulse.x,inv_dt*this.m_impulse.y);
};
d.GetReactionTorque=function(inv_dt)
{
return inv_dt*this.m_impulse.z;
};
d.InitVelocityConstraints=function(step)
{
var tMat=null;
var tX=0;
var bA=null;
var bB=null;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var mA=0;
var mB=0;
var iA=0;
var iB=0;
tMat;
tX;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat=bA.m_xf.R;
rAX=this.m_localAnchorA.x-bA.m_sweep.localCenter.x;
rAY=this.m_localAnchorA.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*rAX+tMat.col2.x*rAY);
rAY=(tMat.col1.y*rAX+tMat.col2.y*rAY);
rAX=tX;
tMat=bB.m_xf.R;
rBX=this.m_localAnchorB.x-bB.m_sweep.localCenter.x;
rBY=this.m_localAnchorB.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*rBX+tMat.col2.x*rBY);
rBY=(tMat.col1.y*rBX+tMat.col2.y*rBY);
rBX=tX;
mA=bA.m_invMass;
mB=bB.m_invMass;
iA=bA.m_invI;
iB=bB.m_invI;
this.m_mass.col1.x=mA+mB+rAY*rAY*iA+rBY*rBY*iB;
this.m_mass.col2.x=-rAY*rAX*iA-rBY*rBX*iB;
this.m_mass.col3.x=-rAY*iA-rBY*iB;
this.m_mass.col1.y=this.m_mass.col2.x;
this.m_mass.col2.y=mA+mB+rAX*rAX*iA+rBX*rBX*iB;
this.m_mass.col3.y=rAX*iA+rBX*iB;
this.m_mass.col1.z=this.m_mass.col3.x;
this.m_mass.col2.z=this.m_mass.col3.y;
this.m_mass.col3.z=iA+iB;
if(step.warmStarting)
{
this.m_impulse.x*=step.dtRatio;
this.m_impulse.y*=step.dtRatio;
this.m_impulse.z*=step.dtRatio;
bA.m_linearVelocity.x-=mA*this.m_impulse.x;
bA.m_linearVelocity.y-=mA*this.m_impulse.y;
bA.m_angularVelocity-=iA*(rAX*this.m_impulse.y-rAY*this.m_impulse.x+this.m_impulse.z);
bB.m_linearVelocity.x+=mB*this.m_impulse.x;
bB.m_linearVelocity.y+=mB*this.m_impulse.y;
bB.m_angularVelocity+=iB*(rBX*this.m_impulse.y-rBY*this.m_impulse.x+this.m_impulse.z)
}
else
{
this.m_impulse.SetZero()
}
};
d.SolveVelocityConstraints=function(step)
{
var tMat=null;
var tX=0;
var bA=null;
var bB=null;
var vA=null;
var wA=0;
var vB=null;
var wB=0;
var mA=0;
var mB=0;
var iA=0;
var iB=0;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var Cdot1X=0;
var Cdot1Y=0;
var Cdot2=0;
var impulse=null;
tMat;
tX;
bA=this.m_bodyA;
bB=this.m_bodyB;
vA=bA.m_linearVelocity;
wA=bA.m_angularVelocity;
vB=bB.m_linearVelocity;
wB=bB.m_angularVelocity;
mA=bA.m_invMass;
mB=bB.m_invMass;
iA=bA.m_invI;
iB=bB.m_invI;
tMat=bA.m_xf.R;
rAX=this.m_localAnchorA.x-bA.m_sweep.localCenter.x;
rAY=this.m_localAnchorA.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*rAX+tMat.col2.x*rAY);
rAY=(tMat.col1.y*rAX+tMat.col2.y*rAY);
rAX=tX;
tMat=bB.m_xf.R;
rBX=this.m_localAnchorB.x-bB.m_sweep.localCenter.x;
rBY=this.m_localAnchorB.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*rBX+tMat.col2.x*rBY);
rBY=(tMat.col1.y*rBX+tMat.col2.y*rBY);
rBX=tX;
Cdot1X=vB.x-wB*rBY-vA.x+wA*rAY;
Cdot1Y=vB.y+wB*rBX-vA.y-wA*rAX;
Cdot2=wB-wA;
impulse=new Box2D.Common.Math.b2Vec3();
this.m_mass.Solve33(impulse,-Cdot1X,-Cdot1Y,-Cdot2);
this.m_impulse.Add(impulse);
vA.x-=mA*impulse.x;
vA.y-=mA*impulse.y;
wA-=iA*(rAX*impulse.y-rAY*impulse.x+impulse.z);
vB.x+=mB*impulse.x;
vB.y+=mB*impulse.y;
wB+=iB*(rBX*impulse.y-rBY*impulse.x+impulse.z);
bA.m_angularVelocity=wA;
bB.m_angularVelocity=wB;
};
d.SolvePositionConstraints=function(baumgarte)
{
var tMat=null;
var tX=0;
var bA=null;
var bB=null;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var mA=0;
var mB=0;
var iA=0;
var iB=0;
var C1X=0;
var C1Y=0;
var C2=0;
var k_allowedStretch=0;
var positionError=0;
var angularError=0;
var impulse=null;
tMat;
tX;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat=bA.m_xf.R;
rAX=this.m_localAnchorA.x-bA.m_sweep.localCenter.x;
rAY=this.m_localAnchorA.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*rAX+tMat.col2.x*rAY);
rAY=(tMat.col1.y*rAX+tMat.col2.y*rAY);
rAX=tX;
tMat=bB.m_xf.R;
rBX=this.m_localAnchorB.x-bB.m_sweep.localCenter.x;
rBY=this.m_localAnchorB.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*rBX+tMat.col2.x*rBY);
rBY=(tMat.col1.y*rBX+tMat.col2.y*rBY);
rBX=tX;
mA=bA.m_invMass;
mB=bB.m_invMass;
iA=bA.m_invI;
iB=bB.m_invI;
C1X=bB.m_sweep.c.x+rBX-bA.m_sweep.c.x-rAX;
C1Y=bB.m_sweep.c.y+rBY-bA.m_sweep.c.y-rAY;
C2=bB.m_sweep.a-bA.m_sweep.a-this.m_referenceAngle;
k_allowedStretch=10.0*Box2D.Common.b2Settings.b2_linearSlop;
positionError=Math.sqrt(C1X*C1X+C1Y*C1Y);
angularError=Box2D.Common.Math.b2Math.Abs(C2);
if(positionError>k_allowedStretch)
{
iA*=1.0;
iB*=1.0
}
this.m_mass.col1.x=mA+mB+rAY*rAY*iA+rBY*rBY*iB;
this.m_mass.col2.x=-rAY*rAX*iA-rBY*rBX*iB;
this.m_mass.col3.x=-rAY*iA-rBY*iB;
this.m_mass.col1.y=this.m_mass.col2.x;
this.m_mass.col2.y=mA+mB+rAX*rAX*iA+rBX*rBX*iB;
this.m_mass.col3.y=rAX*iA+rBX*iB;
this.m_mass.col1.z=this.m_mass.col3.x;
this.m_mass.col2.z=this.m_mass.col3.y;
this.m_mass.col3.z=iA+iB;
impulse=new Box2D.Common.Math.b2Vec3();
this.m_mass.Solve33(impulse,-C1X,-C1Y,-C2);
bA.m_sweep.c.x-=mA*impulse.x;
bA.m_sweep.c.y-=mA*impulse.y;
bA.m_sweep.a-=iA*(rAX*impulse.y-rAY*impulse.x+impulse.z);
bB.m_sweep.c.x+=mB*impulse.x;
bB.m_sweep.c.y+=mB*impulse.y;
bB.m_sweep.a+=iB*(rBX*impulse.y-rBY*impulse.x+impulse.z);
bA.SynchronizeTransform();
bB.SynchronizeTransform();
return positionError<=Box2D.Common.b2Settings.b2_linearSlop&&angularError<=Box2D.Common.b2Settings.b2_angularSlop;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2WeldJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Vec3","Box2D.Common.Math.b2Mat33","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_localAnchor1=null;
d.m_localAnchor2=null;
d.m_localXAxis1=null;
d.m_localYAxis1=null;
d.m_refAngle=0;
d.m_axis=null;
d.m_perp=null;
d.m_s1=0;
d.m_s2=0;
d.m_a1=0;
d.m_a2=0;
d.m_K=null;
d.m_impulse=null;
d.m_motorMass=0;
d.m_motorImpulse=0;
d.m_lowerTranslation=0;
d.m_upperTranslation=0;
d.m_maxMotorForce=0;
d.m_motorSpeed=0;
d.m_enableLimit=false;
d.m_enableMotor=false;
d.m_limitState=0;
d.b2PrismaticJoint=function(def)
{
this.m_localAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor2=new Box2D.Common.Math.b2Vec2();
this.m_localXAxis1=new Box2D.Common.Math.b2Vec2();
this.m_localYAxis1=new Box2D.Common.Math.b2Vec2();
this.m_axis=new Box2D.Common.Math.b2Vec2();
this.m_perp=new Box2D.Common.Math.b2Vec2();
this.m_K=new Box2D.Common.Math.b2Mat33();
this.m_impulse=new Box2D.Common.Math.b2Vec3();
var tMat=null;
var tX=0;
var tY=0;
this.b2Joint_constructor(def);
tMat;
tX;
tY;
this.m_localAnchor1.SetV(def.localAnchorA);
this.m_localAnchor2.SetV(def.localAnchorB);
this.m_localXAxis1.SetV(def.localAxisA);
this.m_localYAxis1.x=-this.m_localXAxis1.y;
this.m_localYAxis1.y=this.m_localXAxis1.x;
this.m_refAngle=def.referenceAngle;
this.m_impulse.SetZero();
this.m_motorMass=0.0;
this.m_motorImpulse=0.0;
this.m_lowerTranslation=def.lowerTranslation;
this.m_upperTranslation=def.upperTranslation;
this.m_maxMotorForce=def.maxMotorForce;
this.m_motorSpeed=def.motorSpeed;
this.m_enableLimit=def.enableLimit;
this.m_enableMotor=def.enableMotor;
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_axis.SetZero();
this.m_perp.SetZero();
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.x),inv_dt*(this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.y));
};
d.GetReactionTorque=function(inv_dt)
{
return inv_dt*this.m_impulse.y;
};
d.InitVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var tMat=null;
var tX=0;
var xf1=null;
var xf2=null;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var dX=0;
var dY=0;
var m1=0;
var m2=0;
var i1=0;
var i2=0;
var jointTransition=0;
var PX=0;
var PY=0;
var L1=0;
var L2=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tX;
this.m_localCenterA.SetV(bA.GetLocalCenter());
this.m_localCenterB.SetV(bB.GetLocalCenter());
xf1=bA.GetTransform();
xf2=bB.GetTransform();
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-this.m_localCenterA.x;
r1Y=this.m_localAnchor1.y-this.m_localCenterA.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-this.m_localCenterB.x;
r2Y=this.m_localAnchor2.y-this.m_localCenterB.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
dX=bB.m_sweep.c.x+r2X-bA.m_sweep.c.x-r1X;
dY=bB.m_sweep.c.y+r2Y-bA.m_sweep.c.y-r1Y;
this.m_invMassA=bA.m_invMass;
this.m_invMassB=bB.m_invMass;
this.m_invIA=bA.m_invI;
this.m_invIB=bB.m_invI;
{
this.m_axis.SetV(Box2D.Common.Math.b2Math.MulMV(xf1.R,this.m_localXAxis1));
this.m_a1=(dX+r1X)*this.m_axis.y-(dY+r1Y)*this.m_axis.x;
this.m_a2=r2X*this.m_axis.y-r2Y*this.m_axis.x;
this.m_motorMass=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_a1*this.m_a1+this.m_invIB*this.m_a2*this.m_a2;
if(this.m_motorMass>Number.MIN_VALUE)
{
this.m_motorMass=1.0/this.m_motorMass
}
};
{
this.m_perp.SetV(Box2D.Common.Math.b2Math.MulMV(xf1.R,this.m_localYAxis1));
this.m_s1=(dX+r1X)*this.m_perp.y-(dY+r1Y)*this.m_perp.x;
this.m_s2=r2X*this.m_perp.y-r2Y*this.m_perp.x;
m1=this.m_invMassA;
m2=this.m_invMassB;
i1=this.m_invIA;
i2=this.m_invIB;
this.m_K.col1.x=m1+m2+i1*this.m_s1*this.m_s1+i2*this.m_s2*this.m_s2;
this.m_K.col1.y=i1*this.m_s1+i2*this.m_s2;
this.m_K.col1.z=i1*this.m_s1*this.m_a1+i2*this.m_s2*this.m_a2;
this.m_K.col2.x=this.m_K.col1.y;
this.m_K.col2.y=i1+i2;
this.m_K.col2.z=i1*this.m_a1+i2*this.m_a2;
this.m_K.col3.x=this.m_K.col1.z;
this.m_K.col3.y=this.m_K.col2.z;
this.m_K.col3.z=m1+m2+i1*this.m_a1*this.m_a1+i2*this.m_a2*this.m_a2
};
if(this.m_enableLimit)
{
jointTransition=this.m_axis.x*dX+this.m_axis.y*dY;
if(Box2D.Common.Math.b2Math.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2.0*Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_equalLimits
}
else if(jointTransition<=this.m_lowerTranslation)
{
if(this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit;
this.m_impulse.z=0.0
}
}
else if(jointTransition>=this.m_upperTranslation)
{
if(this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit;
this.m_impulse.z=0.0
}
}
else
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_impulse.z=0.0
}
}
else
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit
}
if(this.m_enableMotor==false)
{
this.m_motorImpulse=0.0
}
if(step.warmStarting)
{
this.m_impulse.x*=step.dtRatio;
this.m_impulse.y*=step.dtRatio;
this.m_motorImpulse*=step.dtRatio;
PX=this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.x;
PY=this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.y;
L1=this.m_impulse.x*this.m_s1+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a1;
L2=this.m_impulse.x*this.m_s2+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a2;
bA.m_linearVelocity.x-=this.m_invMassA*PX;
bA.m_linearVelocity.y-=this.m_invMassA*PY;
bA.m_angularVelocity-=this.m_invIA*L1;
bB.m_linearVelocity.x+=this.m_invMassB*PX;
bB.m_linearVelocity.y+=this.m_invMassB*PY;
bB.m_angularVelocity+=this.m_invIB*L2
}
else
{
this.m_impulse.SetZero();
this.m_motorImpulse=0.0
}
};
d.SolveVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var v1=null;
var w1=0;
var v2=null;
var w2=0;
var PX=0;
var PY=0;
var L1=0;
var L2=0;
var Cdot=0;
var impulse=0;
var oldImpulse=0;
var maxImpulse=0;
var Cdot1X=0;
var Cdot1Y=0;
var Cdot2=0;
var f1=null;
var df=null;
var bX=0;
var bY=0;
var f2r=null;
var df2=null;
bA=this.m_bodyA;
bB=this.m_bodyB;
v1=bA.m_linearVelocity;
w1=bA.m_angularVelocity;
v2=bB.m_linearVelocity;
w2=bB.m_angularVelocity;
PX;
PY;
L1;
L2;
if(this.m_enableMotor&&this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_equalLimits)
{
Cdot=this.m_axis.x*(v2.x-v1.x)+this.m_axis.y*(v2.y-v1.y)+this.m_a2*w2-this.m_a1*w1;
impulse=this.m_motorMass*(this.m_motorSpeed-Cdot);
oldImpulse=this.m_motorImpulse;
maxImpulse=step.dt*this.m_maxMotorForce;
this.m_motorImpulse=Box2D.Common.Math.b2Math.Clamp(this.m_motorImpulse+impulse,-maxImpulse,maxImpulse);
impulse=this.m_motorImpulse-oldImpulse;
PX=impulse*this.m_axis.x;
PY=impulse*this.m_axis.y;
L1=impulse*this.m_a1;
L2=impulse*this.m_a2;
v1.x-=this.m_invMassA*PX;
v1.y-=this.m_invMassA*PY;
w1-=this.m_invIA*L1;
v2.x+=this.m_invMassB*PX;
v2.y+=this.m_invMassB*PY;
w2+=this.m_invIB*L2
}
Cdot1X=this.m_perp.x*(v2.x-v1.x)+this.m_perp.y*(v2.y-v1.y)+this.m_s2*w2-this.m_s1*w1;
Cdot1Y=w2-w1;
if(this.m_enableLimit&&this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit)
{
Cdot2=this.m_axis.x*(v2.x-v1.x)+this.m_axis.y*(v2.y-v1.y)+this.m_a2*w2-this.m_a1*w1;
f1=this.m_impulse.Copy();
df=this.m_K.Solve33(new Box2D.Common.Math.b2Vec3(),-Cdot1X,-Cdot1Y,-Cdot2);
this.m_impulse.Add(df);
if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)
{
this.m_impulse.z=Box2D.Common.Math.b2Math.Max(this.m_impulse.z,0.0)
}
else if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
this.m_impulse.z=Box2D.Common.Math.b2Math.Min(this.m_impulse.z,0.0)
}
bX=-Cdot1X-(this.m_impulse.z-f1.z)*this.m_K.col3.x;
bY=-Cdot1Y-(this.m_impulse.z-f1.z)*this.m_K.col3.y;
f2r=this.m_K.Solve22(new Box2D.Common.Math.b2Vec2(),bX,bY);
f2r.x+=f1.x;
f2r.y+=f1.y;
this.m_impulse.x=f2r.x;
this.m_impulse.y=f2r.y;
df.x=this.m_impulse.x-f1.x;
df.y=this.m_impulse.y-f1.y;
df.z=this.m_impulse.z-f1.z;
PX=df.x*this.m_perp.x+df.z*this.m_axis.x;
PY=df.x*this.m_perp.y+df.z*this.m_axis.y;
L1=df.x*this.m_s1+df.y+df.z*this.m_a1;
L2=df.x*this.m_s2+df.y+df.z*this.m_a2;
v1.x-=this.m_invMassA*PX;
v1.y-=this.m_invMassA*PY;
w1-=this.m_invIA*L1;
v2.x+=this.m_invMassB*PX;
v2.y+=this.m_invMassB*PY;
w2+=this.m_invIB*L2
}
else
{
df2=this.m_K.Solve22(new Box2D.Common.Math.b2Vec2(),-Cdot1X,-Cdot1Y);
this.m_impulse.x+=df2.x;
this.m_impulse.y+=df2.y;
PX=df2.x*this.m_perp.x;
PY=df2.x*this.m_perp.y;
L1=df2.x*this.m_s1+df2.y;
L2=df2.x*this.m_s2+df2.y;
v1.x-=this.m_invMassA*PX;
v1.y-=this.m_invMassA*PY;
w1-=this.m_invIA*L1;
v2.x+=this.m_invMassB*PX;
v2.y+=this.m_invMassB*PY;
w2+=this.m_invIB*L2
}
bA.m_linearVelocity.SetV(v1);
bA.m_angularVelocity=w1;
bB.m_linearVelocity.SetV(v2);
bB.m_angularVelocity=w2;
};
d.SolvePositionConstraints=function(baumgarte)
{
var limitC=0;
var oldLimitImpulse=0;
var bA=null;
var bB=null;
var c1=null;
var a1=0;
var c2=null;
var a2=0;
var tMat=null;
var tX=0;
var m1=0;
var m2=0;
var i1=0;
var i2=0;
var linearError=0;
var angularError=0;
var active=false;
var C2=0;
var R1=null;
var R2=null;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var dX=0;
var dY=0;
var translation=0;
var impulse=null;
var C1X=0;
var C1Y=0;
var k11=0;
var k12=0;
var k22=0;
var impulse1=null;
var PX=0;
var PY=0;
var L1=0;
var L2=0;
limitC;
oldLimitImpulse;
bA=this.m_bodyA;
bB=this.m_bodyB;
c1=bA.m_sweep.c;
a1=bA.m_sweep.a;
c2=bB.m_sweep.c;
a2=bB.m_sweep.a;
tMat;
tX;
m1;
m2;
i1;
i2;
linearError=0.0;
angularError=0.0;
active=false;
C2=0.0;
R1=Box2D.Common.Math.b2Mat22.FromAngle(a1);
R2=Box2D.Common.Math.b2Mat22.FromAngle(a2);
tMat=R1;
r1X=this.m_localAnchor1.x-this.m_localCenterA.x;
r1Y=this.m_localAnchor1.y-this.m_localCenterA.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=R2;
r2X=this.m_localAnchor2.x-this.m_localCenterB.x;
r2Y=this.m_localAnchor2.y-this.m_localCenterB.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
dX=c2.x+r2X-c1.x-r1X;
dY=c2.y+r2Y-c1.y-r1Y;
if(this.m_enableLimit)
{
this.m_axis=Box2D.Common.Math.b2Math.MulMV(R1,this.m_localXAxis1);
this.m_a1=(dX+r1X)*this.m_axis.y-(dY+r1Y)*this.m_axis.x;
this.m_a2=r2X*this.m_axis.y-r2Y*this.m_axis.x;
translation=this.m_axis.x*dX+this.m_axis.y*dY;
if(Box2D.Common.Math.b2Math.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2.0*Box2D.Common.b2Settings.b2_linearSlop)
{
C2=Box2D.Common.Math.b2Math.Clamp(translation,-Box2D.Common.b2Settings.b2_maxLinearCorrection,Box2D.Common.b2Settings.b2_maxLinearCorrection);
linearError=Box2D.Common.Math.b2Math.Abs(translation);
active=true
}
else if(translation<=this.m_lowerTranslation)
{
C2=Box2D.Common.Math.b2Math.Clamp(translation-this.m_lowerTranslation+Box2D.Common.b2Settings.b2_linearSlop,-Box2D.Common.b2Settings.b2_maxLinearCorrection,0.0);
linearError=this.m_lowerTranslation-translation;
active=true
}
else if(translation>=this.m_upperTranslation)
{
C2=Box2D.Common.Math.b2Math.Clamp(translation-this.m_upperTranslation+Box2D.Common.b2Settings.b2_linearSlop,0.0,Box2D.Common.b2Settings.b2_maxLinearCorrection);
linearError=translation-this.m_upperTranslation;
active=true
}
}
this.m_perp=Box2D.Common.Math.b2Math.MulMV(R1,this.m_localYAxis1);
this.m_s1=(dX+r1X)*this.m_perp.y-(dY+r1Y)*this.m_perp.x;
this.m_s2=r2X*this.m_perp.y-r2Y*this.m_perp.x;
impulse=new Box2D.Common.Math.b2Vec3();
C1X=this.m_perp.x*dX+this.m_perp.y*dY;
C1Y=a2-a1-this.m_refAngle;
linearError=Box2D.Common.Math.b2Math.Max(linearError,Box2D.Common.Math.b2Math.Abs(C1X));
angularError=Box2D.Common.Math.b2Math.Abs(C1Y);
if(active)
{
m1=this.m_invMassA;
m2=this.m_invMassB;
i1=this.m_invIA;
i2=this.m_invIB;
this.m_K.col1.x=m1+m2+i1*this.m_s1*this.m_s1+i2*this.m_s2*this.m_s2;
this.m_K.col1.y=i1*this.m_s1+i2*this.m_s2;
this.m_K.col1.z=i1*this.m_s1*this.m_a1+i2*this.m_s2*this.m_a2;
this.m_K.col2.x=this.m_K.col1.y;
this.m_K.col2.y=i1+i2;
this.m_K.col2.z=i1*this.m_a1+i2*this.m_a2;
this.m_K.col3.x=this.m_K.col1.z;
this.m_K.col3.y=this.m_K.col2.z;
this.m_K.col3.z=m1+m2+i1*this.m_a1*this.m_a1+i2*this.m_a2*this.m_a2;
this.m_K.Solve33(impulse,-C1X,-C1Y,-C2)
}
else
{
m1=this.m_invMassA;
m2=this.m_invMassB;
i1=this.m_invIA;
i2=this.m_invIB;
k11=m1+m2+i1*this.m_s1*this.m_s1+i2*this.m_s2*this.m_s2;
k12=i1*this.m_s1+i2*this.m_s2;
k22=i1+i2;
this.m_K.col1.Set(k11,k12,0.0);
this.m_K.col2.Set(k12,k22,0.0);
impulse1=this.m_K.Solve22(new Box2D.Common.Math.b2Vec2(),-C1X,-C1Y);
impulse.x=impulse1.x;
impulse.y=impulse1.y;
impulse.z=0.0
}
PX=impulse.x*this.m_perp.x+impulse.z*this.m_axis.x;
PY=impulse.x*this.m_perp.y+impulse.z*this.m_axis.y;
L1=impulse.x*this.m_s1+impulse.y+impulse.z*this.m_a1;
L2=impulse.x*this.m_s2+impulse.y+impulse.z*this.m_a2;
c1.x-=this.m_invMassA*PX;
c1.y-=this.m_invMassA*PY;
a1-=this.m_invIA*L1;
c2.x+=this.m_invMassB*PX;
c2.y+=this.m_invMassB*PY;
a2+=this.m_invIB*L2;
bA.m_sweep.a=a1;
bB.m_sweep.a=a2;
bA.SynchronizeTransform();
bB.SynchronizeTransform();
return linearError<=Box2D.Common.b2Settings.b2_linearSlop&&angularError<=Box2D.Common.b2Settings.b2_angularSlop;
};
d.GetJointTranslation=function()
{
var bA=null;
var bB=null;
var tMat=null;
var p1=null;
var p2=null;
var dX=0;
var dY=0;
var axis=null;
var translation=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
p1=bA.GetWorldPoint(this.m_localAnchor1);
p2=bB.GetWorldPoint(this.m_localAnchor2);
dX=p2.x-p1.x;
dY=p2.y-p1.y;
axis=bA.GetWorldVector(this.m_localXAxis1);
translation=axis.x*dX+axis.y*dY;
return translation;
};
d.GetJointSpeed=function()
{
var bA=null;
var bB=null;
var tMat=null;
var r1X=0;
var r1Y=0;
var tX=0;
var r2X=0;
var r2Y=0;
var p1X=0;
var p1Y=0;
var p2X=0;
var p2Y=0;
var dX=0;
var dY=0;
var axis=null;
var v1=null;
var v2=null;
var w1=0;
var w2=0;
var speed=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
p1X=bA.m_sweep.c.x+r1X;
p1Y=bA.m_sweep.c.y+r1Y;
p2X=bB.m_sweep.c.x+r2X;
p2Y=bB.m_sweep.c.y+r2Y;
dX=p2X-p1X;
dY=p2Y-p1Y;
axis=bA.GetWorldVector(this.m_localXAxis1);
v1=bA.m_linearVelocity;
v2=bB.m_linearVelocity;
w1=bA.m_angularVelocity;
w2=bB.m_angularVelocity;
speed=(dX*(-w1*axis.y)+dY*(w1*axis.x))+(axis.x*(((v2.x+(-w2*r2Y))-v1.x)-(-w1*r1Y))+axis.y*(((v2.y+(w2*r2X))-v1.y)-(w1*r1X)));
return speed;
};
d.IsLimitEnabled=function()
{
return this.m_enableLimit;
};
d.EnableLimit=function(flag)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_enableLimit=flag;
};
d.GetLowerLimit=function()
{
return this.m_lowerTranslation;
};
d.GetUpperLimit=function()
{
return this.m_upperTranslation;
};
d.SetLimits=function(lower,upper)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_lowerTranslation=lower;
this.m_upperTranslation=upper;
};
d.IsMotorEnabled=function()
{
return this.m_enableMotor;
};
d.EnableMotor=function(flag)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_enableMotor=flag;
};
d.SetMotorSpeed=function(speed)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_motorSpeed=speed;
};
d.GetMotorSpeed=function()
{
return this.m_motorSpeed;
};
d.SetMaxMotorForce=function(force)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_maxMotorForce=force;
};
d.GetMotorForce=function()
{
return this.m_motorImpulse;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2PrismaticJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Mat33","Box2D.Common.Math.b2Vec3","Box2D.Common.Math.b2Math","Box2D.Common.b2Settings","Box2D.Common.Math.b2Mat22"]);
}
());;
(function()
{
"use strict";
var d={};
d.localAnchorA=null;
d.localAnchorB=null;
d.referenceAngle=0;
d.b2WeldJointDef=function()
{
this.localAnchorA=new Box2D.Common.Math.b2Vec2();
this.localAnchorB=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_weldJoint;
this.referenceAngle=0.0;
};
d.Initialize=function(bA,bB,anchor)
{
this.bodyA=bA;
this.bodyB=bB;
this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle();
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2WeldJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_localAnchor1=null;
d.m_localAnchor2=null;
d.m_u=null;
d.m_frequencyHz=0;
d.m_dampingRatio=0;
d.m_gamma=0;
d.m_bias=0;
d.m_impulse=0;
d.m_mass=0;
d.m_length=0;
d.b2DistanceJoint=function(def)
{
this.m_localAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor2=new Box2D.Common.Math.b2Vec2();
this.m_u=new Box2D.Common.Math.b2Vec2();
var tMat=null;
var tX=0;
var tY=0;
this.b2Joint_constructor(def);
tMat;
tX;
tY;
this.m_localAnchor1.SetV(def.localAnchorA);
this.m_localAnchor2.SetV(def.localAnchorB);
this.m_length=def.length;
this.m_frequencyHz=def.frequencyHz;
this.m_dampingRatio=def.dampingRatio;
this.m_impulse=0.0;
this.m_gamma=0.0;
this.m_bias=0.0;
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*this.m_impulse*this.m_u.x,inv_dt*this.m_impulse*this.m_u.y);
};
d.GetReactionTorque=function(inv_dt)
{
return 0.0;
};
d.InitVelocityConstraints=function(step)
{
var tMat=null;
var tX=0;
var bA=null;
var bB=null;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var length=0;
var cr1u=0;
var cr2u=0;
var invMass=0;
var C=0;
var omega=0;
var d=0;
var k=0;
var PX=0;
var PY=0;
tMat;
tX;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
this.m_u.x=bB.m_sweep.c.x+r2X-bA.m_sweep.c.x-r1X;
this.m_u.y=bB.m_sweep.c.y+r2Y-bA.m_sweep.c.y-r1Y;
length=Math.sqrt(this.m_u.x*this.m_u.x+this.m_u.y*this.m_u.y);
if(length>Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_u.Multiply(1.0/length)
}
else
{
this.m_u.SetZero()
}
cr1u=(r1X*this.m_u.y-r1Y*this.m_u.x);
cr2u=(r2X*this.m_u.y-r2Y*this.m_u.x);
invMass=bA.m_invMass+bA.m_invI*cr1u*cr1u+bB.m_invMass+bB.m_invI*cr2u*cr2u;
this.m_mass=invMass!=0.0?1.0/invMass:0.0;
if(this.m_frequencyHz>0.0)
{
C=length-this.m_length;
omega=2.0*Math.PI*this.m_frequencyHz;
d=2.0*this.m_mass*this.m_dampingRatio*omega;
k=this.m_mass*omega*omega;
this.m_gamma=step.dt*(d+step.dt*k);
this.m_gamma=this.m_gamma!=0.0?1/this.m_gamma:0.0;
this.m_bias=C*step.dt*k*this.m_gamma;
this.m_mass=invMass+this.m_gamma;
this.m_mass=this.m_mass!=0.0?1.0/this.m_mass:0.0
}
if(step.warmStarting)
{
this.m_impulse*=step.dtRatio;
PX=this.m_impulse*this.m_u.x;
PY=this.m_impulse*this.m_u.y;
bA.m_linearVelocity.x-=bA.m_invMass*PX;
bA.m_linearVelocity.y-=bA.m_invMass*PY;
bA.m_angularVelocity-=bA.m_invI*(r1X*PY-r1Y*PX);
bB.m_linearVelocity.x+=bB.m_invMass*PX;
bB.m_linearVelocity.y+=bB.m_invMass*PY;
bB.m_angularVelocity+=bB.m_invI*(r2X*PY-r2Y*PX)
}
else
{
this.m_impulse=0.0
}
};
d.SolveVelocityConstraints=function(step)
{
var tMat=null;
var bA=null;
var bB=null;
var r1X=0;
var r1Y=0;
var tX=0;
var r2X=0;
var r2Y=0;
var v1X=0;
var v1Y=0;
var v2X=0;
var v2Y=0;
var Cdot=0;
var impulse=0;
var PX=0;
var PY=0;
tMat;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
v1X=bA.m_linearVelocity.x+(-bA.m_angularVelocity*r1Y);
v1Y=bA.m_linearVelocity.y+(bA.m_angularVelocity*r1X);
v2X=bB.m_linearVelocity.x+(-bB.m_angularVelocity*r2Y);
v2Y=bB.m_linearVelocity.y+(bB.m_angularVelocity*r2X);
Cdot=(this.m_u.x*(v2X-v1X)+this.m_u.y*(v2Y-v1Y));
impulse=-this.m_mass*(Cdot+this.m_bias+this.m_gamma*this.m_impulse);
this.m_impulse+=impulse;
PX=impulse*this.m_u.x;
PY=impulse*this.m_u.y;
bA.m_linearVelocity.x-=bA.m_invMass*PX;
bA.m_linearVelocity.y-=bA.m_invMass*PY;
bA.m_angularVelocity-=bA.m_invI*(r1X*PY-r1Y*PX);
bB.m_linearVelocity.x+=bB.m_invMass*PX;
bB.m_linearVelocity.y+=bB.m_invMass*PY;
bB.m_angularVelocity+=bB.m_invI*(r2X*PY-r2Y*PX);
};
d.SolvePositionConstraints=function(baumgarte)
{
var tMat=null;
var bA=null;
var bB=null;
var r1X=0;
var r1Y=0;
var tX=0;
var r2X=0;
var r2Y=0;
var dX=0;
var dY=0;
var length=0;
var C=0;
var impulse=0;
var PX=0;
var PY=0;
tMat;
if(this.m_frequencyHz>0.0)
{
return true
}
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
dX=bB.m_sweep.c.x+r2X-bA.m_sweep.c.x-r1X;
dY=bB.m_sweep.c.y+r2Y-bA.m_sweep.c.y-r1Y;
length=Math.sqrt(dX*dX+dY*dY);
dX/=length;
dY/=length;
C=length-this.m_length;
C=Box2D.Common.Math.b2Math.Clamp(C,-Box2D.Common.b2Settings.b2_maxLinearCorrection,Box2D.Common.b2Settings.b2_maxLinearCorrection);
impulse=-this.m_mass*C;
this.m_u.Set(dX,dY);
PX=impulse*this.m_u.x;
PY=impulse*this.m_u.y;
bA.m_sweep.c.x-=bA.m_invMass*PX;
bA.m_sweep.c.y-=bA.m_invMass*PY;
bA.m_sweep.a-=bA.m_invI*(r1X*PY-r1Y*PX);
bB.m_sweep.c.x+=bB.m_invMass*PX;
bB.m_sweep.c.y+=bB.m_invMass*PY;
bB.m_sweep.a+=bB.m_invI*(r2X*PY-r2Y*PX);
bA.SynchronizeTransform();
bB.SynchronizeTransform();
return Box2D.Common.Math.b2Math.Abs(C)<Box2D.Common.b2Settings.b2_linearSlop;
};
d.GetLength=function()
{
return this.m_length;
};
d.SetLength=function(length)
{
this.m_length=length;
};
d.GetFrequency=function()
{
return this.m_frequencyHz;
};
d.SetFrequency=function(hz)
{
this.m_frequencyHz=hz;
};
d.GetDampingRatio=function()
{
return this.m_dampingRatio;
};
d.SetDampingRatio=function(ratio)
{
this.m_dampingRatio=ratio;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2DistanceJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_localAnchor1=null;
d.m_localAnchor2=null;
d.K=null;
d.K1=null;
d.K2=null;
d.K3=null;
d.impulse3=null;
d.impulse2=null;
d.reduced=null;
d.m_impulse=null;
d.m_motorImpulse=0;
d.m_mass=null;
d.m_motorMass=0;
d.m_enableMotor=false;
d.m_maxMotorTorque=0;
d.m_motorSpeed=0;
d.m_enableLimit=false;
d.m_referenceAngle=0;
d.m_lowerAngle=0;
d.m_upperAngle=0;
d.m_limitState=0;
d.b2RevoluteJoint=function(def)
{
this.m_localAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor2=new Box2D.Common.Math.b2Vec2();
this.K=new Box2D.Common.Math.b2Mat22();
this.K1=new Box2D.Common.Math.b2Mat22();
this.K2=new Box2D.Common.Math.b2Mat22();
this.K3=new Box2D.Common.Math.b2Mat22();
this.impulse3=new Box2D.Common.Math.b2Vec3();
this.impulse2=new Box2D.Common.Math.b2Vec2();
this.reduced=new Box2D.Common.Math.b2Vec2();
this.m_impulse=new Box2D.Common.Math.b2Vec3();
this.m_mass=new Box2D.Common.Math.b2Mat33();
this.b2Joint_constructor(def);
this.m_localAnchor1.SetV(def.localAnchorA);
this.m_localAnchor2.SetV(def.localAnchorB);
this.m_referenceAngle=def.referenceAngle;
this.m_impulse.SetZero();
this.m_motorImpulse=0.0;
this.m_lowerAngle=def.lowerAngle;
this.m_upperAngle=def.upperAngle;
this.m_maxMotorTorque=def.maxMotorTorque;
this.m_motorSpeed=def.motorSpeed;
this.m_enableLimit=def.enableLimit;
this.m_enableMotor=def.enableMotor;
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*this.m_impulse.x,inv_dt*this.m_impulse.y);
};
d.GetReactionTorque=function(inv_dt)
{
return inv_dt*this.m_impulse.z;
};
d.InitVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var tMat=null;
var tX=0;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var m1=0;
var m2=0;
var i1=0;
var i2=0;
var jointAngle=0;
var PX=0;
var PY=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tX;
if(this.m_enableMotor||this.m_enableLimit)
{
}
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
m1=bA.m_invMass;
m2=bB.m_invMass;
i1=bA.m_invI;
i2=bB.m_invI;
this.m_mass.col1.x=m1+m2+r1Y*r1Y*i1+r2Y*r2Y*i2;
this.m_mass.col2.x=-r1Y*r1X*i1-r2Y*r2X*i2;
this.m_mass.col3.x=-r1Y*i1-r2Y*i2;
this.m_mass.col1.y=this.m_mass.col2.x;
this.m_mass.col2.y=m1+m2+r1X*r1X*i1+r2X*r2X*i2;
this.m_mass.col3.y=r1X*i1+r2X*i2;
this.m_mass.col1.z=this.m_mass.col3.x;
this.m_mass.col2.z=this.m_mass.col3.y;
this.m_mass.col3.z=i1+i2;
this.m_motorMass=1.0/(i1+i2);
if(this.m_enableMotor==false)
{
this.m_motorImpulse=0.0
}
if(this.m_enableLimit)
{
jointAngle=bB.m_sweep.a-bA.m_sweep.a-this.m_referenceAngle;
if(Box2D.Common.Math.b2Math.Abs(this.m_upperAngle-this.m_lowerAngle)<2.0*Box2D.Common.b2Settings.b2_angularSlop)
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_equalLimits
}
else if(jointAngle<=this.m_lowerAngle)
{
if(this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)
{
this.m_impulse.z=0.0
}
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit
}
else if(jointAngle>=this.m_upperAngle)
{
if(this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
this.m_impulse.z=0.0
}
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit
}
else
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_impulse.z=0.0
}
}
else
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit
}
if(step.warmStarting)
{
this.m_impulse.x*=step.dtRatio;
this.m_impulse.y*=step.dtRatio;
this.m_motorImpulse*=step.dtRatio;
PX=this.m_impulse.x;
PY=this.m_impulse.y;
bA.m_linearVelocity.x-=m1*PX;
bA.m_linearVelocity.y-=m1*PY;
bA.m_angularVelocity-=i1*((r1X*PY-r1Y*PX)+this.m_motorImpulse+this.m_impulse.z);
bB.m_linearVelocity.x+=m2*PX;
bB.m_linearVelocity.y+=m2*PY;
bB.m_angularVelocity+=i2*((r2X*PY-r2Y*PX)+this.m_motorImpulse+this.m_impulse.z)
}
else
{
this.m_impulse.SetZero();
this.m_motorImpulse=0.0
}
};
d.SolveVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var tMat=null;
var tX=0;
var newImpulse=0;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var v1=null;
var w1=0;
var v2=null;
var w2=0;
var m1=0;
var m2=0;
var i1=0;
var i2=0;
var Cdot=0;
var impulse=0;
var oldImpulse=0;
var maxImpulse=0;
var Cdot1X=0;
var Cdot1Y=0;
var Cdot2=0;
var CdotX=0;
var CdotY=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tX;
newImpulse;
r1X;
r1Y;
r2X;
r2Y;
v1=bA.m_linearVelocity;
w1=bA.m_angularVelocity;
v2=bB.m_linearVelocity;
w2=bB.m_angularVelocity;
m1=bA.m_invMass;
m2=bB.m_invMass;
i1=bA.m_invI;
i2=bB.m_invI;
if(this.m_enableMotor&&this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_equalLimits)
{
Cdot=w2-w1-this.m_motorSpeed;
impulse=this.m_motorMass*(-Cdot);
oldImpulse=this.m_motorImpulse;
maxImpulse=step.dt*this.m_maxMotorTorque;
this.m_motorImpulse=Box2D.Common.Math.b2Math.Clamp(this.m_motorImpulse+impulse,-maxImpulse,maxImpulse);
impulse=this.m_motorImpulse-oldImpulse;
w1-=i1*impulse;
w2+=i2*impulse
}
if(this.m_enableLimit&&this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit)
{
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
Cdot1X=v2.x+(-w2*r2Y)-v1.x-(-w1*r1Y);
Cdot1Y=v2.y+(w2*r2X)-v1.y-(w1*r1X);
Cdot2=w2-w1;
this.m_mass.Solve33(this.impulse3,-Cdot1X,-Cdot1Y,-Cdot2);
if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_equalLimits)
{
this.m_impulse.Add(this.impulse3)
}
else if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)
{
newImpulse=this.m_impulse.z+this.impulse3.z;
if(newImpulse<0.0)
{
this.m_mass.Solve22(this.reduced,-Cdot1X,-Cdot1Y);
this.impulse3.x=this.reduced.x;
this.impulse3.y=this.reduced.y;
this.impulse3.z=-this.m_impulse.z;
this.m_impulse.x+=this.reduced.x;
this.m_impulse.y+=this.reduced.y;
this.m_impulse.z=0.0
}
}
else if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
newImpulse=this.m_impulse.z+this.impulse3.z;
if(newImpulse>0.0)
{
this.m_mass.Solve22(this.reduced,-Cdot1X,-Cdot1Y);
this.impulse3.x=this.reduced.x;
this.impulse3.y=this.reduced.y;
this.impulse3.z=-this.m_impulse.z;
this.m_impulse.x+=this.reduced.x;
this.m_impulse.y+=this.reduced.y;
this.m_impulse.z=0.0
}
}
v1.x-=m1*this.impulse3.x;
v1.y-=m1*this.impulse3.y;
w1-=i1*(r1X*this.impulse3.y-r1Y*this.impulse3.x+this.impulse3.z);
v2.x+=m2*this.impulse3.x;
v2.y+=m2*this.impulse3.y;
w2+=i2*(r2X*this.impulse3.y-r2Y*this.impulse3.x+this.impulse3.z)
}
else
{
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
CdotX=v2.x+(-w2*r2Y)-v1.x-(-w1*r1Y);
CdotY=v2.y+(w2*r2X)-v1.y-(w1*r1X);
this.m_mass.Solve22(this.impulse2,-CdotX,-CdotY);
this.m_impulse.x+=this.impulse2.x;
this.m_impulse.y+=this.impulse2.y;
v1.x-=m1*this.impulse2.x;
v1.y-=m1*this.impulse2.y;
w1-=i1*(r1X*this.impulse2.y-r1Y*this.impulse2.x);
v2.x+=m2*this.impulse2.x;
v2.y+=m2*this.impulse2.y;
w2+=i2*(r2X*this.impulse2.y-r2Y*this.impulse2.x)
}
bA.m_linearVelocity.SetV(v1);
bA.m_angularVelocity=w1;
bB.m_linearVelocity.SetV(v2);
bB.m_angularVelocity=w2;
};
d.SolvePositionConstraints=function(baumgarte)
{
var oldLimitImpulse=0;
var C=0;
var tMat=null;
var bA=null;
var bB=null;
var angularError=0;
var positionError=0;
var tX=0;
var impulseX=0;
var impulseY=0;
var angle=0;
var limitImpulse=0;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var CX=0;
var CY=0;
var CLengthSquared=0;
var CLength=0;
var invMass1=0;
var invMass2=0;
var invI1=0;
var invI2=0;
var k_allowedStretch=0;
var uX=0;
var uY=0;
var k=0;
var m=0;
var k_beta=0;
oldLimitImpulse;
C;
tMat;
bA=this.m_bodyA;
bB=this.m_bodyB;
angularError=0.0;
positionError=0.0;
tX;
impulseX;
impulseY;
if(this.m_enableLimit&&this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit)
{
angle=bB.m_sweep.a-bA.m_sweep.a-this.m_referenceAngle;
limitImpulse=0.0;
if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_equalLimits)
{
C=Box2D.Common.Math.b2Math.Clamp(angle-this.m_lowerAngle,-Box2D.Common.b2Settings.b2_maxAngularCorrection,Box2D.Common.b2Settings.b2_maxAngularCorrection);
limitImpulse=-this.m_motorMass*C;
angularError=Box2D.Common.Math.b2Math.Abs(C)
}
else if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)
{
C=angle-this.m_lowerAngle;
angularError=-C;
C=Box2D.Common.Math.b2Math.Clamp(C+Box2D.Common.b2Settings.b2_angularSlop,-Box2D.Common.b2Settings.b2_maxAngularCorrection,0.0);
limitImpulse=-this.m_motorMass*C
}
else if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
C=angle-this.m_upperAngle;
angularError=C;
C=Box2D.Common.Math.b2Math.Clamp(C-Box2D.Common.b2Settings.b2_angularSlop,0.0,Box2D.Common.b2Settings.b2_maxAngularCorrection);
limitImpulse=-this.m_motorMass*C
}
bA.m_sweep.a-=bA.m_invI*limitImpulse;
bB.m_sweep.a+=bB.m_invI*limitImpulse;
bA.SynchronizeTransform();
bB.SynchronizeTransform()
}
{
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
CX=bB.m_sweep.c.x+r2X-bA.m_sweep.c.x-r1X;
CY=bB.m_sweep.c.y+r2Y-bA.m_sweep.c.y-r1Y;
CLengthSquared=CX*CX+CY*CY;
CLength=Math.sqrt(CLengthSquared);
positionError=CLength;
invMass1=bA.m_invMass;
invMass2=bB.m_invMass;
invI1=bA.m_invI;
invI2=bB.m_invI;
k_allowedStretch=10.0*Box2D.Common.b2Settings.b2_linearSlop;
if(CLengthSquared>k_allowedStretch*k_allowedStretch)
{
uX=CX/CLength;
uY=CY/CLength;
k=invMass1+invMass2;
m=1.0/k;
impulseX=m*(-CX);
impulseY=m*(-CY);
k_beta=0.5;
bA.m_sweep.c.x-=k_beta*invMass1*impulseX;
bA.m_sweep.c.y-=k_beta*invMass1*impulseY;
bB.m_sweep.c.x+=k_beta*invMass2*impulseX;
bB.m_sweep.c.y+=k_beta*invMass2*impulseY;
CX=bB.m_sweep.c.x+r2X-bA.m_sweep.c.x-r1X;
CY=bB.m_sweep.c.y+r2Y-bA.m_sweep.c.y-r1Y
}
this.K1.col1.x=invMass1+invMass2;
this.K1.col2.x=0.0;
this.K1.col1.y=0.0;
this.K1.col2.y=invMass1+invMass2;
this.K2.col1.x=invI1*r1Y*r1Y;
this.K2.col2.x=-invI1*r1X*r1Y;
this.K2.col1.y=-invI1*r1X*r1Y;
this.K2.col2.y=invI1*r1X*r1X;
this.K3.col1.x=invI2*r2Y*r2Y;
this.K3.col2.x=-invI2*r2X*r2Y;
this.K3.col1.y=-invI2*r2X*r2Y;
this.K3.col2.y=invI2*r2X*r2X;
this.K.SetM(this.K1);
this.K.AddM(this.K2);
this.K.AddM(this.K3);
this.K.Solve(Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse,-CX,-CY);
impulseX=Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse.x;
impulseY=Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse.y;
bA.m_sweep.c.x-=bA.m_invMass*impulseX;
bA.m_sweep.c.y-=bA.m_invMass*impulseY;
bA.m_sweep.a-=bA.m_invI*(r1X*impulseY-r1Y*impulseX);
bB.m_sweep.c.x+=bB.m_invMass*impulseX;
bB.m_sweep.c.y+=bB.m_invMass*impulseY;
bB.m_sweep.a+=bB.m_invI*(r2X*impulseY-r2Y*impulseX);
bA.SynchronizeTransform();
bB.SynchronizeTransform()
};
return positionError<=Box2D.Common.b2Settings.b2_linearSlop&&angularError<=Box2D.Common.b2Settings.b2_angularSlop;
};
d.GetJointAngle=function()
{
return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle;
};
d.GetJointSpeed=function()
{
return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity;
};
d.IsLimitEnabled=function()
{
return this.m_enableLimit;
};
d.EnableLimit=function(flag)
{
this.m_enableLimit=flag;
};
d.GetLowerLimit=function()
{
return this.m_lowerAngle;
};
d.GetUpperLimit=function()
{
return this.m_upperAngle;
};
d.SetLimits=function(lower,upper)
{
this.m_lowerAngle=lower;
this.m_upperAngle=upper;
};
d.IsMotorEnabled=function()
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
return this.m_enableMotor;
};
d.EnableMotor=function(flag)
{
this.m_enableMotor=flag;
};
d.SetMotorSpeed=function(speed)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_motorSpeed=speed;
};
d.GetMotorSpeed=function()
{
return this.m_motorSpeed;
};
d.SetMaxMotorTorque=function(torque)
{
this.m_maxMotorTorque=torque;
};
d.GetMotorTorque=function()
{
return this.m_maxMotorTorque;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
this.tImpulse=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Dynamics.Joints.b2RevoluteJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Mat22","Box2D.Common.Math.b2Vec3","Box2D.Common.Math.b2Mat33","Box2D.Common.Math.b2Math","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_linearMass=null;
d.m_angularMass=0;
d.m_localAnchorA=null;
d.m_localAnchorB=null;
d.m_linearImpulse=null;
d.m_angularImpulse=0;
d.m_maxForce=0;
d.m_maxTorque=0;
d.b2FrictionJoint=function(def)
{
this.m_linearMass=new Box2D.Common.Math.b2Mat22();
this.m_localAnchorA=new Box2D.Common.Math.b2Vec2();
this.m_localAnchorB=new Box2D.Common.Math.b2Vec2();
this.m_linearImpulse=new Box2D.Common.Math.b2Vec2();
this.b2Joint_constructor(def);
this.m_localAnchorA.SetV(def.localAnchorA);
this.m_localAnchorB.SetV(def.localAnchorB);
this.m_linearMass.SetZero();
this.m_angularMass=0.0;
this.m_linearImpulse.SetZero();
this.m_angularImpulse=0.0;
this.m_maxForce=def.maxForce;
this.m_maxTorque=def.maxTorque;
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*this.m_linearImpulse.x,inv_dt*this.m_linearImpulse.y);
};
d.GetReactionTorque=function(inv_dt)
{
return inv_dt*this.m_angularImpulse;
};
d.InitVelocityConstraints=function(step)
{
var tMat=null;
var tX=0;
var bA=null;
var bB=null;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var mA=0;
var mB=0;
var iA=0;
var iB=0;
var K=null;
var P=null;
tMat;
tX;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat=bA.m_xf.R;
rAX=this.m_localAnchorA.x-bA.m_sweep.localCenter.x;
rAY=this.m_localAnchorA.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*rAX+tMat.col2.x*rAY);
rAY=(tMat.col1.y*rAX+tMat.col2.y*rAY);
rAX=tX;
tMat=bB.m_xf.R;
rBX=this.m_localAnchorB.x-bB.m_sweep.localCenter.x;
rBY=this.m_localAnchorB.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*rBX+tMat.col2.x*rBY);
rBY=(tMat.col1.y*rBX+tMat.col2.y*rBY);
rBX=tX;
mA=bA.m_invMass;
mB=bB.m_invMass;
iA=bA.m_invI;
iB=bB.m_invI;
K=new Box2D.Common.Math.b2Mat22();
K.col1.x=mA+mB;
K.col2.x=0.0;
K.col1.y=0.0;
K.col2.y=mA+mB;
K.col1.x+=iA*rAY*rAY;
K.col2.x+=-iA*rAX*rAY;
K.col1.y+=-iA*rAX*rAY;
K.col2.y+=iA*rAX*rAX;
K.col1.x+=iB*rBY*rBY;
K.col2.x+=-iB*rBX*rBY;
K.col1.y+=-iB*rBX*rBY;
K.col2.y+=iB*rBX*rBX;
K.GetInverse(this.m_linearMass);
this.m_angularMass=iA+iB;
if(this.m_angularMass>0.0)
{
this.m_angularMass=1.0/this.m_angularMass
}
if(step.warmStarting)
{
this.m_linearImpulse.x*=step.dtRatio;
this.m_linearImpulse.y*=step.dtRatio;
this.m_angularImpulse*=step.dtRatio;
P=this.m_linearImpulse;
bA.m_linearVelocity.x-=mA*P.x;
bA.m_linearVelocity.y-=mA*P.y;
bA.m_angularVelocity-=iA*(rAX*P.y-rAY*P.x+this.m_angularImpulse);
bB.m_linearVelocity.x+=mB*P.x;
bB.m_linearVelocity.y+=mB*P.y;
bB.m_angularVelocity+=iB*(rBX*P.y-rBY*P.x+this.m_angularImpulse)
}
else
{
this.m_linearImpulse.SetZero();
this.m_angularImpulse=0.0
}
};
d.SolveVelocityConstraints=function(step)
{
var tMat=null;
var tX=0;
var bA=null;
var bB=null;
var vA=null;
var wA=0;
var vB=null;
var wB=0;
var mA=0;
var mB=0;
var iA=0;
var iB=0;
var rAX=0;
var rAY=0;
var rBX=0;
var rBY=0;
var maxImpulse=0;
var Cdot=0;
var impulse=0;
var oldImpulse=0;
var CdotX=0;
var CdotY=0;
var impulseV=null;
var oldImpulseV=null;
tMat;
tX;
bA=this.m_bodyA;
bB=this.m_bodyB;
vA=bA.m_linearVelocity;
wA=bA.m_angularVelocity;
vB=bB.m_linearVelocity;
wB=bB.m_angularVelocity;
mA=bA.m_invMass;
mB=bB.m_invMass;
iA=bA.m_invI;
iB=bB.m_invI;
tMat=bA.m_xf.R;
rAX=this.m_localAnchorA.x-bA.m_sweep.localCenter.x;
rAY=this.m_localAnchorA.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*rAX+tMat.col2.x*rAY);
rAY=(tMat.col1.y*rAX+tMat.col2.y*rAY);
rAX=tX;
tMat=bB.m_xf.R;
rBX=this.m_localAnchorB.x-bB.m_sweep.localCenter.x;
rBY=this.m_localAnchorB.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*rBX+tMat.col2.x*rBY);
rBY=(tMat.col1.y*rBX+tMat.col2.y*rBY);
rBX=tX;
maxImpulse;
{
Cdot=wB-wA;
impulse=-this.m_angularMass*Cdot;
oldImpulse=this.m_angularImpulse;
maxImpulse=step.dt*this.m_maxTorque;
this.m_angularImpulse=Box2D.Common.Math.b2Math.Clamp(this.m_angularImpulse+impulse,-maxImpulse,maxImpulse);
impulse=this.m_angularImpulse-oldImpulse;
wA-=iA*impulse;
wB+=iB*impulse
};
{
CdotX=vB.x-wB*rBY-vA.x+wA*rAY;
CdotY=vB.y+wB*rBX-vA.y-wA*rAX;
impulseV=Box2D.Common.Math.b2Math.MulMV(this.m_linearMass,new Box2D.Common.Math.b2Vec2(-CdotX,-CdotY));
oldImpulseV=this.m_linearImpulse.Copy();
this.m_linearImpulse.Add(impulseV);
maxImpulse=step.dt*this.m_maxForce;
if(this.m_linearImpulse.LengthSquared()>maxImpulse*maxImpulse)
{
this.m_linearImpulse.Normalize();
this.m_linearImpulse.Multiply(maxImpulse)
}
impulseV=Box2D.Common.Math.b2Math.SubtractVV(this.m_linearImpulse,oldImpulseV);
vA.x-=mA*impulseV.x;
vA.y-=mA*impulseV.y;
wA-=iA*(rAX*impulseV.y-rAY*impulseV.x);
vB.x+=mB*impulseV.x;
vB.y+=mB*impulseV.y;
wB+=iB*(rBX*impulseV.y-rBY*impulseV.x)
};
bA.m_angularVelocity=wA;
bB.m_angularVelocity=wB;
};
d.SolvePositionConstraints=function(baumgarte)
{
return true;
};
d.SetMaxForce=function(force)
{
this.m_maxForce=force;
};
d.GetMaxForce=function()
{
return this.m_maxForce;
};
d.SetMaxTorque=function(torque)
{
this.m_maxTorque=torque;
};
d.GetMaxTorque=function()
{
return this.m_maxTorque;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2FrictionJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Mat22","Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.other=null;
d.joint=null;
d.prev=null;
d.next=null;
d.b2JointEdge=function()
{
};
flash.addDescription("Box2D.Dynamics.Joints.b2JointEdge",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.m_type=0;
d.m_prev=null;
d.m_next=null;
d.m_edgeA=null;
d.m_edgeB=null;
d.m_bodyA=null;
d.m_bodyB=null;
d.m_islandFlag=false;
d.m_collideConnected=false;
d.m_localCenterA=null;
d.m_localCenterB=null;
d.m_invMassA=0;
d.m_invMassB=0;
d.m_invIA=0;
d.m_invIB=0;
d.m_userData=null;
d.b2Joint=function(def)
{
this.m_edgeA=new Box2D.Dynamics.Joints.b2JointEdge();
this.m_edgeB=new Box2D.Dynamics.Joints.b2JointEdge();
this.m_localCenterA=new Box2D.Common.Math.b2Vec2();
this.m_localCenterB=new Box2D.Common.Math.b2Vec2();
Box2D.Common.b2Settings.b2Assert(def.bodyA!=def.bodyB);
this.m_type=def.type;
this.m_prev=null;
this.m_next=null;
this.m_bodyA=def.bodyA;
this.m_bodyB=def.bodyB;
this.m_collideConnected=def.collideConnected;
this.m_islandFlag=false;
this.m_userData=def.userData;
};
d.GetType=function()
{
return this.m_type;
};
d.GetAnchorA=function()
{
return null;
};
d.GetAnchorB=function()
{
return null;
};
d.GetReactionForce=function(inv_dt)
{
return null;
};
d.GetReactionTorque=function(inv_dt)
{
return 0.0;
};
d.GetBodyA=function()
{
return this.m_bodyA;
};
d.GetBodyB=function()
{
return this.m_bodyB;
};
d.GetNext=function()
{
return this.m_next;
};
d.GetUserData=function()
{
return this.m_userData;
};
d.SetUserData=function(data)
{
this.m_userData=data;
};
d.IsActive=function()
{
return this.m_bodyA.IsActive()&&this.m_bodyB.IsActive();
};
d.InitVelocityConstraints=function(step)
{
};
d.SolveVelocityConstraints=function(step)
{
};
d.FinalizeVelocityConstraints=function()
{
};
d.SolvePositionConstraints=function(baumgarte)
{
return false;
};
var s={};
s.__init__=function()
{
this.e_unknownJoint=0;
this.e_revoluteJoint=1;
this.e_prismaticJoint=2;
this.e_distanceJoint=3;
this.e_pulleyJoint=4;
this.e_mouseJoint=5;
this.e_gearJoint=6;
this.e_lineJoint=7;
this.e_weldJoint=8;
this.e_frictionJoint=9;
this.e_inactiveLimit=0;
this.e_atLowerLimit=1;
this.e_atUpperLimit=2;
this.e_equalLimits=3;
};
s.Create=function(def,allocator)
{
var joint=null;
joint=null;
switch(def.type)
{
case Box2D.Dynamics.Joints.b2Joint.e_distanceJoint:
{
joint=new Box2D.Dynamics.Joints.b2DistanceJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_mouseJoint:
{
joint=new Box2D.Dynamics.Joints.b2MouseJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint:
{
joint=new Box2D.Dynamics.Joints.b2PrismaticJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint:
{
joint=new Box2D.Dynamics.Joints.b2RevoluteJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint:
{
joint=new Box2D.Dynamics.Joints.b2PulleyJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_gearJoint:
{
joint=new Box2D.Dynamics.Joints.b2GearJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_lineJoint:
{
joint=new Box2D.Dynamics.Joints.b2LineJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_weldJoint:
{
joint=new Box2D.Dynamics.Joints.b2WeldJoint(def)
};
break;
;case Box2D.Dynamics.Joints.b2Joint.e_frictionJoint:
{
joint=new Box2D.Dynamics.Joints.b2FrictionJoint(def)
};
break;
;default:
break;
;
}
return joint;
};
s.Destroy=function(joint,allocator)
{
};
flash.addDescription("Box2D.Dynamics.Joints.b2Joint",d,null,s,null,["Box2D.Dynamics.Joints.b2JointEdge","Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2DistanceJoint","Box2D.Dynamics.Joints.b2DistanceJointDef","Box2D.Dynamics.Joints.b2MouseJoint","Box2D.Dynamics.Joints.b2MouseJointDef","Box2D.Dynamics.Joints.b2PrismaticJoint","Box2D.Dynamics.Joints.b2PrismaticJointDef","Box2D.Dynamics.Joints.b2RevoluteJoint","Box2D.Dynamics.Joints.b2RevoluteJointDef","Box2D.Dynamics.Joints.b2PulleyJoint","Box2D.Dynamics.Joints.b2PulleyJointDef","Box2D.Dynamics.Joints.b2GearJoint","Box2D.Dynamics.Joints.b2GearJointDef","Box2D.Dynamics.Joints.b2LineJoint","Box2D.Dynamics.Joints.b2LineJointDef","Box2D.Dynamics.Joints.b2WeldJoint","Box2D.Dynamics.Joints.b2WeldJointDef","Box2D.Dynamics.Joints.b2FrictionJoint","Box2D.Dynamics.Joints.b2FrictionJointDef","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_ground1=null;
d.m_ground2=null;
d.m_revolute1=null;
d.m_prismatic1=null;
d.m_revolute2=null;
d.m_prismatic2=null;
d.m_groundAnchor1=null;
d.m_groundAnchor2=null;
d.m_localAnchor1=null;
d.m_localAnchor2=null;
d.m_J=null;
d.m_constant=0;
d.m_ratio=0;
d.m_mass=0;
d.m_impulse=0;
d.b2GearJoint=function(def)
{
this.m_groundAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_groundAnchor2=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor2=new Box2D.Common.Math.b2Vec2();
this.m_J=new Box2D.Dynamics.Joints.b2Jacobian();
var type1=0;
var type2=0;
var coordinate1=0;
var coordinate2=0;
this.b2Joint_constructor(def);
type1=def.joint1.m_type;
type2=def.joint2.m_type;
this.m_revolute1=null;
this.m_prismatic1=null;
this.m_revolute2=null;
this.m_prismatic2=null;
coordinate1;
coordinate2;
this.m_ground1=def.joint1.GetBodyA();
this.m_bodyA=def.joint1.GetBodyB();
if(type1==Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint)
{
this.m_revolute1=def.joint1;
this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
coordinate1=this.m_revolute1.GetJointAngle()
}
else
{
this.m_prismatic1=def.joint1;
this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
coordinate1=this.m_prismatic1.GetJointTranslation()
}
this.m_ground2=def.joint2.GetBodyA();
this.m_bodyB=def.joint2.GetBodyB();
if(type2==Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint)
{
this.m_revolute2=def.joint2;
this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
coordinate2=this.m_revolute2.GetJointAngle()
}
else
{
this.m_prismatic2=def.joint2;
this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
coordinate2=this.m_prismatic2.GetJointTranslation()
}
this.m_ratio=def.ratio;
this.m_constant=coordinate1+this.m_ratio*coordinate2;
this.m_impulse=0.0;
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*this.m_impulse*this.m_J.linearB.x,inv_dt*this.m_impulse*this.m_J.linearB.y);
};
d.GetReactionTorque=function(inv_dt)
{
var tMat=null;
var rX=0;
var rY=0;
var tX=0;
var PX=0;
var PY=0;
tMat=this.m_bodyB.m_xf.R;
rX=this.m_localAnchor1.x-this.m_bodyB.m_sweep.localCenter.x;
rY=this.m_localAnchor1.y-this.m_bodyB.m_sweep.localCenter.y;
tX=tMat.col1.x*rX+tMat.col2.x*rY;
rY=tMat.col1.y*rX+tMat.col2.y*rY;
rX=tX;
PX=this.m_impulse*this.m_J.linearB.x;
PY=this.m_impulse*this.m_J.linearB.y;
return inv_dt*(this.m_impulse*this.m_J.angularB-rX*PY+rY*PX);
};
d.InitVelocityConstraints=function(step)
{
var g1=null;
var g2=null;
var bA=null;
var bB=null;
var ugX=0;
var ugY=0;
var rX=0;
var rY=0;
var tMat=null;
var tVec=null;
var crug=0;
var tX=0;
var K=0;
g1=this.m_ground1;
g2=this.m_ground2;
bA=this.m_bodyA;
bB=this.m_bodyB;
ugX;
ugY;
rX;
rY;
tMat;
tVec;
crug;
tX;
K=0.0;
this.m_J.SetZero();
if(this.m_revolute1)
{
this.m_J.angularA=-1.0;
K+=bA.m_invI
}
else
{
tMat=g1.m_xf.R;
tVec=this.m_prismatic1.m_localXAxis1;
ugX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
ugY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tMat=bA.m_xf.R;
rX=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
rY=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=tMat.col1.x*rX+tMat.col2.x*rY;
rY=tMat.col1.y*rX+tMat.col2.y*rY;
rX=tX;
crug=rX*ugY-rY*ugX;
this.m_J.linearA.Set(-ugX,-ugY);
this.m_J.angularA=-crug;
K+=bA.m_invMass+bA.m_invI*crug*crug
}
if(this.m_revolute2)
{
this.m_J.angularB=-this.m_ratio;
K+=this.m_ratio*this.m_ratio*bB.m_invI
}
else
{
tMat=g2.m_xf.R;
tVec=this.m_prismatic2.m_localXAxis1;
ugX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
ugY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tMat=bB.m_xf.R;
rX=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
rY=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=tMat.col1.x*rX+tMat.col2.x*rY;
rY=tMat.col1.y*rX+tMat.col2.y*rY;
rX=tX;
crug=rX*ugY-rY*ugX;
this.m_J.linearB.Set(-this.m_ratio*ugX,-this.m_ratio*ugY);
this.m_J.angularB=-this.m_ratio*crug;
K+=this.m_ratio*this.m_ratio*(bB.m_invMass+bB.m_invI*crug*crug)
}
this.m_mass=K>0.0?1.0/K:0.0;
if(step.warmStarting)
{
bA.m_linearVelocity.x+=bA.m_invMass*this.m_impulse*this.m_J.linearA.x;
bA.m_linearVelocity.y+=bA.m_invMass*this.m_impulse*this.m_J.linearA.y;
bA.m_angularVelocity+=bA.m_invI*this.m_impulse*this.m_J.angularA;
bB.m_linearVelocity.x+=bB.m_invMass*this.m_impulse*this.m_J.linearB.x;
bB.m_linearVelocity.y+=bB.m_invMass*this.m_impulse*this.m_J.linearB.y;
bB.m_angularVelocity+=bB.m_invI*this.m_impulse*this.m_J.angularB
}
else
{
this.m_impulse=0.0
}
};
d.SolveVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var Cdot=0;
var impulse=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
Cdot=this.m_J.Compute(bA.m_linearVelocity,bA.m_angularVelocity,bB.m_linearVelocity,bB.m_angularVelocity);
impulse=-this.m_mass*Cdot;
this.m_impulse+=impulse;
bA.m_linearVelocity.x+=bA.m_invMass*impulse*this.m_J.linearA.x;
bA.m_linearVelocity.y+=bA.m_invMass*impulse*this.m_J.linearA.y;
bA.m_angularVelocity+=bA.m_invI*impulse*this.m_J.angularA;
bB.m_linearVelocity.x+=bB.m_invMass*impulse*this.m_J.linearB.x;
bB.m_linearVelocity.y+=bB.m_invMass*impulse*this.m_J.linearB.y;
bB.m_angularVelocity+=bB.m_invI*impulse*this.m_J.angularB;
};
d.SolvePositionConstraints=function(baumgarte)
{
var linearError=0;
var bA=null;
var bB=null;
var coordinate1=0;
var coordinate2=0;
var C=0;
var impulse=0;
linearError=0.0;
bA=this.m_bodyA;
bB=this.m_bodyB;
coordinate1;
coordinate2;
if(this.m_revolute1)
{
coordinate1=this.m_revolute1.GetJointAngle()
}
else
{
coordinate1=this.m_prismatic1.GetJointTranslation()
}
if(this.m_revolute2)
{
coordinate2=this.m_revolute2.GetJointAngle()
}
else
{
coordinate2=this.m_prismatic2.GetJointTranslation()
}
C=this.m_constant-(coordinate1+this.m_ratio*coordinate2);
impulse=-this.m_mass*C;
bA.m_sweep.c.x+=bA.m_invMass*impulse*this.m_J.linearA.x;
bA.m_sweep.c.y+=bA.m_invMass*impulse*this.m_J.linearA.y;
bA.m_sweep.a+=bA.m_invI*impulse*this.m_J.angularA;
bB.m_sweep.c.x+=bB.m_invMass*impulse*this.m_J.linearB.x;
bB.m_sweep.c.y+=bB.m_invMass*impulse*this.m_J.linearB.y;
bB.m_sweep.a+=bB.m_invI*impulse*this.m_J.angularB;
bA.SynchronizeTransform();
bB.SynchronizeTransform();
return linearError<Box2D.Common.b2Settings.b2_linearSlop;
};
d.GetRatio=function()
{
return this.m_ratio;
};
d.SetRatio=function(ratio)
{
this.m_ratio=ratio;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2GearJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Jacobian","Box2D.Dynamics.Joints.b2Joint","Box2D.Dynamics.Joints.b2RevoluteJoint","Box2D.Dynamics.Joints.b2PrismaticJoint","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_localAnchor1=null;
d.m_localAnchor2=null;
d.m_localXAxis1=null;
d.m_localYAxis1=null;
d.m_axis=null;
d.m_perp=null;
d.m_s1=0;
d.m_s2=0;
d.m_a1=0;
d.m_a2=0;
d.m_K=null;
d.m_impulse=null;
d.m_motorMass=0;
d.m_motorImpulse=0;
d.m_lowerTranslation=0;
d.m_upperTranslation=0;
d.m_maxMotorForce=0;
d.m_motorSpeed=0;
d.m_enableLimit=false;
d.m_enableMotor=false;
d.m_limitState=0;
d.b2LineJoint=function(def)
{
this.m_localAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor2=new Box2D.Common.Math.b2Vec2();
this.m_localXAxis1=new Box2D.Common.Math.b2Vec2();
this.m_localYAxis1=new Box2D.Common.Math.b2Vec2();
this.m_axis=new Box2D.Common.Math.b2Vec2();
this.m_perp=new Box2D.Common.Math.b2Vec2();
this.m_K=new Box2D.Common.Math.b2Mat22();
this.m_impulse=new Box2D.Common.Math.b2Vec2();
var tMat=null;
var tX=0;
var tY=0;
this.b2Joint_constructor(def);
tMat;
tX;
tY;
this.m_localAnchor1.SetV(def.localAnchorA);
this.m_localAnchor2.SetV(def.localAnchorB);
this.m_localXAxis1.SetV(def.localAxisA);
this.m_localYAxis1.x=-this.m_localXAxis1.y;
this.m_localYAxis1.y=this.m_localXAxis1.x;
this.m_impulse.SetZero();
this.m_motorMass=0.0;
this.m_motorImpulse=0.0;
this.m_lowerTranslation=def.lowerTranslation;
this.m_upperTranslation=def.upperTranslation;
this.m_maxMotorForce=def.maxMotorForce;
this.m_motorSpeed=def.motorSpeed;
this.m_enableLimit=def.enableLimit;
this.m_enableMotor=def.enableMotor;
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_axis.SetZero();
this.m_perp.SetZero();
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.y)*this.m_axis.x),inv_dt*(this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.y)*this.m_axis.y));
};
d.GetReactionTorque=function(inv_dt)
{
return inv_dt*this.m_impulse.y;
};
d.InitVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var tMat=null;
var tX=0;
var xf1=null;
var xf2=null;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var dX=0;
var dY=0;
var m1=0;
var m2=0;
var i1=0;
var i2=0;
var jointTransition=0;
var PX=0;
var PY=0;
var L1=0;
var L2=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tX;
this.m_localCenterA.SetV(bA.GetLocalCenter());
this.m_localCenterB.SetV(bB.GetLocalCenter());
xf1=bA.GetTransform();
xf2=bB.GetTransform();
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-this.m_localCenterA.x;
r1Y=this.m_localAnchor1.y-this.m_localCenterA.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-this.m_localCenterB.x;
r2Y=this.m_localAnchor2.y-this.m_localCenterB.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
dX=bB.m_sweep.c.x+r2X-bA.m_sweep.c.x-r1X;
dY=bB.m_sweep.c.y+r2Y-bA.m_sweep.c.y-r1Y;
this.m_invMassA=bA.m_invMass;
this.m_invMassB=bB.m_invMass;
this.m_invIA=bA.m_invI;
this.m_invIB=bB.m_invI;
{
this.m_axis.SetV(Box2D.Common.Math.b2Math.MulMV(xf1.R,this.m_localXAxis1));
this.m_a1=(dX+r1X)*this.m_axis.y-(dY+r1Y)*this.m_axis.x;
this.m_a2=r2X*this.m_axis.y-r2Y*this.m_axis.x;
this.m_motorMass=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_a1*this.m_a1+this.m_invIB*this.m_a2*this.m_a2;
this.m_motorMass=this.m_motorMass>Number.MIN_VALUE?1.0/this.m_motorMass:0.0
};
{
this.m_perp.SetV(Box2D.Common.Math.b2Math.MulMV(xf1.R,this.m_localYAxis1));
this.m_s1=(dX+r1X)*this.m_perp.y-(dY+r1Y)*this.m_perp.x;
this.m_s2=r2X*this.m_perp.y-r2Y*this.m_perp.x;
m1=this.m_invMassA;
m2=this.m_invMassB;
i1=this.m_invIA;
i2=this.m_invIB;
this.m_K.col1.x=m1+m2+i1*this.m_s1*this.m_s1+i2*this.m_s2*this.m_s2;
this.m_K.col1.y=i1*this.m_s1*this.m_a1+i2*this.m_s2*this.m_a2;
this.m_K.col2.x=this.m_K.col1.y;
this.m_K.col2.y=m1+m2+i1*this.m_a1*this.m_a1+i2*this.m_a2*this.m_a2
};
if(this.m_enableLimit)
{
jointTransition=this.m_axis.x*dX+this.m_axis.y*dY;
if(Box2D.Common.Math.b2Math.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2.0*Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_equalLimits
}
else if(jointTransition<=this.m_lowerTranslation)
{
if(this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit;
this.m_impulse.y=0.0
}
}
else if(jointTransition>=this.m_upperTranslation)
{
if(this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit;
this.m_impulse.y=0.0
}
}
else
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_impulse.y=0.0
}
}
else
{
this.m_limitState=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit
}
if(this.m_enableMotor==false)
{
this.m_motorImpulse=0.0
}
if(step.warmStarting)
{
this.m_impulse.x*=step.dtRatio;
this.m_impulse.y*=step.dtRatio;
this.m_motorImpulse*=step.dtRatio;
PX=this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.y)*this.m_axis.x;
PY=this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.y)*this.m_axis.y;
L1=this.m_impulse.x*this.m_s1+(this.m_motorImpulse+this.m_impulse.y)*this.m_a1;
L2=this.m_impulse.x*this.m_s2+(this.m_motorImpulse+this.m_impulse.y)*this.m_a2;
bA.m_linearVelocity.x-=this.m_invMassA*PX;
bA.m_linearVelocity.y-=this.m_invMassA*PY;
bA.m_angularVelocity-=this.m_invIA*L1;
bB.m_linearVelocity.x+=this.m_invMassB*PX;
bB.m_linearVelocity.y+=this.m_invMassB*PY;
bB.m_angularVelocity+=this.m_invIB*L2
}
else
{
this.m_impulse.SetZero();
this.m_motorImpulse=0.0
}
};
d.SolveVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var v1=null;
var w1=0;
var v2=null;
var w2=0;
var PX=0;
var PY=0;
var L1=0;
var L2=0;
var Cdot=0;
var impulse=0;
var oldImpulse=0;
var maxImpulse=0;
var Cdot1=0;
var Cdot2=0;
var f1=null;
var df=null;
var b=0;
var f2r=0;
var df2=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
v1=bA.m_linearVelocity;
w1=bA.m_angularVelocity;
v2=bB.m_linearVelocity;
w2=bB.m_angularVelocity;
PX;
PY;
L1;
L2;
if(this.m_enableMotor&&this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_equalLimits)
{
Cdot=this.m_axis.x*(v2.x-v1.x)+this.m_axis.y*(v2.y-v1.y)+this.m_a2*w2-this.m_a1*w1;
impulse=this.m_motorMass*(this.m_motorSpeed-Cdot);
oldImpulse=this.m_motorImpulse;
maxImpulse=step.dt*this.m_maxMotorForce;
this.m_motorImpulse=Box2D.Common.Math.b2Math.Clamp(this.m_motorImpulse+impulse,-maxImpulse,maxImpulse);
impulse=this.m_motorImpulse-oldImpulse;
PX=impulse*this.m_axis.x;
PY=impulse*this.m_axis.y;
L1=impulse*this.m_a1;
L2=impulse*this.m_a2;
v1.x-=this.m_invMassA*PX;
v1.y-=this.m_invMassA*PY;
w1-=this.m_invIA*L1;
v2.x+=this.m_invMassB*PX;
v2.y+=this.m_invMassB*PY;
w2+=this.m_invIB*L2
}
Cdot1=this.m_perp.x*(v2.x-v1.x)+this.m_perp.y*(v2.y-v1.y)+this.m_s2*w2-this.m_s1*w1;
if(this.m_enableLimit&&this.m_limitState!=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit)
{
Cdot2=this.m_axis.x*(v2.x-v1.x)+this.m_axis.y*(v2.y-v1.y)+this.m_a2*w2-this.m_a1*w1;
f1=this.m_impulse.Copy();
df=this.m_K.Solve(new Box2D.Common.Math.b2Vec2(),-Cdot1,-Cdot2);
this.m_impulse.Add(df);
if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)
{
this.m_impulse.y=Box2D.Common.Math.b2Math.Max(this.m_impulse.y,0.0)
}
else if(this.m_limitState==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
this.m_impulse.y=Box2D.Common.Math.b2Math.Min(this.m_impulse.y,0.0)
}
b=-Cdot1-(this.m_impulse.y-f1.y)*this.m_K.col2.x;
f2r;
if(this.m_K.col1.x!=0.0)
{
f2r=b/this.m_K.col1.x+f1.x
}
else
{
f2r=f1.x
}
this.m_impulse.x=f2r;
df.x=this.m_impulse.x-f1.x;
df.y=this.m_impulse.y-f1.y;
PX=df.x*this.m_perp.x+df.y*this.m_axis.x;
PY=df.x*this.m_perp.y+df.y*this.m_axis.y;
L1=df.x*this.m_s1+df.y*this.m_a1;
L2=df.x*this.m_s2+df.y*this.m_a2;
v1.x-=this.m_invMassA*PX;
v1.y-=this.m_invMassA*PY;
w1-=this.m_invIA*L1;
v2.x+=this.m_invMassB*PX;
v2.y+=this.m_invMassB*PY;
w2+=this.m_invIB*L2
}
else
{
df2;
if(this.m_K.col1.x!=0.0)
{
df2=(-Cdot1)/this.m_K.col1.x
}
else
{
df2=0.0
}
this.m_impulse.x+=df2;
PX=df2*this.m_perp.x;
PY=df2*this.m_perp.y;
L1=df2*this.m_s1;
L2=df2*this.m_s2;
v1.x-=this.m_invMassA*PX;
v1.y-=this.m_invMassA*PY;
w1-=this.m_invIA*L1;
v2.x+=this.m_invMassB*PX;
v2.y+=this.m_invMassB*PY;
w2+=this.m_invIB*L2
}
bA.m_linearVelocity.SetV(v1);
bA.m_angularVelocity=w1;
bB.m_linearVelocity.SetV(v2);
bB.m_angularVelocity=w2;
};
d.SolvePositionConstraints=function(baumgarte)
{
var limitC=0;
var oldLimitImpulse=0;
var bA=null;
var bB=null;
var c1=null;
var a1=0;
var c2=null;
var a2=0;
var tMat=null;
var tX=0;
var m1=0;
var m2=0;
var i1=0;
var i2=0;
var linearError=0;
var angularError=0;
var active=false;
var C2=0;
var R1=null;
var R2=null;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var dX=0;
var dY=0;
var translation=0;
var impulse=null;
var C1=0;
var k11=0;
var impulse1=0;
var PX=0;
var PY=0;
var L1=0;
var L2=0;
limitC;
oldLimitImpulse;
bA=this.m_bodyA;
bB=this.m_bodyB;
c1=bA.m_sweep.c;
a1=bA.m_sweep.a;
c2=bB.m_sweep.c;
a2=bB.m_sweep.a;
tMat;
tX;
m1;
m2;
i1;
i2;
linearError=0.0;
angularError=0.0;
active=false;
C2=0.0;
R1=Box2D.Common.Math.b2Mat22.FromAngle(a1);
R2=Box2D.Common.Math.b2Mat22.FromAngle(a2);
tMat=R1;
r1X=this.m_localAnchor1.x-this.m_localCenterA.x;
r1Y=this.m_localAnchor1.y-this.m_localCenterA.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=R2;
r2X=this.m_localAnchor2.x-this.m_localCenterB.x;
r2Y=this.m_localAnchor2.y-this.m_localCenterB.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
dX=c2.x+r2X-c1.x-r1X;
dY=c2.y+r2Y-c1.y-r1Y;
if(this.m_enableLimit)
{
this.m_axis=Box2D.Common.Math.b2Math.MulMV(R1,this.m_localXAxis1);
this.m_a1=(dX+r1X)*this.m_axis.y-(dY+r1Y)*this.m_axis.x;
this.m_a2=r2X*this.m_axis.y-r2Y*this.m_axis.x;
translation=this.m_axis.x*dX+this.m_axis.y*dY;
if(Box2D.Common.Math.b2Math.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2.0*Box2D.Common.b2Settings.b2_linearSlop)
{
C2=Box2D.Common.Math.b2Math.Clamp(translation,-Box2D.Common.b2Settings.b2_maxLinearCorrection,Box2D.Common.b2Settings.b2_maxLinearCorrection);
linearError=Box2D.Common.Math.b2Math.Abs(translation);
active=true
}
else if(translation<=this.m_lowerTranslation)
{
C2=Box2D.Common.Math.b2Math.Clamp(translation-this.m_lowerTranslation+Box2D.Common.b2Settings.b2_linearSlop,-Box2D.Common.b2Settings.b2_maxLinearCorrection,0.0);
linearError=this.m_lowerTranslation-translation;
active=true
}
else if(translation>=this.m_upperTranslation)
{
C2=Box2D.Common.Math.b2Math.Clamp(translation-this.m_upperTranslation+Box2D.Common.b2Settings.b2_linearSlop,0.0,Box2D.Common.b2Settings.b2_maxLinearCorrection);
linearError=translation-this.m_upperTranslation;
active=true
}
}
this.m_perp=Box2D.Common.Math.b2Math.MulMV(R1,this.m_localYAxis1);
this.m_s1=(dX+r1X)*this.m_perp.y-(dY+r1Y)*this.m_perp.x;
this.m_s2=r2X*this.m_perp.y-r2Y*this.m_perp.x;
impulse=new Box2D.Common.Math.b2Vec2();
C1=this.m_perp.x*dX+this.m_perp.y*dY;
linearError=Box2D.Common.Math.b2Math.Max(linearError,Box2D.Common.Math.b2Math.Abs(C1));
angularError=0.0;
if(active)
{
m1=this.m_invMassA;
m2=this.m_invMassB;
i1=this.m_invIA;
i2=this.m_invIB;
this.m_K.col1.x=m1+m2+i1*this.m_s1*this.m_s1+i2*this.m_s2*this.m_s2;
this.m_K.col1.y=i1*this.m_s1*this.m_a1+i2*this.m_s2*this.m_a2;
this.m_K.col2.x=this.m_K.col1.y;
this.m_K.col2.y=m1+m2+i1*this.m_a1*this.m_a1+i2*this.m_a2*this.m_a2;
this.m_K.Solve(impulse,-C1,-C2)
}
else
{
m1=this.m_invMassA;
m2=this.m_invMassB;
i1=this.m_invIA;
i2=this.m_invIB;
k11=m1+m2+i1*this.m_s1*this.m_s1+i2*this.m_s2*this.m_s2;
impulse1;
if(k11!=0.0)
{
impulse1=(-C1)/k11
}
else
{
impulse1=0.0
}
impulse.x=impulse1;
impulse.y=0.0
}
PX=impulse.x*this.m_perp.x+impulse.y*this.m_axis.x;
PY=impulse.x*this.m_perp.y+impulse.y*this.m_axis.y;
L1=impulse.x*this.m_s1+impulse.y*this.m_a1;
L2=impulse.x*this.m_s2+impulse.y*this.m_a2;
c1.x-=this.m_invMassA*PX;
c1.y-=this.m_invMassA*PY;
a1-=this.m_invIA*L1;
c2.x+=this.m_invMassB*PX;
c2.y+=this.m_invMassB*PY;
a2+=this.m_invIB*L2;
bA.m_sweep.a=a1;
bB.m_sweep.a=a2;
bA.SynchronizeTransform();
bB.SynchronizeTransform();
return linearError<=Box2D.Common.b2Settings.b2_linearSlop&&angularError<=Box2D.Common.b2Settings.b2_angularSlop;
};
d.GetJointTranslation=function()
{
var bA=null;
var bB=null;
var tMat=null;
var p1=null;
var p2=null;
var dX=0;
var dY=0;
var axis=null;
var translation=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
p1=bA.GetWorldPoint(this.m_localAnchor1);
p2=bB.GetWorldPoint(this.m_localAnchor2);
dX=p2.x-p1.x;
dY=p2.y-p1.y;
axis=bA.GetWorldVector(this.m_localXAxis1);
translation=axis.x*dX+axis.y*dY;
return translation;
};
d.GetJointSpeed=function()
{
var bA=null;
var bB=null;
var tMat=null;
var r1X=0;
var r1Y=0;
var tX=0;
var r2X=0;
var r2Y=0;
var p1X=0;
var p1Y=0;
var p2X=0;
var p2Y=0;
var dX=0;
var dY=0;
var axis=null;
var v1=null;
var v2=null;
var w1=0;
var w2=0;
var speed=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
p1X=bA.m_sweep.c.x+r1X;
p1Y=bA.m_sweep.c.y+r1Y;
p2X=bB.m_sweep.c.x+r2X;
p2Y=bB.m_sweep.c.y+r2Y;
dX=p2X-p1X;
dY=p2Y-p1Y;
axis=bA.GetWorldVector(this.m_localXAxis1);
v1=bA.m_linearVelocity;
v2=bB.m_linearVelocity;
w1=bA.m_angularVelocity;
w2=bB.m_angularVelocity;
speed=(dX*(-w1*axis.y)+dY*(w1*axis.x))+(axis.x*(((v2.x+(-w2*r2Y))-v1.x)-(-w1*r1Y))+axis.y*(((v2.y+(w2*r2X))-v1.y)-(w1*r1X)));
return speed;
};
d.IsLimitEnabled=function()
{
return this.m_enableLimit;
};
d.EnableLimit=function(flag)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_enableLimit=flag;
};
d.GetLowerLimit=function()
{
return this.m_lowerTranslation;
};
d.GetUpperLimit=function()
{
return this.m_upperTranslation;
};
d.SetLimits=function(lower,upper)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_lowerTranslation=lower;
this.m_upperTranslation=upper;
};
d.IsMotorEnabled=function()
{
return this.m_enableMotor;
};
d.EnableMotor=function(flag)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_enableMotor=flag;
};
d.SetMotorSpeed=function(speed)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_motorSpeed=speed;
};
d.GetMotorSpeed=function()
{
return this.m_motorSpeed;
};
d.SetMaxMotorForce=function(force)
{
this.m_bodyA.SetAwake(true);
this.m_bodyB.SetAwake(true);
this.m_maxMotorForce=force;
};
d.GetMaxMotorForce=function()
{
return this.m_maxMotorForce;
};
d.GetMotorForce=function()
{
return this.m_motorImpulse;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2LineJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Mat22","Box2D.Common.Math.b2Math","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.K=null;
d.K1=null;
d.K2=null;
d.m_localAnchor=null;
d.m_target=null;
d.m_impulse=null;
d.m_mass=null;
d.m_C=null;
d.m_maxForce=0;
d.m_frequencyHz=0;
d.m_dampingRatio=0;
d.m_beta=0;
d.m_gamma=0;
d.b2MouseJoint=function(def)
{
this.K=new Box2D.Common.Math.b2Mat22();
this.K1=new Box2D.Common.Math.b2Mat22();
this.K2=new Box2D.Common.Math.b2Mat22();
this.m_localAnchor=new Box2D.Common.Math.b2Vec2();
this.m_target=new Box2D.Common.Math.b2Vec2();
this.m_impulse=new Box2D.Common.Math.b2Vec2();
this.m_mass=new Box2D.Common.Math.b2Mat22();
this.m_C=new Box2D.Common.Math.b2Vec2();
var tX=0;
var tY=0;
var tMat=null;
this.b2Joint_constructor(def);
this.m_target.SetV(def.target);
tX=this.m_target.x-this.m_bodyB.m_xf.position.x;
tY=this.m_target.y-this.m_bodyB.m_xf.position.y;
tMat=this.m_bodyB.m_xf.R;
this.m_localAnchor.x=(tX*tMat.col1.x+tY*tMat.col1.y);
this.m_localAnchor.y=(tX*tMat.col2.x+tY*tMat.col2.y);
this.m_maxForce=def.maxForce;
this.m_impulse.SetZero();
this.m_frequencyHz=def.frequencyHz;
this.m_dampingRatio=def.dampingRatio;
this.m_beta=0.0;
this.m_gamma=0.0;
};
d.GetAnchorA=function()
{
return this.m_target;
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*this.m_impulse.x,inv_dt*this.m_impulse.y);
};
d.GetReactionTorque=function(inv_dt)
{
return 0.0;
};
d.InitVelocityConstraints=function(step)
{
var b=null;
var mass=0;
var omega=0;
var d=0;
var k=0;
var tMat=null;
var rX=0;
var rY=0;
var tX=0;
var invMass=0;
var invI=0;
b=this.m_bodyB;
mass=b.GetMass();
omega=2.0*Math.PI*this.m_frequencyHz;
d=2.0*mass*this.m_dampingRatio*omega;
k=mass*omega*omega;
this.m_gamma=step.dt*(d+step.dt*k);
this.m_gamma=this.m_gamma!=0?1/this.m_gamma:0.0;
this.m_beta=step.dt*k*this.m_gamma;
tMat;
tMat=b.m_xf.R;
rX=this.m_localAnchor.x-b.m_sweep.localCenter.x;
rY=this.m_localAnchor.y-b.m_sweep.localCenter.y;
tX=(tMat.col1.x*rX+tMat.col2.x*rY);
rY=(tMat.col1.y*rX+tMat.col2.y*rY);
rX=tX;
invMass=b.m_invMass;
invI=b.m_invI;
this.K1.col1.x=invMass;
this.K1.col2.x=0.0;
this.K1.col1.y=0.0;
this.K1.col2.y=invMass;
this.K2.col1.x=invI*rY*rY;
this.K2.col2.x=-invI*rX*rY;
this.K2.col1.y=-invI*rX*rY;
this.K2.col2.y=invI*rX*rX;
this.K.SetM(this.K1);
this.K.AddM(this.K2);
this.K.col1.x+=this.m_gamma;
this.K.col2.y+=this.m_gamma;
this.K.GetInverse(this.m_mass);
this.m_C.x=b.m_sweep.c.x+rX-this.m_target.x;
this.m_C.y=b.m_sweep.c.y+rY-this.m_target.y;
b.m_angularVelocity*=0.98;
this.m_impulse.x*=step.dtRatio;
this.m_impulse.y*=step.dtRatio;
b.m_linearVelocity.x+=invMass*this.m_impulse.x;
b.m_linearVelocity.y+=invMass*this.m_impulse.y;
b.m_angularVelocity+=invI*(rX*this.m_impulse.y-rY*this.m_impulse.x);
};
d.SolveVelocityConstraints=function(step)
{
var b=null;
var tMat=null;
var tX=0;
var tY=0;
var rX=0;
var rY=0;
var CdotX=0;
var CdotY=0;
var impulseX=0;
var impulseY=0;
var oldImpulseX=0;
var oldImpulseY=0;
var maxImpulse=0;
b=this.m_bodyB;
tMat;
tX;
tY;
tMat=b.m_xf.R;
rX=this.m_localAnchor.x-b.m_sweep.localCenter.x;
rY=this.m_localAnchor.y-b.m_sweep.localCenter.y;
tX=(tMat.col1.x*rX+tMat.col2.x*rY);
rY=(tMat.col1.y*rX+tMat.col2.y*rY);
rX=tX;
CdotX=b.m_linearVelocity.x+(-b.m_angularVelocity*rY);
CdotY=b.m_linearVelocity.y+(b.m_angularVelocity*rX);
tMat=this.m_mass;
tX=CdotX+this.m_beta*this.m_C.x+this.m_gamma*this.m_impulse.x;
tY=CdotY+this.m_beta*this.m_C.y+this.m_gamma*this.m_impulse.y;
impulseX=-(tMat.col1.x*tX+tMat.col2.x*tY);
impulseY=-(tMat.col1.y*tX+tMat.col2.y*tY);
oldImpulseX=this.m_impulse.x;
oldImpulseY=this.m_impulse.y;
this.m_impulse.x+=impulseX;
this.m_impulse.y+=impulseY;
maxImpulse=step.dt*this.m_maxForce;
if(this.m_impulse.LengthSquared()>maxImpulse*maxImpulse)
{
this.m_impulse.Multiply(maxImpulse/this.m_impulse.Length())
}
impulseX=this.m_impulse.x-oldImpulseX;
impulseY=this.m_impulse.y-oldImpulseY;
b.m_linearVelocity.x+=b.m_invMass*impulseX;
b.m_linearVelocity.y+=b.m_invMass*impulseY;
b.m_angularVelocity+=b.m_invI*(rX*impulseY-rY*impulseX);
};
d.SolvePositionConstraints=function(baumgarte)
{
return true;
};
d.GetTarget=function()
{
return this.m_target;
};
d.SetTarget=function(target)
{
if(this.m_bodyB.IsAwake()==false)
{
this.m_bodyB.SetAwake(true)
}
this.m_target=target;
};
d.GetMaxForce=function()
{
return this.m_maxForce;
};
d.SetMaxForce=function(maxForce)
{
this.m_maxForce=maxForce;
};
d.GetFrequency=function()
{
return this.m_frequencyHz;
};
d.SetFrequency=function(hz)
{
this.m_frequencyHz=hz;
};
d.GetDampingRatio=function()
{
return this.m_dampingRatio;
};
d.SetDampingRatio=function(ratio)
{
this.m_dampingRatio=ratio;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2MouseJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Mat22","Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.type=0;
d.userData=null;
d.bodyA=null;
d.bodyB=null;
d.collideConnected=false;
d.b2JointDef=function()
{
this.type=Box2D.Dynamics.Joints.b2Joint.e_unknownJoint;
this.userData=null;
this.bodyA=null;
this.bodyB=null;
this.collideConnected=false;
};
flash.addDescription("Box2D.Dynamics.Joints.b2JointDef",d,null,null,null,["Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.localAnchorA=null;
d.localAnchorB=null;
d.length=0;
d.frequencyHz=0;
d.dampingRatio=0;
d.b2DistanceJointDef=function()
{
this.localAnchorA=new Box2D.Common.Math.b2Vec2();
this.localAnchorB=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_distanceJoint;
this.length=1.0;
this.frequencyHz=0.0;
this.dampingRatio=0.0;
};
d.Initialize=function(bA,bB,anchorA,anchorB)
{
var dX=0;
var dY=0;
this.bodyA=bA;
this.bodyB=bB;
this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
dX=anchorB.x-anchorA.x;
dY=anchorB.y-anchorA.y;
this.length=Math.sqrt(dX*dX+dY*dY);
this.frequencyHz=0.0;
this.dampingRatio=0.0;
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2DistanceJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.localAnchorA=null;
d.localAnchorB=null;
d.referenceAngle=0;
d.enableLimit=false;
d.lowerAngle=0;
d.upperAngle=0;
d.enableMotor=false;
d.motorSpeed=0;
d.maxMotorTorque=0;
d.b2RevoluteJointDef=function()
{
this.localAnchorA=new Box2D.Common.Math.b2Vec2();
this.localAnchorB=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint;
this.localAnchorA.Set(0.0,0.0);
this.localAnchorB.Set(0.0,0.0);
this.referenceAngle=0.0;
this.lowerAngle=0.0;
this.upperAngle=0.0;
this.maxMotorTorque=0.0;
this.motorSpeed=0.0;
this.enableLimit=false;
this.enableMotor=false;
};
d.Initialize=function(bA,bB,anchor)
{
this.bodyA=bA;
this.bodyB=bB;
this.localAnchorA=this.bodyA.GetLocalPoint(anchor);
this.localAnchorB=this.bodyB.GetLocalPoint(anchor);
this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle();
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2RevoluteJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.localAnchorA=null;
d.localAnchorB=null;
d.maxForce=0;
d.maxTorque=0;
d.b2FrictionJointDef=function()
{
this.localAnchorA=new Box2D.Common.Math.b2Vec2();
this.localAnchorB=new Box2D.Common.Math.b2Vec2();
this.b2JointDef_constructor();
this.type=Box2D.Dynamics.Joints.b2Joint.e_frictionJoint;
this.maxForce=0.0;
this.maxTorque=0.0;
};
d.Initialize=function(bA,bB,anchor)
{
this.bodyA=bA;
this.bodyB=bB;
this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
};
var s={};
s.__init__=function()
{
this.prototype.b2JointDef_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Joints.b2FrictionJointDef",d,"Box2D.Dynamics.Joints.b2JointDef",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.Joints.b2Joint"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_ground=null;
d.m_groundAnchor1=null;
d.m_groundAnchor2=null;
d.m_localAnchor1=null;
d.m_localAnchor2=null;
d.m_u1=null;
d.m_u2=null;
d.m_constant=0;
d.m_ratio=0;
d.m_maxLength1=0;
d.m_maxLength2=0;
d.m_pulleyMass=0;
d.m_limitMass1=0;
d.m_limitMass2=0;
d.m_impulse=0;
d.m_limitImpulse1=0;
d.m_limitImpulse2=0;
d.m_state=0;
d.m_limitState1=0;
d.m_limitState2=0;
d.b2PulleyJoint=function(def)
{
this.m_groundAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_groundAnchor2=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor1=new Box2D.Common.Math.b2Vec2();
this.m_localAnchor2=new Box2D.Common.Math.b2Vec2();
this.m_u1=new Box2D.Common.Math.b2Vec2();
this.m_u2=new Box2D.Common.Math.b2Vec2();
var tMat=null;
var tX=0;
var tY=0;
this.b2Joint_constructor(def);
tMat;
tX;
tY;
this.m_ground=this.m_bodyA.m_world.m_groundBody;
this.m_groundAnchor1.x=def.groundAnchorA.x-this.m_ground.m_xf.position.x;
this.m_groundAnchor1.y=def.groundAnchorA.y-this.m_ground.m_xf.position.y;
this.m_groundAnchor2.x=def.groundAnchorB.x-this.m_ground.m_xf.position.x;
this.m_groundAnchor2.y=def.groundAnchorB.y-this.m_ground.m_xf.position.y;
this.m_localAnchor1.SetV(def.localAnchorA);
this.m_localAnchor2.SetV(def.localAnchorB);
this.m_ratio=def.ratio;
this.m_constant=def.lengthA+this.m_ratio*def.lengthB;
this.m_maxLength1=Box2D.Common.Math.b2Math.Min(def.maxLengthA,this.m_constant-this.m_ratio*Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength);
this.m_maxLength2=Box2D.Common.Math.b2Math.Min(def.maxLengthB,(this.m_constant-Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength)/this.m_ratio);
this.m_impulse=0.0;
this.m_limitImpulse1=0.0;
this.m_limitImpulse2=0.0;
};
d.GetAnchorA=function()
{
return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
};
d.GetAnchorB=function()
{
return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
};
d.GetReactionForce=function(inv_dt)
{
return new Box2D.Common.Math.b2Vec2(inv_dt*this.m_impulse*this.m_u2.x,inv_dt*this.m_impulse*this.m_u2.y);
};
d.GetReactionTorque=function(inv_dt)
{
return 0.0;
};
d.InitVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var tMat=null;
var r1X=0;
var r1Y=0;
var tX=0;
var r2X=0;
var r2Y=0;
var p1X=0;
var p1Y=0;
var p2X=0;
var p2Y=0;
var s1X=0;
var s1Y=0;
var s2X=0;
var s2Y=0;
var length1=0;
var length2=0;
var C=0;
var cr1u1=0;
var cr2u2=0;
var P1X=0;
var P1Y=0;
var P2X=0;
var P2Y=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
p1X=bA.m_sweep.c.x+r1X;
p1Y=bA.m_sweep.c.y+r1Y;
p2X=bB.m_sweep.c.x+r2X;
p2Y=bB.m_sweep.c.y+r2Y;
s1X=this.m_ground.m_xf.position.x+this.m_groundAnchor1.x;
s1Y=this.m_ground.m_xf.position.y+this.m_groundAnchor1.y;
s2X=this.m_ground.m_xf.position.x+this.m_groundAnchor2.x;
s2Y=this.m_ground.m_xf.position.y+this.m_groundAnchor2.y;
this.m_u1.Set(p1X-s1X,p1Y-s1Y);
this.m_u2.Set(p2X-s2X,p2Y-s2Y);
length1=this.m_u1.Length();
length2=this.m_u2.Length();
if(length1>Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_u1.Multiply(1.0/length1)
}
else
{
this.m_u1.SetZero()
}
if(length2>Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_u2.Multiply(1.0/length2)
}
else
{
this.m_u2.SetZero()
}
C=this.m_constant-length1-this.m_ratio*length2;
if(C>0.0)
{
this.m_state=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_impulse=0.0
}
else
{
this.m_state=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit
}
if(length1<this.m_maxLength1)
{
this.m_limitState1=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_limitImpulse1=0.0
}
else
{
this.m_limitState1=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit
}
if(length2<this.m_maxLength2)
{
this.m_limitState2=Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;
this.m_limitImpulse2=0.0
}
else
{
this.m_limitState2=Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit
}
cr1u1=r1X*this.m_u1.y-r1Y*this.m_u1.x;
cr2u2=r2X*this.m_u2.y-r2Y*this.m_u2.x;
this.m_limitMass1=bA.m_invMass+bA.m_invI*cr1u1*cr1u1;
this.m_limitMass2=bB.m_invMass+bB.m_invI*cr2u2*cr2u2;
this.m_pulleyMass=this.m_limitMass1+this.m_ratio*this.m_ratio*this.m_limitMass2;
this.m_limitMass1=1.0/this.m_limitMass1;
this.m_limitMass2=1.0/this.m_limitMass2;
this.m_pulleyMass=1.0/this.m_pulleyMass;
if(step.warmStarting)
{
this.m_impulse*=step.dtRatio;
this.m_limitImpulse1*=step.dtRatio;
this.m_limitImpulse2*=step.dtRatio;
P1X=(-this.m_impulse-this.m_limitImpulse1)*this.m_u1.x;
P1Y=(-this.m_impulse-this.m_limitImpulse1)*this.m_u1.y;
P2X=(-this.m_ratio*this.m_impulse-this.m_limitImpulse2)*this.m_u2.x;
P2Y=(-this.m_ratio*this.m_impulse-this.m_limitImpulse2)*this.m_u2.y;
bA.m_linearVelocity.x+=bA.m_invMass*P1X;
bA.m_linearVelocity.y+=bA.m_invMass*P1Y;
bA.m_angularVelocity+=bA.m_invI*(r1X*P1Y-r1Y*P1X);
bB.m_linearVelocity.x+=bB.m_invMass*P2X;
bB.m_linearVelocity.y+=bB.m_invMass*P2Y;
bB.m_angularVelocity+=bB.m_invI*(r2X*P2Y-r2Y*P2X)
}
else
{
this.m_impulse=0.0;
this.m_limitImpulse1=0.0;
this.m_limitImpulse2=0.0
}
};
d.SolveVelocityConstraints=function(step)
{
var bA=null;
var bB=null;
var tMat=null;
var r1X=0;
var r1Y=0;
var tX=0;
var r2X=0;
var r2Y=0;
var v1X=0;
var v1Y=0;
var v2X=0;
var v2Y=0;
var P1X=0;
var P1Y=0;
var P2X=0;
var P2Y=0;
var Cdot=0;
var impulse=0;
var oldImpulse=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
v1X;
v1Y;
v2X;
v2Y;
P1X;
P1Y;
P2X;
P2Y;
Cdot;
impulse;
oldImpulse;
if(this.m_state==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
v1X=bA.m_linearVelocity.x+(-bA.m_angularVelocity*r1Y);
v1Y=bA.m_linearVelocity.y+(bA.m_angularVelocity*r1X);
v2X=bB.m_linearVelocity.x+(-bB.m_angularVelocity*r2Y);
v2Y=bB.m_linearVelocity.y+(bB.m_angularVelocity*r2X);
Cdot=-(this.m_u1.x*v1X+this.m_u1.y*v1Y)-this.m_ratio*(this.m_u2.x*v2X+this.m_u2.y*v2Y);
impulse=this.m_pulleyMass*(-Cdot);
oldImpulse=this.m_impulse;
this.m_impulse=Box2D.Common.Math.b2Math.Max(0.0,this.m_impulse+impulse);
impulse=this.m_impulse-oldImpulse;
P1X=-impulse*this.m_u1.x;
P1Y=-impulse*this.m_u1.y;
P2X=-this.m_ratio*impulse*this.m_u2.x;
P2Y=-this.m_ratio*impulse*this.m_u2.y;
bA.m_linearVelocity.x+=bA.m_invMass*P1X;
bA.m_linearVelocity.y+=bA.m_invMass*P1Y;
bA.m_angularVelocity+=bA.m_invI*(r1X*P1Y-r1Y*P1X);
bB.m_linearVelocity.x+=bB.m_invMass*P2X;
bB.m_linearVelocity.y+=bB.m_invMass*P2Y;
bB.m_angularVelocity+=bB.m_invI*(r2X*P2Y-r2Y*P2X)
}
if(this.m_limitState1==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
v1X=bA.m_linearVelocity.x+(-bA.m_angularVelocity*r1Y);
v1Y=bA.m_linearVelocity.y+(bA.m_angularVelocity*r1X);
Cdot=-(this.m_u1.x*v1X+this.m_u1.y*v1Y);
impulse=-this.m_limitMass1*Cdot;
oldImpulse=this.m_limitImpulse1;
this.m_limitImpulse1=Box2D.Common.Math.b2Math.Max(0.0,this.m_limitImpulse1+impulse);
impulse=this.m_limitImpulse1-oldImpulse;
P1X=-impulse*this.m_u1.x;
P1Y=-impulse*this.m_u1.y;
bA.m_linearVelocity.x+=bA.m_invMass*P1X;
bA.m_linearVelocity.y+=bA.m_invMass*P1Y;
bA.m_angularVelocity+=bA.m_invI*(r1X*P1Y-r1Y*P1X)
}
if(this.m_limitState2==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
v2X=bB.m_linearVelocity.x+(-bB.m_angularVelocity*r2Y);
v2Y=bB.m_linearVelocity.y+(bB.m_angularVelocity*r2X);
Cdot=-(this.m_u2.x*v2X+this.m_u2.y*v2Y);
impulse=-this.m_limitMass2*Cdot;
oldImpulse=this.m_limitImpulse2;
this.m_limitImpulse2=Box2D.Common.Math.b2Math.Max(0.0,this.m_limitImpulse2+impulse);
impulse=this.m_limitImpulse2-oldImpulse;
P2X=-impulse*this.m_u2.x;
P2Y=-impulse*this.m_u2.y;
bB.m_linearVelocity.x+=bB.m_invMass*P2X;
bB.m_linearVelocity.y+=bB.m_invMass*P2Y;
bB.m_angularVelocity+=bB.m_invI*(r2X*P2Y-r2Y*P2X)
}
};
d.SolvePositionConstraints=function(baumgarte)
{
var bA=null;
var bB=null;
var tMat=null;
var s1X=0;
var s1Y=0;
var s2X=0;
var s2Y=0;
var r1X=0;
var r1Y=0;
var r2X=0;
var r2Y=0;
var p1X=0;
var p1Y=0;
var p2X=0;
var p2Y=0;
var length1=0;
var length2=0;
var C=0;
var impulse=0;
var oldImpulse=0;
var oldLimitPositionImpulse=0;
var tX=0;
var linearError=0;
bA=this.m_bodyA;
bB=this.m_bodyB;
tMat;
s1X=this.m_ground.m_xf.position.x+this.m_groundAnchor1.x;
s1Y=this.m_ground.m_xf.position.y+this.m_groundAnchor1.y;
s2X=this.m_ground.m_xf.position.x+this.m_groundAnchor2.x;
s2Y=this.m_ground.m_xf.position.y+this.m_groundAnchor2.y;
r1X;
r1Y;
r2X;
r2Y;
p1X;
p1Y;
p2X;
p2Y;
length1;
length2;
C;
impulse;
oldImpulse;
oldLimitPositionImpulse;
tX;
linearError=0.0;
if(this.m_state==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
p1X=bA.m_sweep.c.x+r1X;
p1Y=bA.m_sweep.c.y+r1Y;
p2X=bB.m_sweep.c.x+r2X;
p2Y=bB.m_sweep.c.y+r2Y;
this.m_u1.Set(p1X-s1X,p1Y-s1Y);
this.m_u2.Set(p2X-s2X,p2Y-s2Y);
length1=this.m_u1.Length();
length2=this.m_u2.Length();
if(length1>Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_u1.Multiply(1.0/length1)
}
else
{
this.m_u1.SetZero()
}
if(length2>Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_u2.Multiply(1.0/length2)
}
else
{
this.m_u2.SetZero()
}
C=this.m_constant-length1-this.m_ratio*length2;
linearError=Box2D.Common.Math.b2Math.Max(linearError,-C);
C=Box2D.Common.Math.b2Math.Clamp(C+Box2D.Common.b2Settings.b2_linearSlop,-Box2D.Common.b2Settings.b2_maxLinearCorrection,0.0);
impulse=-this.m_pulleyMass*C;
p1X=-impulse*this.m_u1.x;
p1Y=-impulse*this.m_u1.y;
p2X=-this.m_ratio*impulse*this.m_u2.x;
p2Y=-this.m_ratio*impulse*this.m_u2.y;
bA.m_sweep.c.x+=bA.m_invMass*p1X;
bA.m_sweep.c.y+=bA.m_invMass*p1Y;
bA.m_sweep.a+=bA.m_invI*(r1X*p1Y-r1Y*p1X);
bB.m_sweep.c.x+=bB.m_invMass*p2X;
bB.m_sweep.c.y+=bB.m_invMass*p2Y;
bB.m_sweep.a+=bB.m_invI*(r2X*p2Y-r2Y*p2X);
bA.SynchronizeTransform();
bB.SynchronizeTransform()
}
if(this.m_limitState1==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
tMat=bA.m_xf.R;
r1X=this.m_localAnchor1.x-bA.m_sweep.localCenter.x;
r1Y=this.m_localAnchor1.y-bA.m_sweep.localCenter.y;
tX=(tMat.col1.x*r1X+tMat.col2.x*r1Y);
r1Y=(tMat.col1.y*r1X+tMat.col2.y*r1Y);
r1X=tX;
p1X=bA.m_sweep.c.x+r1X;
p1Y=bA.m_sweep.c.y+r1Y;
this.m_u1.Set(p1X-s1X,p1Y-s1Y);
length1=this.m_u1.Length();
if(length1>Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_u1.x*=1.0/length1;
this.m_u1.y*=1.0/length1
}
else
{
this.m_u1.SetZero()
}
C=this.m_maxLength1-length1;
linearError=Box2D.Common.Math.b2Math.Max(linearError,-C);
C=Box2D.Common.Math.b2Math.Clamp(C+Box2D.Common.b2Settings.b2_linearSlop,-Box2D.Common.b2Settings.b2_maxLinearCorrection,0.0);
impulse=-this.m_limitMass1*C;
p1X=-impulse*this.m_u1.x;
p1Y=-impulse*this.m_u1.y;
bA.m_sweep.c.x+=bA.m_invMass*p1X;
bA.m_sweep.c.y+=bA.m_invMass*p1Y;
bA.m_sweep.a+=bA.m_invI*(r1X*p1Y-r1Y*p1X);
bA.SynchronizeTransform()
}
if(this.m_limitState2==Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)
{
tMat=bB.m_xf.R;
r2X=this.m_localAnchor2.x-bB.m_sweep.localCenter.x;
r2Y=this.m_localAnchor2.y-bB.m_sweep.localCenter.y;
tX=(tMat.col1.x*r2X+tMat.col2.x*r2Y);
r2Y=(tMat.col1.y*r2X+tMat.col2.y*r2Y);
r2X=tX;
p2X=bB.m_sweep.c.x+r2X;
p2Y=bB.m_sweep.c.y+r2Y;
this.m_u2.Set(p2X-s2X,p2Y-s2Y);
length2=this.m_u2.Length();
if(length2>Box2D.Common.b2Settings.b2_linearSlop)
{
this.m_u2.x*=1.0/length2;
this.m_u2.y*=1.0/length2
}
else
{
this.m_u2.SetZero()
}
C=this.m_maxLength2-length2;
linearError=Box2D.Common.Math.b2Math.Max(linearError,-C);
C=Box2D.Common.Math.b2Math.Clamp(C+Box2D.Common.b2Settings.b2_linearSlop,-Box2D.Common.b2Settings.b2_maxLinearCorrection,0.0);
impulse=-this.m_limitMass2*C;
p2X=-impulse*this.m_u2.x;
p2Y=-impulse*this.m_u2.y;
bB.m_sweep.c.x+=bB.m_invMass*p2X;
bB.m_sweep.c.y+=bB.m_invMass*p2Y;
bB.m_sweep.a+=bB.m_invI*(r2X*p2Y-r2Y*p2X);
bB.SynchronizeTransform()
}
return linearError<Box2D.Common.b2Settings.b2_linearSlop;
};
d.GetGroundAnchorA=function()
{
var a=null;
a=this.m_ground.m_xf.position.Copy();
a.Add(this.m_groundAnchor1);
return a;
};
d.GetGroundAnchorB=function()
{
var a=null;
a=this.m_ground.m_xf.position.Copy();
a.Add(this.m_groundAnchor2);
return a;
};
d.GetLength1=function()
{
var p=null;
var sX=0;
var sY=0;
var dX=0;
var dY=0;
p=this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
sX=this.m_ground.m_xf.position.x+this.m_groundAnchor1.x;
sY=this.m_ground.m_xf.position.y+this.m_groundAnchor1.y;
dX=p.x-sX;
dY=p.y-sY;
return Math.sqrt(dX*dX+dY*dY);
};
d.GetLength2=function()
{
var p=null;
var sX=0;
var sY=0;
var dX=0;
var dY=0;
p=this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
sX=this.m_ground.m_xf.position.x+this.m_groundAnchor2.x;
sY=this.m_ground.m_xf.position.y+this.m_groundAnchor2.y;
dX=p.x-sX;
dY=p.y-sY;
return Math.sqrt(dX*dX+dY*dY);
};
d.GetRatio=function()
{
return this.m_ratio;
};
var s={};
s.__init__=function()
{
this.prototype.b2Joint_constructor=this.__base__;
this.b2_minPulleyLength=2.0;
};
flash.addDescription("Box2D.Dynamics.Joints.b2PulleyJoint",d,"Box2D.Dynamics.Joints.b2Joint",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Math","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.linearA=null;
d.angularA=0;
d.linearB=null;
d.angularB=0;
d.SetZero=function()
{
this.linearA.SetZero();
this.angularA=0.0;
this.linearB.SetZero();
this.angularB=0.0;
};
d.Set=function(x1,a1,x2,a2)
{
this.linearA.SetV(x1);
this.angularA=a1;
this.linearB.SetV(x2);
this.angularB=a2;
};
d.Compute=function(x1,a1,x2,a2)
{
return(this.linearA.x*x1.x+this.linearA.y*x1.y)+this.angularA*a1+(this.linearB.x*x2.x+this.linearB.y*x2.y)+this.angularB*a2;
};
d.b2Jacobian=function()
{
this.linearA=new Box2D.Common.Math.b2Vec2();
this.linearB=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Dynamics.Joints.b2Jacobian",d,null,null,null,["Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_world=null;
d.m_broadPhase=null;
d.m_contactList=null;
d.m_contactCount=0;
d.m_contactFilter=null;
d.m_contactListener=null;
d.m_contactFactory=null;
d.m_allocator=null;
d.b2ContactManager=function()
{
this.m_world=null;
this.m_contactCount=0;
this.m_contactFilter=Box2D.Dynamics.b2ContactFilter.b2_defaultFilter;
this.m_contactListener=Box2D.Dynamics.b2ContactListener.b2_defaultListener;
this.m_contactFactory=new Box2D.Dynamics.Contacts.b2ContactFactory(this.m_allocator);
this.m_broadPhase=new Box2D.Collision.b2DynamicTreeBroadPhase();
};
d.AddPair=function(proxyUserDataA,proxyUserDataB)
{
var fixtureA=null;
var fixtureB=null;
var bodyA=null;
var bodyB=null;
var edge=null;
var fA=null;
var fB=null;
var c=null;
fixtureA=proxyUserDataA;
fixtureB=proxyUserDataB;
bodyA=fixtureA.GetBody();
bodyB=fixtureB.GetBody();
if(bodyA==bodyB)
{
return
}
edge=bodyB.GetContactList();
while(edge)
{
if(edge.other==bodyA)
{
fA=edge.contact.GetFixtureA();
fB=edge.contact.GetFixtureB();
if(fA==fixtureA&&fB==fixtureB)
{
return
}
if(fA==fixtureB&&fB==fixtureA)
{
return
}
}
edge=edge.next
}
if(bodyB.ShouldCollide(bodyA)==false)
{
return
}
if(this.m_contactFilter.ShouldCollide(fixtureA,fixtureB)==false)
{
return
}
c=this.m_contactFactory.Create(fixtureA,fixtureB);
fixtureA=c.GetFixtureA();
fixtureB=c.GetFixtureB();
bodyA=fixtureA.m_body;
bodyB=fixtureB.m_body;
c.m_prev=null;
c.m_next=this.m_world.m_contactList;
if(this.m_world.m_contactList!=null)
{
this.m_world.m_contactList.m_prev=c
}
this.m_world.m_contactList=c;
c.m_nodeA.contact=c;
c.m_nodeA.other=bodyB;
c.m_nodeA.prev=null;
c.m_nodeA.next=bodyA.m_contactList;
if(bodyA.m_contactList!=null)
{
bodyA.m_contactList.prev=c.m_nodeA
}
bodyA.m_contactList=c.m_nodeA;
c.m_nodeB.contact=c;
c.m_nodeB.other=bodyA;
c.m_nodeB.prev=null;
c.m_nodeB.next=bodyB.m_contactList;
if(bodyB.m_contactList!=null)
{
bodyB.m_contactList.prev=c.m_nodeB
}
bodyB.m_contactList=c.m_nodeB;
++this.m_world.m_contactCount;
};
d.FindNewContacts=function()
{
this.m_broadPhase.UpdatePairs(flash.bindFunction(this,this.AddPair));
};
d.Destroy=function(c)
{
var fixtureA=null;
var fixtureB=null;
var bodyA=null;
var bodyB=null;
fixtureA=c.GetFixtureA();
fixtureB=c.GetFixtureB();
bodyA=fixtureA.GetBody();
bodyB=fixtureB.GetBody();
if(c.IsTouching())
{
this.m_contactListener.EndContact(c)
}
if(c.m_prev)
{
c.m_prev.m_next=c.m_next
}
if(c.m_next)
{
c.m_next.m_prev=c.m_prev
}
if(c==this.m_world.m_contactList)
{
this.m_world.m_contactList=c.m_next
}
if(c.m_nodeA.prev)
{
c.m_nodeA.prev.next=c.m_nodeA.next
}
if(c.m_nodeA.next)
{
c.m_nodeA.next.prev=c.m_nodeA.prev
}
if(c.m_nodeA==bodyA.m_contactList)
{
bodyA.m_contactList=c.m_nodeA.next
}
if(c.m_nodeB.prev)
{
c.m_nodeB.prev.next=c.m_nodeB.next
}
if(c.m_nodeB.next)
{
c.m_nodeB.next.prev=c.m_nodeB.prev
}
if(c.m_nodeB==bodyB.m_contactList)
{
bodyB.m_contactList=c.m_nodeB.next
}
this.m_contactFactory.Destroy(c);
--this.m_contactCount;
};
d.Collide=function()
{
var c=null;
var fixtureA=null;
var fixtureB=null;
var bodyA=null;
var bodyB=null;
var cNuke=null;
var proxyA=null;
var proxyB=null;
var overlap=false;
c=this.m_world.m_contactList;
while(c)
{
fixtureA=c.GetFixtureA();
fixtureB=c.GetFixtureB();
bodyA=fixtureA.GetBody();
bodyB=fixtureB.GetBody();
if(bodyA.IsAwake()==false&&bodyB.IsAwake()==false)
{
c=c.GetNext();
continue;
;
}
if(c.m_flags&Box2D.Dynamics.Contacts.b2Contact.e_filterFlag)
{
if(bodyB.ShouldCollide(bodyA)==false)
{
cNuke=c;
c=cNuke.GetNext();
this.Destroy(cNuke);
continue;
;
}
if(this.m_contactFilter.ShouldCollide(fixtureA,fixtureB)==false)
{
cNuke=c;
c=cNuke.GetNext();
this.Destroy(cNuke);
continue;
;
}
c.m_flags&=~Box2D.Dynamics.Contacts.b2Contact.e_filterFlag
}
proxyA=fixtureA.m_proxy;
proxyB=fixtureB.m_proxy;
overlap=this.m_broadPhase.TestOverlap(proxyA,proxyB);
if(overlap==false)
{
cNuke=c;
c=cNuke.GetNext();
this.Destroy(cNuke);
continue;
;
}
c.Update(this.m_contactListener);
c=c.GetNext()
}
};
var s={};
s.__init__=function()
{
this.s_evalCP=new Box2D.Collision.b2ContactPoint();
};
flash.addDescription("Box2D.Dynamics.b2ContactManager",d,null,s,null,["Box2D.Collision.b2ContactPoint","Box2D.Dynamics.b2ContactFilter","Box2D.Dynamics.b2ContactListener","Box2D.Dynamics.Contacts.b2ContactFactory","Box2D.Collision.b2DynamicTreeBroadPhase","Box2D.Dynamics.b2Fixture","Box2D.Dynamics.Contacts.b2Contact"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_flags=0;
d.m_type=0;
d.m_islandIndex=0;
d.m_xf=null;
d.m_sweep=null;
d.m_linearVelocity=null;
d.m_angularVelocity=0;
d.m_force=null;
d.m_torque=0;
d.m_world=null;
d.m_prev=null;
d.m_next=null;
d.m_fixtureList=null;
d.m_fixtureCount=0;
d.m_controllerList=null;
d.m_controllerCount=0;
d.m_jointList=null;
d.m_contactList=null;
d.m_mass=0;
d.m_invMass=0;
d.m_I=0;
d.m_invI=0;
d.m_inertiaScale=0;
d.m_linearDamping=0;
d.m_angularDamping=0;
d.m_sleepTime=0;
d.m_userData=null;
d.b2Body=function(bd,world)
{
this.m_xf=new Box2D.Common.Math.b2Transform();
this.m_sweep=new Box2D.Common.Math.b2Sweep();
this.m_linearVelocity=new Box2D.Common.Math.b2Vec2();
this.m_force=new Box2D.Common.Math.b2Vec2();
var tMat=null;
var tVec=null;
this.m_flags=0;
if(bd.bullet)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_bulletFlag
}
if(bd.fixedRotation)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_fixedRotationFlag
}
if(bd.allowSleep)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_allowSleepFlag
}
if(bd.awake)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_awakeFlag
}
if(bd.active)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_activeFlag
}
this.m_world=world;
this.m_xf.position.SetV(bd.position);
this.m_xf.R.Set(bd.angle);
this.m_sweep.localCenter.SetZero();
this.m_sweep.t0=1.0;
this.m_sweep.a0=this.m_sweep.a=bd.angle;
tMat=this.m_xf.R;
tVec=this.m_sweep.localCenter;
this.m_sweep.c.x=(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
this.m_sweep.c.y=(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
this.m_sweep.c.x+=this.m_xf.position.x;
this.m_sweep.c.y+=this.m_xf.position.y;
this.m_sweep.c0.SetV(this.m_sweep.c);
this.m_jointList=null;
this.m_controllerList=null;
this.m_contactList=null;
this.m_controllerCount=0;
this.m_prev=null;
this.m_next=null;
this.m_linearVelocity.SetV(bd.linearVelocity);
this.m_angularVelocity=bd.angularVelocity;
this.m_linearDamping=bd.linearDamping;
this.m_angularDamping=bd.angularDamping;
this.m_force.Set(0.0,0.0);
this.m_torque=0.0;
this.m_sleepTime=0.0;
this.m_type=bd.type;
if(this.m_type==Box2D.Dynamics.b2Body.b2_dynamicBody)
{
this.m_mass=1.0;
this.m_invMass=1.0
}
else
{
this.m_mass=0.0;
this.m_invMass=0.0
}
this.m_I=0.0;
this.m_invI=0.0;
this.m_inertiaScale=bd.inertiaScale;
this.m_userData=bd.userData;
this.m_fixtureList=null;
this.m_fixtureCount=0;
};
d.CreateFixture=function(def)
{
var fixture=null;
var broadPhase=null;
if(this.m_world.IsLocked()==true)
{
return null
}
fixture=new Box2D.Dynamics.b2Fixture();
fixture.Create(this,this.m_xf,def);
if(this.m_flags&Box2D.Dynamics.b2Body.e_activeFlag)
{
broadPhase=this.m_world.m_contactManager.m_broadPhase;
fixture.CreateProxy(broadPhase,this.m_xf)
}
fixture.m_next=this.m_fixtureList;
this.m_fixtureList=fixture;
++this.m_fixtureCount;
fixture.m_body=this;
if(fixture.m_density>0.0)
{
this.ResetMassData()
}
this.m_world.m_flags|=Box2D.Dynamics.b2World.e_newFixture;
return fixture;
};
d.CreateFixture2=function(shape,density)
{
if(density==undefined)density=0.0;
var def=null;
def=new Box2D.Dynamics.b2FixtureDef();
def.shape=shape;
def.density=density;
return this.CreateFixture(def);
};
d.DestroyFixture=function(fixture)
{
var node=null;
var ppF=null;
var found=false;
var edge=null;
var c=null;
var fixtureA=null;
var fixtureB=null;
var broadPhase=null;
if(this.m_world.IsLocked()==true)
{
return
}
node=this.m_fixtureList;
ppF=null;
found=false;
while(node!=null)
{
if(node==fixture)
{
if(ppF)
{
ppF.m_next=fixture.m_next
}
else
{
this.m_fixtureList=fixture.m_next
}
found=true;
break;
;
}
ppF=node;
node=node.m_next
}
edge=this.m_contactList;
while(edge)
{
c=edge.contact;
edge=edge.next;
fixtureA=c.GetFixtureA();
fixtureB=c.GetFixtureB();
if(fixture==fixtureA||fixture==fixtureB)
{
this.m_world.m_contactManager.Destroy(c)
}
}
if(this.m_flags&Box2D.Dynamics.b2Body.e_activeFlag)
{
broadPhase=this.m_world.m_contactManager.m_broadPhase;
fixture.DestroyProxy(broadPhase)
}
else
{
}
fixture.Destroy();
fixture.m_body=null;
fixture.m_next=null;
--this.m_fixtureCount;
this.ResetMassData();
};
d.SetPositionAndAngle=function(position,angle)
{
var f=null;
var tMat=null;
var tVec=null;
var broadPhase=null;
f;
if(this.m_world.IsLocked()==true)
{
return
}
this.m_xf.R.Set(angle);
this.m_xf.position.SetV(position);
tMat=this.m_xf.R;
tVec=this.m_sweep.localCenter;
this.m_sweep.c.x=(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
this.m_sweep.c.y=(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
this.m_sweep.c.x+=this.m_xf.position.x;
this.m_sweep.c.y+=this.m_xf.position.y;
this.m_sweep.c0.SetV(this.m_sweep.c);
this.m_sweep.a0=this.m_sweep.a=angle;
broadPhase=this.m_world.m_contactManager.m_broadPhase;
for(f=this.m_fixtureList;f;f=f.m_next)
{
f.Synchronize(broadPhase,this.m_xf,this.m_xf)
}
this.m_world.m_contactManager.FindNewContacts();
};
d.SetTransform=function(xf)
{
this.SetPositionAndAngle(xf.position,xf.GetAngle());
};
d.GetTransform=function()
{
return this.m_xf;
};
d.GetPosition=function()
{
return this.m_xf.position;
};
d.SetPosition=function(position)
{
this.SetPositionAndAngle(position,this.GetAngle());
};
d.GetAngle=function()
{
return this.m_sweep.a;
};
d.SetAngle=function(angle)
{
this.SetPositionAndAngle(this.GetPosition(),angle);
};
d.GetWorldCenter=function()
{
return this.m_sweep.c;
};
d.GetLocalCenter=function()
{
return this.m_sweep.localCenter;
};
d.SetLinearVelocity=function(v)
{
if(this.m_type==Box2D.Dynamics.b2Body.b2_staticBody)
{
return
}
this.m_linearVelocity.SetV(v);
};
d.GetLinearVelocity=function()
{
return this.m_linearVelocity;
};
d.SetAngularVelocity=function(omega)
{
if(this.m_type==Box2D.Dynamics.b2Body.b2_staticBody)
{
return
}
this.m_angularVelocity=omega;
};
d.GetAngularVelocity=function()
{
return this.m_angularVelocity;
};
d.GetDefinition=function()
{
var bd=null;
bd=new Box2D.Dynamics.b2BodyDef();
bd.type=this.GetType();
bd.allowSleep=(this.m_flags&Box2D.Dynamics.b2Body.e_allowSleepFlag)==Box2D.Dynamics.b2Body.e_allowSleepFlag;
bd.angle=this.GetAngle();
bd.angularDamping=this.m_angularDamping;
bd.angularVelocity=this.m_angularVelocity;
bd.fixedRotation=(this.m_flags&Box2D.Dynamics.b2Body.e_fixedRotationFlag)==Box2D.Dynamics.b2Body.e_fixedRotationFlag;
bd.bullet=(this.m_flags&Box2D.Dynamics.b2Body.e_bulletFlag)==Box2D.Dynamics.b2Body.e_bulletFlag;
bd.awake=(this.m_flags&Box2D.Dynamics.b2Body.e_awakeFlag)==Box2D.Dynamics.b2Body.e_awakeFlag;
bd.linearDamping=this.m_linearDamping;
bd.linearVelocity.SetV(this.GetLinearVelocity());
bd.position=this.GetPosition();
bd.userData=this.GetUserData();
return bd;
};
d.ApplyForce=function(force,point)
{
if(this.m_type!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
return
}
if(this.IsAwake()==false)
{
this.SetAwake(true)
}
this.m_force.x+=force.x;
this.m_force.y+=force.y;
this.m_torque+=((point.x-this.m_sweep.c.x)*force.y-(point.y-this.m_sweep.c.y)*force.x);
};
d.ApplyTorque=function(torque)
{
if(this.m_type!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
return
}
if(this.IsAwake()==false)
{
this.SetAwake(true)
}
this.m_torque+=torque;
};
d.ApplyImpulse=function(impulse,point)
{
if(this.m_type!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
return
}
if(this.IsAwake()==false)
{
this.SetAwake(true)
}
this.m_linearVelocity.x+=this.m_invMass*impulse.x;
this.m_linearVelocity.y+=this.m_invMass*impulse.y;
this.m_angularVelocity+=this.m_invI*((point.x-this.m_sweep.c.x)*impulse.y-(point.y-this.m_sweep.c.y)*impulse.x);
};
d.Split=function(callback)
{
var linearVelocity=null;
var angularVelocity=0;
var center=null;
var body1=null;
var body2=null;
var prev=null;
var f=null;
var next=null;
var center1=null;
var center2=null;
var velocity1=null;
var velocity2=null;
linearVelocity=this.GetLinearVelocity().Copy();
angularVelocity=this.GetAngularVelocity();
center=this.GetWorldCenter();
body1=this;
body2=this.m_world.CreateBody(this.GetDefinition());
prev;
f=body1.m_fixtureList;
while(f!=null)
{
if(callback(f))
{
next=f.m_next;
if(prev)
{
prev.m_next=next
}
else
{
body1.m_fixtureList=next
}
body1.m_fixtureCount--;
f.m_next=body2.m_fixtureList;
body2.m_fixtureList=f;
body2.m_fixtureCount++;
f.m_body=body2;
f=next
}
else
{
prev=f;
f=f.m_next
}
}
body1.ResetMassData();
body2.ResetMassData();
center1=body1.GetWorldCenter();
center2=body2.GetWorldCenter();
velocity1=Box2D.Common.Math.b2Math.AddVV(linearVelocity,Box2D.Common.Math.b2Math.CrossFV(angularVelocity,Box2D.Common.Math.b2Math.SubtractVV(center1,center)));
velocity2=Box2D.Common.Math.b2Math.AddVV(linearVelocity,Box2D.Common.Math.b2Math.CrossFV(angularVelocity,Box2D.Common.Math.b2Math.SubtractVV(center2,center)));
body1.SetLinearVelocity(velocity1);
body2.SetLinearVelocity(velocity2);
body1.SetAngularVelocity(angularVelocity);
body2.SetAngularVelocity(angularVelocity);
body1.SynchronizeFixtures();
body2.SynchronizeFixtures();
return body2;
};
d.Merge=function(other)
{
var f=null;
var next=null;
var body1=null;
var body2=null;
var center1=null;
var center2=null;
var velocity1=null;
var velocity2=null;
var angular1=0;
var angular=0;
f=other.m_fixtureList;
while(f)
{
next=f.m_next;
other.m_fixtureCount--;
f.m_next=this.m_fixtureList;
this.m_fixtureList=f;
this.m_fixtureCount++;
f.m_body=body2;
f=next
}
body1.m_fixtureCount=0;
body1=this;
body2=other;
center1=body1.GetWorldCenter();
center2=body2.GetWorldCenter();
velocity1=body1.GetLinearVelocity().Copy();
velocity2=body2.GetLinearVelocity().Copy();
angular1=body1.GetAngularVelocity();
angular=body2.GetAngularVelocity();
body1.ResetMassData();
this.SynchronizeFixtures();
};
d.GetMass=function()
{
return this.m_mass;
};
d.GetInertia=function()
{
return this.m_I;
};
d.GetMassData=function(data)
{
data.mass=this.m_mass;
data.I=this.m_I;
data.center.SetV(this.m_sweep.localCenter);
};
d.SetMassData=function(massData)
{
var oldCenter=null;
Box2D.Common.b2Settings.b2Assert(this.m_world.IsLocked()==false);
if(this.m_world.IsLocked()==true)
{
return
}
if(this.m_type!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
return
}
this.m_invMass=0.0;
this.m_I=0.0;
this.m_invI=0.0;
this.m_mass=massData.mass;
if(this.m_mass<=0.0)
{
this.m_mass=1.0
}
this.m_invMass=1.0/this.m_mass;
if(massData.I>0.0&&(this.m_flags&Box2D.Dynamics.b2Body.e_fixedRotationFlag)==0)
{
this.m_I=massData.I-this.m_mass*(massData.center.x*massData.center.x+massData.center.y*massData.center.y);
this.m_invI=1.0/this.m_I
}
oldCenter=this.m_sweep.c.Copy();
this.m_sweep.localCenter.SetV(massData.center);
this.m_sweep.c0.SetV(Box2D.Common.Math.b2Math.MulX(this.m_xf,this.m_sweep.localCenter));
this.m_sweep.c.SetV(this.m_sweep.c0);
this.m_linearVelocity.x+=this.m_angularVelocity*-(this.m_sweep.c.y-oldCenter.y);
this.m_linearVelocity.y+=this.m_angularVelocity*+(this.m_sweep.c.x-oldCenter.x);
};
d.ResetMassData=function()
{
var center=null;
var f=null;
var massData=null;
var oldCenter=null;
this.m_mass=0.0;
this.m_invMass=0.0;
this.m_I=0.0;
this.m_invI=0.0;
this.m_sweep.localCenter.SetZero();
if(this.m_type==Box2D.Dynamics.b2Body.b2_staticBody||this.m_type==Box2D.Dynamics.b2Body.b2_kinematicBody)
{
return
}
center=Box2D.Common.Math.b2Vec2.Make(0,0);
for(f=this.m_fixtureList;f;f=f.m_next)
{
if(f.m_density==0.0)
{
continue;
;
}
massData=f.GetMassData();
this.m_mass+=massData.mass;
center.x+=massData.center.x*massData.mass;
center.y+=massData.center.y*massData.mass;
this.m_I+=massData.I
}
if(this.m_mass>0.0)
{
this.m_invMass=1.0/this.m_mass;
center.x*=this.m_invMass;
center.y*=this.m_invMass
}
else
{
this.m_mass=1.0;
this.m_invMass=1.0
}
if(this.m_I>0.0&&(this.m_flags&Box2D.Dynamics.b2Body.e_fixedRotationFlag)==0)
{
this.m_I-=this.m_mass*(center.x*center.x+center.y*center.y);
this.m_I*=this.m_inertiaScale;
Box2D.Common.b2Settings.b2Assert(this.m_I>0);
this.m_invI=1.0/this.m_I
}
else
{
this.m_I=0.0;
this.m_invI=0.0
}
oldCenter=this.m_sweep.c.Copy();
this.m_sweep.localCenter.SetV(center);
this.m_sweep.c0.SetV(Box2D.Common.Math.b2Math.MulX(this.m_xf,this.m_sweep.localCenter));
this.m_sweep.c.SetV(this.m_sweep.c0);
this.m_linearVelocity.x+=this.m_angularVelocity*-(this.m_sweep.c.y-oldCenter.y);
this.m_linearVelocity.y+=this.m_angularVelocity*+(this.m_sweep.c.x-oldCenter.x);
};
d.GetWorldPoint=function(localPoint)
{
var A=null;
var u=null;
A=this.m_xf.R;
u=new Box2D.Common.Math.b2Vec2(A.col1.x*localPoint.x+A.col2.x*localPoint.y,A.col1.y*localPoint.x+A.col2.y*localPoint.y);
u.x+=this.m_xf.position.x;
u.y+=this.m_xf.position.y;
return u;
};
d.GetWorldVector=function(localVector)
{
return Box2D.Common.Math.b2Math.MulMV(this.m_xf.R,localVector);
};
d.GetLocalPoint=function(worldPoint)
{
return Box2D.Common.Math.b2Math.MulXT(this.m_xf,worldPoint);
};
d.GetLocalVector=function(worldVector)
{
return Box2D.Common.Math.b2Math.MulTMV(this.m_xf.R,worldVector);
};
d.GetLinearVelocityFromWorldPoint=function(worldPoint)
{
return new Box2D.Common.Math.b2Vec2(this.m_linearVelocity.x-this.m_angularVelocity*(worldPoint.y-this.m_sweep.c.y),this.m_linearVelocity.y+this.m_angularVelocity*(worldPoint.x-this.m_sweep.c.x));
};
d.GetLinearVelocityFromLocalPoint=function(localPoint)
{
var A=null;
var worldPoint=null;
A=this.m_xf.R;
worldPoint=new Box2D.Common.Math.b2Vec2(A.col1.x*localPoint.x+A.col2.x*localPoint.y,A.col1.y*localPoint.x+A.col2.y*localPoint.y);
worldPoint.x+=this.m_xf.position.x;
worldPoint.y+=this.m_xf.position.y;
return new Box2D.Common.Math.b2Vec2(this.m_linearVelocity.x-this.m_angularVelocity*(worldPoint.y-this.m_sweep.c.y),this.m_linearVelocity.y+this.m_angularVelocity*(worldPoint.x-this.m_sweep.c.x));
};
d.GetLinearDamping=function()
{
return this.m_linearDamping;
};
d.SetLinearDamping=function(linearDamping)
{
this.m_linearDamping=linearDamping;
};
d.GetAngularDamping=function()
{
return this.m_angularDamping;
};
d.SetAngularDamping=function(angularDamping)
{
this.m_angularDamping=angularDamping;
};
d.SetType=function(type)
{
type=flash.uint(type);
var ce=null;
if(this.m_type==type)
{
return
}
this.m_type=type;
this.ResetMassData();
if(this.m_type==Box2D.Dynamics.b2Body.b2_staticBody)
{
this.m_linearVelocity.SetZero();
this.m_angularVelocity=0.0
}
this.SetAwake(true);
this.m_force.SetZero();
this.m_torque=0.0;
for(ce=this.m_contactList;ce;ce=ce.next)
{
ce.contact.FlagForFiltering()
}
};
d.GetType=function()
{
return this.m_type;
};
d.SetBullet=function(flag)
{
if(flag)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_bulletFlag
}
else
{
this.m_flags&=~Box2D.Dynamics.b2Body.e_bulletFlag
}
};
d.IsBullet=function()
{
return(this.m_flags&Box2D.Dynamics.b2Body.e_bulletFlag)==Box2D.Dynamics.b2Body.e_bulletFlag;
};
d.SetSleepingAllowed=function(flag)
{
if(flag)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_allowSleepFlag
}
else
{
this.m_flags&=~Box2D.Dynamics.b2Body.e_allowSleepFlag;
this.SetAwake(true)
}
};
d.SetAwake=function(flag)
{
if(flag)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_awakeFlag;
this.m_sleepTime=0.0
}
else
{
this.m_flags&=~Box2D.Dynamics.b2Body.e_awakeFlag;
this.m_sleepTime=0.0;
this.m_linearVelocity.SetZero();
this.m_angularVelocity=0.0;
this.m_force.SetZero();
this.m_torque=0.0
}
};
d.IsAwake=function()
{
return(this.m_flags&Box2D.Dynamics.b2Body.e_awakeFlag)==Box2D.Dynamics.b2Body.e_awakeFlag;
};
d.SetFixedRotation=function(fixed)
{
if(fixed)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_fixedRotationFlag
}
else
{
this.m_flags&=~Box2D.Dynamics.b2Body.e_fixedRotationFlag
}
this.ResetMassData();
};
d.IsFixedRotation=function()
{
return(this.m_flags&Box2D.Dynamics.b2Body.e_fixedRotationFlag)==Box2D.Dynamics.b2Body.e_fixedRotationFlag;
};
d.SetActive=function(flag)
{
var broadPhase=null;
var f=null;
var ce=null;
var ce0=null;
if(flag==this.IsActive())
{
return
}
broadPhase;
f;
if(flag)
{
this.m_flags|=Box2D.Dynamics.b2Body.e_activeFlag;
broadPhase=this.m_world.m_contactManager.m_broadPhase;
for(f=this.m_fixtureList;f;f=f.m_next)
{
f.CreateProxy(broadPhase,this.m_xf)
}
}
else
{
this.m_flags&=~Box2D.Dynamics.b2Body.e_activeFlag;
broadPhase=this.m_world.m_contactManager.m_broadPhase;
for(f=this.m_fixtureList;f;f=f.m_next)
{
f.DestroyProxy(broadPhase)
}
ce=this.m_contactList;
while(ce)
{
ce0=ce;
ce=ce.next;
this.m_world.m_contactManager.Destroy(ce0.contact)
}
this.m_contactList=null
}
};
d.IsActive=function()
{
return(this.m_flags&Box2D.Dynamics.b2Body.e_activeFlag)==Box2D.Dynamics.b2Body.e_activeFlag;
};
d.IsSleepingAllowed=function()
{
return(this.m_flags&Box2D.Dynamics.b2Body.e_allowSleepFlag)==Box2D.Dynamics.b2Body.e_allowSleepFlag;
};
d.GetFixtureList=function()
{
return this.m_fixtureList;
};
d.GetJointList=function()
{
return this.m_jointList;
};
d.GetControllerList=function()
{
return this.m_controllerList;
};
d.GetContactList=function()
{
return this.m_contactList;
};
d.GetNext=function()
{
return this.m_next;
};
d.GetUserData=function()
{
return this.m_userData;
};
d.SetUserData=function(data)
{
this.m_userData=data;
};
d.GetWorld=function()
{
return this.m_world;
};
d.SynchronizeFixtures=function()
{
var xf1=null;
var tMat=null;
var tVec=null;
var f=null;
var broadPhase=null;
xf1=Box2D.Dynamics.b2Body.s_xf1;
xf1.R.Set(this.m_sweep.a0);
tMat=xf1.R;
tVec=this.m_sweep.localCenter;
xf1.position.x=this.m_sweep.c0.x-(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
xf1.position.y=this.m_sweep.c0.y-(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
f;
broadPhase=this.m_world.m_contactManager.m_broadPhase;
for(f=this.m_fixtureList;f;f=f.m_next)
{
f.Synchronize(broadPhase,xf1,this.m_xf)
}
};
d.SynchronizeTransform=function()
{
var tMat=null;
var tVec=null;
this.m_xf.R.Set(this.m_sweep.a);
tMat=this.m_xf.R;
tVec=this.m_sweep.localCenter;
this.m_xf.position.x=this.m_sweep.c.x-(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
this.m_xf.position.y=this.m_sweep.c.y-(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
};
d.ShouldCollide=function(other)
{
var jn=null;
if(this.m_type!=Box2D.Dynamics.b2Body.b2_dynamicBody&&other.m_type!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
return false
}
for(jn=this.m_jointList;jn;jn=jn.next)
{
if(jn.other==other)
{
if(jn.joint.m_collideConnected==false)
{
return false
}
}
}
return true;
};
d.Advance=function(t)
{
this.m_sweep.Advance(t);
this.m_sweep.c.SetV(this.m_sweep.c0);
this.m_sweep.a=this.m_sweep.a0;
this.SynchronizeTransform();
};
d.connectEdges=function(s1,s2,angle1)
{
var angle2=0;
var coreOffset=0;
var core=null;
var cornerDir=null;
var convex=false;
angle2=Math.atan2(s2.GetDirectionVector().y,s2.GetDirectionVector().x);
coreOffset=Math.tan((angle2-angle1)*0.5);
core=Box2D.Common.Math.b2Math.MulFV(coreOffset,s2.GetDirectionVector());
core=Box2D.Common.Math.b2Math.SubtractVV(core,s2.GetNormalVector());
core=Box2D.Common.Math.b2Math.MulFV(Box2D.Common.b2Settings.b2_toiSlop,core);
core=Box2D.Common.Math.b2Math.AddVV(core,s2.GetVertex1());
cornerDir=Box2D.Common.Math.b2Math.AddVV(s1.GetDirectionVector(),s2.GetDirectionVector());
cornerDir.Normalize();
convex=Box2D.Common.Math.b2Math.Dot(s1.GetDirectionVector(),s2.GetNormalVector())>0.0;
s1.SetNextEdge(s2,core,cornerDir,convex);
s2.SetPrevEdge(s1,core,cornerDir,convex);
return angle2;
};
var s={};
s.__init__=function()
{
this.e_islandFlag=0x0001;
this.e_awakeFlag=0x0002;
this.e_allowSleepFlag=0x0004;
this.e_bulletFlag=0x0008;
this.e_fixedRotationFlag=0x0010;
this.e_activeFlag=0x0020;
this.b2_staticBody=0;
this.b2_kinematicBody=1;
this.b2_dynamicBody=2;
this.s_xf1=new Box2D.Common.Math.b2Transform();
};
flash.addDescription("Box2D.Dynamics.b2Body",d,null,s,null,["Box2D.Common.Math.b2Transform","Box2D.Common.Math.b2Sweep","Box2D.Common.Math.b2Vec2","Box2D.Dynamics.b2Fixture","Box2D.Dynamics.b2World","Box2D.Dynamics.b2FixtureDef","Box2D.Dynamics.b2BodyDef","Box2D.Common.Math.b2Math","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.type=0;
d.position=null;
d.angle=0;
d.linearVelocity=null;
d.angularVelocity=0;
d.linearDamping=0;
d.angularDamping=0;
d.allowSleep=false;
d.awake=false;
d.fixedRotation=false;
d.bullet=false;
d.active=false;
d.userData=null;
d.inertiaScale=0;
d.b2BodyDef=function()
{
this.position=new Box2D.Common.Math.b2Vec2();
this.linearVelocity=new Box2D.Common.Math.b2Vec2();
this.userData=null;
this.position.Set(0.0,0.0);
this.angle=0.0;
this.linearVelocity.Set(0,0);
this.angularVelocity=0.0;
this.linearDamping=0.0;
this.angularDamping=0.0;
this.allowSleep=true;
this.awake=true;
this.fixedRotation=false;
this.bullet=false;
this.type=Box2D.Dynamics.b2Body.b2_staticBody;
this.active=true;
this.inertiaScale=1.0;
};
flash.addDescription("Box2D.Dynamics.b2BodyDef",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Dynamics.b2Body"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_sprite=null;
d.m_drawFlags=0;
d.m_drawScale=0;
d.m_lineThickness=0;
d.m_alpha=0;
d.m_fillAlpha=0;
d.m_xformScale=0;
d.b2DebugDraw=function()
{
this.m_drawScale=1.0;
this.m_lineThickness=1.0;
this.m_alpha=1.0;
this.m_fillAlpha=1.0;
this.m_xformScale=1.0;
this.m_drawFlags=0;
};
d.SetFlags=function(flags)
{
flags=flash.uint(flags);
this.m_drawFlags=flags;
};
d.GetFlags=function()
{
return this.m_drawFlags;
};
d.AppendFlags=function(flags)
{
flags=flash.uint(flags);
this.m_drawFlags|=flags;
};
d.ClearFlags=function(flags)
{
flags=flash.uint(flags);
this.m_drawFlags&=~flags;
};
d.SetSprite=function(sprite)
{
this.m_sprite=sprite;
};
d.GetSprite=function()
{
return this.m_sprite;
};
d.SetDrawScale=function(drawScale)
{
this.m_drawScale=drawScale;
};
d.GetDrawScale=function()
{
return this.m_drawScale;
};
d.SetLineThickness=function(lineThickness)
{
this.m_lineThickness=lineThickness;
};
d.GetLineThickness=function()
{
return this.m_lineThickness;
};
d.SetAlpha=function(alpha)
{
this.m_alpha=alpha;
};
d.GetAlpha=function()
{
return this.m_alpha;
};
d.SetFillAlpha=function(alpha)
{
this.m_fillAlpha=alpha;
};
d.GetFillAlpha=function()
{
return this.m_fillAlpha;
};
d.SetXFormScale=function(xformScale)
{
this.m_xformScale=xformScale;
};
d.GetXFormScale=function()
{
return this.m_xformScale;
};
d.DrawPolygon=function(vertices,vertexCount,color)
{
vertexCount=flash.int(vertexCount);
var i=0;
this.m_sprite.get_graphics().lineStyle(this.m_lineThickness,color.get_color(),this.m_alpha);
this.m_sprite.get_graphics().moveTo(vertices[0].x*this.m_drawScale,vertices[0].y*this.m_drawScale);
for(i=1;i<vertexCount;i++)
{
this.m_sprite.get_graphics().lineTo(vertices[i].x*this.m_drawScale,vertices[i].y*this.m_drawScale)
}
this.m_sprite.get_graphics().lineTo(vertices[0].x*this.m_drawScale,vertices[0].y*this.m_drawScale);
};
d.DrawSolidPolygon=function(vertices,vertexCount,color)
{
vertexCount=flash.int(vertexCount);
var i=0;
this.m_sprite.get_graphics().lineStyle(this.m_lineThickness,color.get_color(),this.m_alpha);
this.m_sprite.get_graphics().moveTo(vertices[0].x*this.m_drawScale,vertices[0].y*this.m_drawScale);
this.m_sprite.get_graphics().beginFill(color.get_color(),this.m_fillAlpha);
for(i=1;i<vertexCount;i++)
{
this.m_sprite.get_graphics().lineTo(vertices[i].x*this.m_drawScale,vertices[i].y*this.m_drawScale)
}
this.m_sprite.get_graphics().lineTo(vertices[0].x*this.m_drawScale,vertices[0].y*this.m_drawScale);
this.m_sprite.get_graphics().endFill();
};
d.DrawCircle=function(center,radius,color)
{
this.m_sprite.get_graphics().lineStyle(this.m_lineThickness,color.get_color(),this.m_alpha);
this.m_sprite.get_graphics().drawCircle(center.x*this.m_drawScale,center.y*this.m_drawScale,radius*this.m_drawScale);
};
d.DrawSolidCircle=function(center,radius,axis,color)
{
this.m_sprite.get_graphics().lineStyle(this.m_lineThickness,color.get_color(),this.m_alpha);
this.m_sprite.get_graphics().moveTo(0,0);
this.m_sprite.get_graphics().beginFill(color.get_color(),this.m_fillAlpha);
this.m_sprite.get_graphics().drawCircle(center.x*this.m_drawScale,center.y*this.m_drawScale,radius*this.m_drawScale);
this.m_sprite.get_graphics().endFill();
this.m_sprite.get_graphics().moveTo(center.x*this.m_drawScale,center.y*this.m_drawScale);
this.m_sprite.get_graphics().lineTo((center.x+axis.x*radius)*this.m_drawScale,(center.y+axis.y*radius)*this.m_drawScale);
};
d.DrawSegment=function(p1,p2,color)
{
this.m_sprite.get_graphics().lineStyle(this.m_lineThickness,color.get_color(),this.m_alpha);
this.m_sprite.get_graphics().moveTo(p1.x*this.m_drawScale,p1.y*this.m_drawScale);
this.m_sprite.get_graphics().lineTo(p2.x*this.m_drawScale,p2.y*this.m_drawScale);
};
d.DrawTransform=function(xf)
{
this.m_sprite.get_graphics().lineStyle(this.m_lineThickness,0xff0000,this.m_alpha);
this.m_sprite.get_graphics().moveTo(xf.position.x*this.m_drawScale,xf.position.y*this.m_drawScale);
this.m_sprite.get_graphics().lineTo((xf.position.x+this.m_xformScale*xf.R.col1.x)*this.m_drawScale,(xf.position.y+this.m_xformScale*xf.R.col1.y)*this.m_drawScale);
this.m_sprite.get_graphics().lineStyle(this.m_lineThickness,0x00ff00,this.m_alpha);
this.m_sprite.get_graphics().moveTo(xf.position.x*this.m_drawScale,xf.position.y*this.m_drawScale);
this.m_sprite.get_graphics().lineTo((xf.position.x+this.m_xformScale*xf.R.col2.x)*this.m_drawScale,(xf.position.y+this.m_xformScale*xf.R.col2.y)*this.m_drawScale);
};
var s={};
s.__init__=function()
{
this.e_shapeBit=0x0001;
this.e_jointBit=0x0002;
this.e_aabbBit=0x0004;
this.e_pairBit=0x0008;
this.e_centerOfMassBit=0x0010;
this.e_controllerBit=0x0020;
};
flash.addDescription("Box2D.Dynamics.b2DebugDraw",d,null,s,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.normalImpulses=null;
d.tangentImpulses=null;
d.b2ContactImpulse=function()
{
this.normalImpulses=new Array();
this.tangentImpulses=new Array();
};
flash.addDescription("Box2D.Dynamics.b2ContactImpulse",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.BeginContact=function(contact)
{
};
d.EndContact=function(contact)
{
};
d.PreSolve=function(contact,oldManifold)
{
};
d.PostSolve=function(contact,impulse)
{
};
d.b2ContactListener=function()
{
};
var s={};
s.__init__=function()
{
this.b2_defaultListener=new Box2D.Dynamics.b2ContactListener();
};
flash.addDescription("Box2D.Dynamics.b2ContactListener",d,null,s,null,["Box2D.Dynamics.b2ContactListener"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_bodies=null;
d.m_contacts=null;
d.m_joints=null;
d.m_bodyCount=0;
d.m_jointCount=0;
d.m_contactCount=0;
d.m_contactCapacity=0;
d.m_jointCapacity=0;
d.m_allocator=null;
d.m_listener=null;
d.m_contactSolver=null;
d.m_bodyCapacity=0;
d.b2Island=function()
{
this.m_bodies=new Array();
this.m_contacts=new Array();
this.m_joints=new Array();
};
d.Initialize=function(bodyCapacity,contactCapacity,jointCapacity,allocator,listener,contactSolver)
{
bodyCapacity=flash.int(bodyCapacity);
contactCapacity=flash.int(contactCapacity);
jointCapacity=flash.int(jointCapacity);
var i=0;
i;
this.m_bodyCapacity=bodyCapacity;
this.m_contactCapacity=contactCapacity;
this.m_jointCapacity=jointCapacity;
this.m_bodyCount=0;
this.m_contactCount=0;
this.m_jointCount=0;
this.m_allocator=allocator;
this.m_listener=listener;
this.m_contactSolver=contactSolver;
for(i=this.m_bodies.length;i<bodyCapacity;i++)
{
this.m_bodies[i]=null
}
for(i=this.m_contacts.length;i<contactCapacity;i++)
{
this.m_contacts[i]=null
}
for(i=this.m_joints.length;i<jointCapacity;i++)
{
this.m_joints[i]=null
}
};
d.Clear=function()
{
this.m_bodyCount=0;
this.m_contactCount=0;
this.m_jointCount=0;
};
d.Solve=function(step,gravity,allowSleep)
{
var i=0;
var j=0;
var b=null;
var joint=null;
var contactSolver=null;
var translationX=0;
var translationY=0;
var rotation=0;
var contactsOkay=false;
var jointsOkay=false;
var jointOkay=false;
var minSleepTime=0;
var linTolSqr=0;
var angTolSqr=0;
i;
j;
b;
joint;
for(i=0;i<this.m_bodyCount;++i)
{
b=this.m_bodies[i];
if(b.GetType()!=Box2D.Dynamics.b2Body.b2_dynamicBody)
{
continue
}
;b.m_linearVelocity.x+=step.dt*(gravity.x+b.m_invMass*b.m_force.x);
b.m_linearVelocity.y+=step.dt*(gravity.y+b.m_invMass*b.m_force.y);
b.m_angularVelocity+=step.dt*b.m_invI*b.m_torque;
b.m_linearVelocity.Multiply(Box2D.Common.Math.b2Math.Clamp(1.0-step.dt*b.m_linearDamping,0.0,1.0));
b.m_angularVelocity*=Box2D.Common.Math.b2Math.Clamp(1.0-step.dt*b.m_angularDamping,0.0,1.0)
}
this.m_contactSolver.Initialize(step,this.m_contacts,this.m_contactCount,this.m_allocator);
contactSolver=this.m_contactSolver;
contactSolver.InitVelocityConstraints(step);
for(i=0;i<this.m_jointCount;++i)
{
joint=this.m_joints[i];
joint.InitVelocityConstraints(step)
}
for(i=0;i<step.velocityIterations;++i)
{
for(j=0;j<this.m_jointCount;++j)
{
joint=this.m_joints[j];
joint.SolveVelocityConstraints(step)
}
contactSolver.SolveVelocityConstraints()
}
for(i=0;i<this.m_jointCount;++i)
{
joint=this.m_joints[i];
joint.FinalizeVelocityConstraints()
}
contactSolver.FinalizeVelocityConstraints();
for(i=0;i<this.m_bodyCount;++i)
{
b=this.m_bodies[i];
if(b.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
continue
}
;translationX=step.dt*b.m_linearVelocity.x;
translationY=step.dt*b.m_linearVelocity.y;
if((translationX*translationX+translationY*translationY)>Box2D.Common.b2Settings.b2_maxTranslationSquared)
{
b.m_linearVelocity.Normalize();
b.m_linearVelocity.x*=Box2D.Common.b2Settings.b2_maxTranslation*step.inv_dt;
b.m_linearVelocity.y*=Box2D.Common.b2Settings.b2_maxTranslation*step.inv_dt
}
rotation=step.dt*b.m_angularVelocity;
if(rotation*rotation>Box2D.Common.b2Settings.b2_maxRotationSquared)
{
if(b.m_angularVelocity<0.0)
{
b.m_angularVelocity=-Box2D.Common.b2Settings.b2_maxRotation*step.inv_dt
}
else
{
b.m_angularVelocity=Box2D.Common.b2Settings.b2_maxRotation*step.inv_dt
}
}
b.m_sweep.c0.SetV(b.m_sweep.c);
b.m_sweep.a0=b.m_sweep.a;
b.m_sweep.c.x+=step.dt*b.m_linearVelocity.x;
b.m_sweep.c.y+=step.dt*b.m_linearVelocity.y;
b.m_sweep.a+=step.dt*b.m_angularVelocity;
b.SynchronizeTransform()
}
for(i=0;i<step.positionIterations;++i)
{
contactsOkay=contactSolver.SolvePositionConstraints(Box2D.Common.b2Settings.b2_contactBaumgarte);
jointsOkay=true;
for(j=0;j<this.m_jointCount;++j)
{
joint=this.m_joints[j];
jointOkay=joint.SolvePositionConstraints(Box2D.Common.b2Settings.b2_contactBaumgarte);
jointsOkay=jointsOkay&&jointOkay
}
if(contactsOkay&&jointsOkay)
{
break;
;
}
}
this.Report(contactSolver.m_constraints);
if(allowSleep)
{
minSleepTime=Number.MAX_VALUE;
linTolSqr=Box2D.Common.b2Settings.b2_linearSleepTolerance*Box2D.Common.b2Settings.b2_linearSleepTolerance;
angTolSqr=Box2D.Common.b2Settings.b2_angularSleepTolerance*Box2D.Common.b2Settings.b2_angularSleepTolerance;
for(i=0;i<this.m_bodyCount;++i)
{
b=this.m_bodies[i];
if(b.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
continue;
;
}
if((b.m_flags&Box2D.Dynamics.b2Body.e_allowSleepFlag)==0)
{
b.m_sleepTime=0.0;
minSleepTime=0.0
}
if((b.m_flags&Box2D.Dynamics.b2Body.e_allowSleepFlag)==0||b.m_angularVelocity*b.m_angularVelocity>angTolSqr||Box2D.Common.Math.b2Math.Dot(b.m_linearVelocity,b.m_linearVelocity)>linTolSqr)
{
b.m_sleepTime=0.0;
minSleepTime=0.0
}
else
{
b.m_sleepTime+=step.dt;
minSleepTime=Box2D.Common.Math.b2Math.Min(minSleepTime,b.m_sleepTime)
}
}
if(minSleepTime>=Box2D.Common.b2Settings.b2_timeToSleep)
{
for(i=0;i<this.m_bodyCount;++i)
{
b=this.m_bodies[i];
b.SetAwake(false)
}
}
}
};
d.SolveTOI=function(subStep)
{
var i=0;
var j=0;
var contactSolver=null;
var b=null;
var translationX=0;
var translationY=0;
var rotation=0;
var k_toiBaumgarte=0;
var contactsOkay=false;
var jointsOkay=false;
var jointOkay=false;
i;
j;
this.m_contactSolver.Initialize(subStep,this.m_contacts,this.m_contactCount,this.m_allocator);
contactSolver=this.m_contactSolver;
for(i=0;i<this.m_jointCount;++i)
{
this.m_joints[i].InitVelocityConstraints(subStep)
}
for(i=0;i<subStep.velocityIterations;++i)
{
contactSolver.SolveVelocityConstraints();
for(j=0;j<this.m_jointCount;++j)
{
this.m_joints[j].SolveVelocityConstraints(subStep)
}
}
for(i=0;i<this.m_bodyCount;++i)
{
b=this.m_bodies[i];
if(b.GetType()==Box2D.Dynamics.b2Body.b2_staticBody)
{
continue
}
;translationX=subStep.dt*b.m_linearVelocity.x;
translationY=subStep.dt*b.m_linearVelocity.y;
if((translationX*translationX+translationY*translationY)>Box2D.Common.b2Settings.b2_maxTranslationSquared)
{
b.m_linearVelocity.Normalize();
b.m_linearVelocity.x*=Box2D.Common.b2Settings.b2_maxTranslation*subStep.inv_dt;
b.m_linearVelocity.y*=Box2D.Common.b2Settings.b2_maxTranslation*subStep.inv_dt
}
rotation=subStep.dt*b.m_angularVelocity;
if(rotation*rotation>Box2D.Common.b2Settings.b2_maxRotationSquared)
{
if(b.m_angularVelocity<0.0)
{
b.m_angularVelocity=-Box2D.Common.b2Settings.b2_maxRotation*subStep.inv_dt
}
else
{
b.m_angularVelocity=Box2D.Common.b2Settings.b2_maxRotation*subStep.inv_dt
}
}
b.m_sweep.c0.SetV(b.m_sweep.c);
b.m_sweep.a0=b.m_sweep.a;
b.m_sweep.c.x+=subStep.dt*b.m_linearVelocity.x;
b.m_sweep.c.y+=subStep.dt*b.m_linearVelocity.y;
b.m_sweep.a+=subStep.dt*b.m_angularVelocity;
b.SynchronizeTransform()
}
k_toiBaumgarte=0.75;
for(i=0;i<subStep.positionIterations;++i)
{
contactsOkay=contactSolver.SolvePositionConstraints(k_toiBaumgarte);
jointsOkay=true;
for(j=0;j<this.m_jointCount;++j)
{
jointOkay=this.m_joints[j].SolvePositionConstraints(Box2D.Common.b2Settings.b2_contactBaumgarte);
jointsOkay=jointsOkay&&jointOkay
}
if(contactsOkay&&jointsOkay)
{
break;
;
}
}
this.Report(contactSolver.m_constraints);
};
d.Report=function(constraints)
{
var i=0;
var c=null;
var cc=null;
var j=0;
if(this.m_listener==null)
{
return
}
for(i=0;i<this.m_contactCount;++i)
{
c=this.m_contacts[i];
cc=constraints[i];
for(j=0;j<cc.pointCount;++j)
{
Box2D.Dynamics.b2Island.s_impulse.normalImpulses[j]=cc.points[j].normalImpulse;
Box2D.Dynamics.b2Island.s_impulse.tangentImpulses[j]=cc.points[j].tangentImpulse
}
this.m_listener.PostSolve(c,Box2D.Dynamics.b2Island.s_impulse)
}
};
d.AddBody=function(body)
{
body.m_islandIndex=this.m_bodyCount;
this.m_bodies[this.m_bodyCount++]=body;
};
d.AddContact=function(contact)
{
this.m_contacts[this.m_contactCount++]=contact;
};
d.AddJoint=function(joint)
{
this.m_joints[this.m_jointCount++]=joint;
};
var s={};
s.__init__=function()
{
this.s_impulse=new Box2D.Dynamics.b2ContactImpulse();
};
flash.addDescription("Box2D.Dynamics.b2Island",d,null,s,null,["Box2D.Dynamics.b2ContactImpulse","Box2D.Dynamics.b2Body","Box2D.Dynamics.Contacts.b2Contact","Box2D.Dynamics.Joints.b2Joint","Box2D.Common.Math.b2Math","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.categoryBits=0;
d.maskBits=0;
d.groupIndex=0;
d.Copy=function()
{
var copy=null;
copy=new Box2D.Dynamics.b2FilterData();
copy.categoryBits=this.categoryBits;
copy.maskBits=this.maskBits;
copy.groupIndex=this.groupIndex;
return copy;
};
d.b2FilterData=function()
{
this.categoryBits=0x0001;
this.maskBits=0xFFFF;
};
flash.addDescription("Box2D.Dynamics.b2FilterData",d,null,null,null,["Box2D.Dynamics.b2FilterData"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_next=null;
d.m_prev=null;
d.m_world=null;
d.m_bodyList=null;
d.m_bodyCount=0;
d.Step=function(step)
{
};
d.Draw=function(debugDraw)
{
};
d.AddBody=function(body)
{
var edge=null;
edge=new Box2D.Dynamics.Controllers.b2ControllerEdge();
edge.controller=this;
edge.body=body;
edge.nextBody=this.m_bodyList;
edge.prevBody=null;
this.m_bodyList=edge;
if(edge.nextBody)
{
edge.nextBody.prevBody=edge
}
this.m_bodyCount++;
edge.nextController=body.m_controllerList;
edge.prevController=null;
body.m_controllerList=edge;
if(edge.nextController)
{
edge.nextController.prevController=edge
}
body.m_controllerCount++;
};
d.RemoveBody=function(body)
{
var edge=null;
edge=body.m_controllerList;
while(edge&&edge.controller!=this)
{
edge=edge.nextController
}
if(edge.prevBody)
{
edge.prevBody.nextBody=edge.nextBody
}
if(edge.nextBody)
{
edge.nextBody.prevBody=edge.prevBody
}
if(edge.nextController)
{
edge.nextController.prevController=edge.prevController
}
if(edge.prevController)
{
edge.prevController.nextController=edge.nextController
}
if(this.m_bodyList==edge)
{
this.m_bodyList=edge.nextBody
}
if(body.m_controllerList==edge)
{
body.m_controllerList=edge.nextController
}
body.m_controllerCount--;
this.m_bodyCount--;
};
d.Clear=function()
{
while(this.m_bodyList)
{
this.RemoveBody(this.m_bodyList.body)
}
};
d.GetNext=function()
{
return this.m_next;
};
d.GetWorld=function()
{
return this.m_world;
};
d.GetBodyList=function()
{
return this.m_bodyList;
};
d.b2Controller=function()
{
};
flash.addDescription("Box2D.Dynamics.Controllers.b2Controller",d,null,null,null,["Box2D.Dynamics.Controllers.b2ControllerEdge"]);
}
());;
(function()
{
"use strict";
var d={};
d.normal=null;
d.offset=0;
d.density=0;
d.velocity=null;
d.linearDrag=0;
d.angularDrag=0;
d.useDensity=false;
d.useWorldGravity=false;
d.gravity=null;
d.Step=function(step)
{
var i=null;
var body=null;
var areac=null;
var massc=null;
var area=0;
var mass=0;
var fixture=null;
var sc=null;
var sarea=0;
var shapeDensity=0;
var buoyancyForce=null;
var dragForce=null;
if(!this.m_bodyList)
{
return
}
if(this.useWorldGravity)
{
this.gravity=this.GetWorld().GetGravity().Copy()
}
for(i=this.m_bodyList;i;i=i.nextBody)
{
body=i.body;
if(body.IsAwake()==false)
{
continue;
;
}
areac=new Box2D.Common.Math.b2Vec2();
massc=new Box2D.Common.Math.b2Vec2();
area=0.0;
mass=0.0;
for(fixture=body.GetFixtureList();fixture;fixture=fixture.GetNext())
{
sc=new Box2D.Common.Math.b2Vec2();
sarea=fixture.GetShape().ComputeSubmergedArea(this.normal,this.offset,body.GetTransform(),sc);
area+=sarea;
areac.x+=sarea*sc.x;
areac.y+=sarea*sc.y;
shapeDensity;
if(this.useDensity)
{
shapeDensity=1
}
else
{
shapeDensity=1
}
mass+=sarea*shapeDensity;
massc.x+=sarea*sc.x*shapeDensity;
massc.y+=sarea*sc.y*shapeDensity
}
areac.x/=area;
areac.y/=area;
massc.x/=mass;
massc.y/=mass;
if(area<Number.MIN_VALUE)
{
continue
}
;buoyancyForce=this.gravity.GetNegative();
buoyancyForce.Multiply(this.density*area);
body.ApplyForce(buoyancyForce,massc);
dragForce=body.GetLinearVelocityFromWorldPoint(areac);
dragForce.Subtract(this.velocity);
dragForce.Multiply(-this.linearDrag*area);
body.ApplyForce(dragForce,areac);
body.ApplyTorque(-body.GetInertia()/body.GetMass()*area*body.GetAngularVelocity()*this.angularDrag)
}
};
d.Draw=function(debugDraw)
{
var r=0;
var p1=null;
var p2=null;
var color=null;
r=1000;
p1=new Box2D.Common.Math.b2Vec2();
p2=new Box2D.Common.Math.b2Vec2();
p1.x=this.normal.x*this.offset+this.normal.y*r;
p1.y=this.normal.y*this.offset-this.normal.x*r;
p2.x=this.normal.x*this.offset-this.normal.y*r;
p2.y=this.normal.y*this.offset+this.normal.x*r;
color=new Box2D.Common.b2Color(0,0,1);
debugDraw.DrawSegment(p1,p2,color);
};
d.b2BuoyancyController=function()
{
this.normal=new Box2D.Common.Math.b2Vec2(0,-1);
this.velocity=new Box2D.Common.Math.b2Vec2(0,0);
this.linearDrag=2;
this.angularDrag=1;
this.useWorldGravity=true;
this.b2Controller_constructor();
};
var s={};
s.__init__=function()
{
this.prototype.b2Controller_constructor=this.__base__;
};
flash.addDescription("Box2D.Dynamics.Controllers.b2BuoyancyController",d,"Box2D.Dynamics.Controllers.b2Controller",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.b2Color"]);
}
());;
(function()
{
"use strict";
var d={};
d.controller=null;
d.body=null;
d.prevBody=null;
d.nextBody=null;
d.prevController=null;
d.nextController=null;
d.b2ControllerEdge=function()
{
};
flash.addDescription("Box2D.Dynamics.Controllers.b2ControllerEdge",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.ShouldCollide=function(fixtureA,fixtureB)
{
var filter1=null;
var filter2=null;
var collide=false;
filter1=fixtureA.GetFilterData();
filter2=fixtureB.GetFilterData();
if(filter1.groupIndex==filter2.groupIndex&&filter1.groupIndex!=0)
{
return filter1.groupIndex>0
}
collide=(filter1.maskBits&filter2.categoryBits)!=0&&(filter1.categoryBits&filter2.maskBits)!=0;
return collide;
};
d.RayCollide=function(userData,fixture)
{
if(!userData)
{
return true
}
return this.ShouldCollide(userData,fixture);
};
d.b2ContactFilter=function()
{
};
var s={};
s.__init__=function()
{
this.b2_defaultFilter=new Box2D.Dynamics.b2ContactFilter();
};
flash.addDescription("Box2D.Dynamics.b2ContactFilter",d,null,s,null,["Box2D.Dynamics.b2ContactFilter","Box2D.Dynamics.b2Fixture"]);
}
());;
(function()
{
"use strict";
var d={};
d._r=0;
d._g=0;
d._b=0;
d.get_color=function()
{
return(this._r<<16)|(this._g<<8)|(this._b);
};
d.set_r=function(rr)
{
this._r=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(rr,0.0,1.0));
};
d.set_g=function(gg)
{
this._g=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(gg,0.0,1.0));
};
d.set_b=function(bb)
{
this._b=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(bb,0.0,1.0));
};
d.b2Color=function(rr,gg,bb)
{
this._r=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(rr,0.0,1.0));
this._g=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(gg,0.0,1.0));
this._b=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(bb,0.0,1.0));
};
d.Set=function(rr,gg,bb)
{
this._r=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(rr,0.0,1.0));
this._g=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(gg,0.0,1.0));
this._b=flash.uint(255*Box2D.Common.Math.b2Math.Clamp(bb,0.0,1.0));
};
flash.addDescription("Box2D.Common.b2Color",d,null,null,null,["Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.b2Settings=function()
{
};
var s={};
s.__init__=function()
{
this.VERSION="2.1alpha";
this.USHRT_MAX=0x0000ffff;
this.b2_pi=Math.PI;
this.b2_maxManifoldPoints=2;
this.b2_aabbExtension=0.1;
this.b2_aabbMultiplier=2.0;
this.b2_polygonRadius=2.0*Box2D.Common.b2Settings.b2_linearSlop;
this.b2_linearSlop=0.005;
this.b2_angularSlop=2.0/180.0*Box2D.Common.b2Settings.b2_pi;
this.b2_toiSlop=8.0*Box2D.Common.b2Settings.b2_linearSlop;
this.b2_maxTOIContactsPerIsland=32;
this.b2_maxTOIJointsPerIsland=32;
this.b2_velocityThreshold=1.0;
this.b2_maxLinearCorrection=0.2;
this.b2_maxAngularCorrection=8.0/180.0*Box2D.Common.b2Settings.b2_pi;
this.b2_maxTranslation=2.0;
this.b2_maxTranslationSquared=Box2D.Common.b2Settings.b2_maxTranslation*Box2D.Common.b2Settings.b2_maxTranslation;
this.b2_maxRotation=0.5*Box2D.Common.b2Settings.b2_pi;
this.b2_maxRotationSquared=Box2D.Common.b2Settings.b2_maxRotation*Box2D.Common.b2Settings.b2_maxRotation;
this.b2_contactBaumgarte=0.2;
this.b2_timeToSleep=0.5;
this.b2_linearSleepTolerance=0.01;
this.b2_angularSleepTolerance=2.0/180.0*Box2D.Common.b2Settings.b2_pi;
};
s.b2MixFriction=function(friction1,friction2)
{
return Math.sqrt(friction1*friction2);
};
s.b2MixRestitution=function(restitution1,restitution2)
{
return restitution1>restitution2?restitution1:restitution2;
};
s.b2Assert=function(a)
{
if(!a)
{
throw"Assertion Failed"
}
};
flash.addDescription("Box2D.Common.b2Settings",d,null,s,null,["Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.col1=null;
d.col2=null;
d.b2Mat22=function()
{
this.col1=new Box2D.Common.Math.b2Vec2();
this.col2=new Box2D.Common.Math.b2Vec2();
this.col1.x=this.col2.y=1.0;
};
d.Set=function(angle)
{
var c=0;
var s=0;
c=Math.cos(angle);
s=Math.sin(angle);
this.col1.x=c;
this.col2.x=-s;
this.col1.y=s;
this.col2.y=c;
};
d.SetVV=function(c1,c2)
{
this.col1.SetV(c1);
this.col2.SetV(c2);
};
d.Copy=function()
{
var mat=null;
mat=new Box2D.Common.Math.b2Mat22();
mat.SetM(this);
return mat;
};
d.SetM=function(m)
{
this.col1.SetV(m.col1);
this.col2.SetV(m.col2);
};
d.AddM=function(m)
{
this.col1.x+=m.col1.x;
this.col1.y+=m.col1.y;
this.col2.x+=m.col2.x;
this.col2.y+=m.col2.y;
};
d.SetIdentity=function()
{
this.col1.x=1.0;
this.col2.x=0.0;
this.col1.y=0.0;
this.col2.y=1.0;
};
d.SetZero=function()
{
this.col1.x=0.0;
this.col2.x=0.0;
this.col1.y=0.0;
this.col2.y=0.0;
};
d.GetAngle=function()
{
return Math.atan2(this.col1.y,this.col1.x);
};
d.GetInverse=function(out)
{
var a=0;
var b=0;
var c=0;
var d=0;
var det=0;
a=this.col1.x;
b=this.col2.x;
c=this.col1.y;
d=this.col2.y;
det=a*d-b*c;
if(det!=0.0)
{
det=1.0/det
}
out.col1.x=det*d;
out.col2.x=-det*b;
out.col1.y=-det*c;
out.col2.y=det*a;
return out;
};
d.Solve=function(out,bX,bY)
{
var a11=0;
var a12=0;
var a21=0;
var a22=0;
var det=0;
a11=this.col1.x;
a12=this.col2.x;
a21=this.col1.y;
a22=this.col2.y;
det=a11*a22-a12*a21;
if(det!=0.0)
{
det=1.0/det
}
out.x=det*(a22*bX-a12*bY);
out.y=det*(a11*bY-a21*bX);
return out;
};
d.Abs=function()
{
this.col1.Abs();
this.col2.Abs();
};
var s={};
s.FromAngle=function(angle)
{
var mat=null;
mat=new Box2D.Common.Math.b2Mat22();
mat.Set(angle);
return mat;
};
s.FromVV=function(c1,c2)
{
var mat=null;
mat=new Box2D.Common.Math.b2Mat22();
mat.SetVV(c1,c2);
return mat;
};
flash.addDescription("Box2D.Common.Math.b2Mat22",d,null,s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Mat22"]);
}
());;
(function()
{
"use strict";
var d={};
d.col1=null;
d.col2=null;
d.col3=null;
d.b2Mat33=function(c1,c2,c3)
{
this.col1=new Box2D.Common.Math.b2Vec3();
this.col2=new Box2D.Common.Math.b2Vec3();
this.col3=new Box2D.Common.Math.b2Vec3();
if(c1==undefined)c1=null;
if(c2==undefined)c2=null;
if(c3==undefined)c3=null;
if(!c1&&!c2&&!c3)
{
this.col1.SetZero();
this.col2.SetZero();
this.col3.SetZero()
}
else
{
this.col1.SetV(c1);
this.col2.SetV(c2);
this.col3.SetV(c3)
}
};
d.SetVVV=function(c1,c2,c3)
{
this.col1.SetV(c1);
this.col2.SetV(c2);
this.col3.SetV(c3);
};
d.Copy=function()
{
return new Box2D.Common.Math.b2Mat33(this.col1,this.col2,this.col3);
};
d.SetM=function(m)
{
this.col1.SetV(m.col1);
this.col2.SetV(m.col2);
this.col3.SetV(m.col3);
};
d.AddM=function(m)
{
this.col1.x+=m.col1.x;
this.col1.y+=m.col1.y;
this.col1.z+=m.col1.z;
this.col2.x+=m.col2.x;
this.col2.y+=m.col2.y;
this.col2.z+=m.col2.z;
this.col3.x+=m.col3.x;
this.col3.y+=m.col3.y;
this.col3.z+=m.col3.z;
};
d.SetIdentity=function()
{
this.col1.x=1.0;
this.col2.x=0.0;
this.col3.x=0.0;
this.col1.y=0.0;
this.col2.y=1.0;
this.col3.y=0.0;
this.col1.z=0.0;
this.col2.z=0.0;
this.col3.z=1.0;
};
d.SetZero=function()
{
this.col1.x=0.0;
this.col2.x=0.0;
this.col3.x=0.0;
this.col1.y=0.0;
this.col2.y=0.0;
this.col3.y=0.0;
this.col1.z=0.0;
this.col2.z=0.0;
this.col3.z=0.0;
};
d.Solve22=function(out,bX,bY)
{
var a11=0;
var a12=0;
var a21=0;
var a22=0;
var det=0;
a11=this.col1.x;
a12=this.col2.x;
a21=this.col1.y;
a22=this.col2.y;
det=a11*a22-a12*a21;
if(det!=0.0)
{
det=1.0/det
}
out.x=det*(a22*bX-a12*bY);
out.y=det*(a11*bY-a21*bX);
return out;
};
d.Solve33=function(out,bX,bY,bZ)
{
var a11=0;
var a21=0;
var a31=0;
var a12=0;
var a22=0;
var a32=0;
var a13=0;
var a23=0;
var a33=0;
var det=0;
a11=this.col1.x;
a21=this.col1.y;
a31=this.col1.z;
a12=this.col2.x;
a22=this.col2.y;
a32=this.col2.z;
a13=this.col3.x;
a23=this.col3.y;
a33=this.col3.z;
det=a11*(a22*a33-a32*a23)+a21*(a32*a13-a12*a33)+a31*(a12*a23-a22*a13);
if(det!=0.0)
{
det=1.0/det
}
out.x=det*(bX*(a22*a33-a32*a23)+bY*(a32*a13-a12*a33)+bZ*(a12*a23-a22*a13));
out.y=det*(a11*(bY*a33-bZ*a23)+a21*(bZ*a13-bX*a33)+a31*(bX*a23-bY*a13));
out.z=det*(a11*(a22*bZ-a32*bY)+a21*(a32*bX-a12*bZ)+a31*(a12*bY-a22*bX));
return out;
};
flash.addDescription("Box2D.Common.Math.b2Mat33",d,null,null,null,["Box2D.Common.Math.b2Vec3","Box2D.Common.Math.b2Mat33"]);
}
());;
(function()
{
"use strict";
var d={};
d.x=0;
d.y=0;
d.z=0;
d.b2Vec3=function(x,y,z)
{
if(x==undefined)x=0;
if(y==undefined)y=0;
if(z==undefined)z=0;
this.x=x;
this.y=y;
this.z=z;
};
d.SetZero=function()
{
this.x=this.y=this.z=0.0;
};
d.Set=function(x,y,z)
{
this.x=x;
this.y=y;
this.z=z;
};
d.SetV=function(v)
{
this.x=v.x;
this.y=v.y;
this.z=v.z;
};
d.GetNegative=function()
{
return new Box2D.Common.Math.b2Vec3(-this.x,-this.y,-this.z);
};
d.NegativeSelf=function()
{
this.x=-this.x;
this.y=-this.y;
this.z=-this.z;
};
d.Copy=function()
{
return new Box2D.Common.Math.b2Vec3(this.x,this.y,this.z);
};
d.Add=function(v)
{
this.x+=v.x;
this.y+=v.y;
this.z+=v.z;
};
d.Subtract=function(v)
{
this.x-=v.x;
this.y-=v.y;
this.z-=v.z;
};
d.Multiply=function(a)
{
this.x*=a;
this.y*=a;
this.z*=a;
};
flash.addDescription("Box2D.Common.Math.b2Vec3",d,null,null,null,["Box2D.Common.Math.b2Vec3"]);
}
());;
(function()
{
"use strict";
var d={};
d.b2Math=function()
{
};
var s={};
s.__init__=function()
{
this.b2Vec2_zero=new Box2D.Common.Math.b2Vec2(0.0,0.0);
this.b2Mat22_identity=Box2D.Common.Math.b2Mat22.FromVV(new Box2D.Common.Math.b2Vec2(1.0,0.0),new Box2D.Common.Math.b2Vec2(0.0,1.0));
this.b2Transform_identity=new Box2D.Common.Math.b2Transform(Box2D.Common.Math.b2Math.b2Vec2_zero,Box2D.Common.Math.b2Math.b2Mat22_identity);
};
s.IsValid=function(x)
{
return isFinite(x);
};
s.Dot=function(a,b)
{
return a.x*b.x+a.y*b.y;
};
s.CrossVV=function(a,b)
{
return a.x*b.y-a.y*b.x;
};
s.CrossVF=function(a,s)
{
var v=null;
v=new Box2D.Common.Math.b2Vec2(s*a.y,-s*a.x);
return v;
};
s.CrossFV=function(s,a)
{
var v=null;
v=new Box2D.Common.Math.b2Vec2(-s*a.y,s*a.x);
return v;
};
s.MulMV=function(A,v)
{
var u=null;
u=new Box2D.Common.Math.b2Vec2(A.col1.x*v.x+A.col2.x*v.y,A.col1.y*v.x+A.col2.y*v.y);
return u;
};
s.MulTMV=function(A,v)
{
var u=null;
u=new Box2D.Common.Math.b2Vec2(Box2D.Common.Math.b2Math.Dot(v,A.col1),Box2D.Common.Math.b2Math.Dot(v,A.col2));
return u;
};
s.MulX=function(T,v)
{
var a=null;
a=Box2D.Common.Math.b2Math.MulMV(T.R,v);
a.x+=T.position.x;
a.y+=T.position.y;
return a;
};
s.MulXT=function(T,v)
{
var a=null;
var tX=0;
a=Box2D.Common.Math.b2Math.SubtractVV(v,T.position);
tX=(a.x*T.R.col1.x+a.y*T.R.col1.y);
a.y=(a.x*T.R.col2.x+a.y*T.R.col2.y);
a.x=tX;
return a;
};
s.AddVV=function(a,b)
{
var v=null;
v=new Box2D.Common.Math.b2Vec2(a.x+b.x,a.y+b.y);
return v;
};
s.SubtractVV=function(a,b)
{
var v=null;
v=new Box2D.Common.Math.b2Vec2(a.x-b.x,a.y-b.y);
return v;
};
s.Distance=function(a,b)
{
var cX=0;
var cY=0;
cX=a.x-b.x;
cY=a.y-b.y;
return Math.sqrt(cX*cX+cY*cY);
};
s.DistanceSquared=function(a,b)
{
var cX=0;
var cY=0;
cX=a.x-b.x;
cY=a.y-b.y;
return(cX*cX+cY*cY);
};
s.MulFV=function(s,a)
{
var v=null;
v=new Box2D.Common.Math.b2Vec2(s*a.x,s*a.y);
return v;
};
s.AddMM=function(A,B)
{
var C=null;
C=Box2D.Common.Math.b2Mat22.FromVV(Box2D.Common.Math.b2Math.AddVV(A.col1,B.col1),Box2D.Common.Math.b2Math.AddVV(A.col2,B.col2));
return C;
};
s.MulMM=function(A,B)
{
var C=null;
C=Box2D.Common.Math.b2Mat22.FromVV(Box2D.Common.Math.b2Math.MulMV(A,B.col1),Box2D.Common.Math.b2Math.MulMV(A,B.col2));
return C;
};
s.MulTMM=function(A,B)
{
var c1=null;
var c2=null;
var C=null;
c1=new Box2D.Common.Math.b2Vec2(Box2D.Common.Math.b2Math.Dot(A.col1,B.col1),Box2D.Common.Math.b2Math.Dot(A.col2,B.col1));
c2=new Box2D.Common.Math.b2Vec2(Box2D.Common.Math.b2Math.Dot(A.col1,B.col2),Box2D.Common.Math.b2Math.Dot(A.col2,B.col2));
C=Box2D.Common.Math.b2Mat22.FromVV(c1,c2);
return C;
};
s.Abs=function(a)
{
return a>0.0?a:-a;
};
s.AbsV=function(a)
{
var b=null;
b=new Box2D.Common.Math.b2Vec2(Box2D.Common.Math.b2Math.Abs(a.x),Box2D.Common.Math.b2Math.Abs(a.y));
return b;
};
s.AbsM=function(A)
{
var B=null;
B=Box2D.Common.Math.b2Mat22.FromVV(Box2D.Common.Math.b2Math.AbsV(A.col1),Box2D.Common.Math.b2Math.AbsV(A.col2));
return B;
};
s.Min=function(a,b)
{
return a<b?a:b;
};
s.MinV=function(a,b)
{
var c=null;
c=new Box2D.Common.Math.b2Vec2(Box2D.Common.Math.b2Math.Min(a.x,b.x),Box2D.Common.Math.b2Math.Min(a.y,b.y));
return c;
};
s.Max=function(a,b)
{
return a>b?a:b;
};
s.MaxV=function(a,b)
{
var c=null;
c=new Box2D.Common.Math.b2Vec2(Box2D.Common.Math.b2Math.Max(a.x,b.x),Box2D.Common.Math.b2Math.Max(a.y,b.y));
return c;
};
s.Clamp=function(a,low,high)
{
return a<low?low:a>high?high:a;
};
s.ClampV=function(a,low,high)
{
return Box2D.Common.Math.b2Math.MaxV(low,Box2D.Common.Math.b2Math.MinV(a,high));
};
s.Swap=function(a,b)
{
var tmp=null;
tmp=a[0];
a[0]=b[0];
b[0]=tmp;
};
s.Random=function()
{
return Math.random()*2-1;
};
s.RandomRange=function(lo,hi)
{
var r=0;
r=Math.random();
r=(hi-lo)*r+lo;
return r;
};
s.NextPowerOfTwo=function(x)
{
x=flash.uint(x);
x|=(x>>1)&0x7FFFFFFF;
x|=(x>>2)&0x3FFFFFFF;
x|=(x>>4)&0x0FFFFFFF;
x|=(x>>8)&0x00FFFFFF;
x|=(x>>16)&0x0000FFFF;
return x+1;
};
s.IsPowerOfTwo=function(x)
{
x=flash.uint(x);
var result=false;
result=x>0&&(x&(x-1))==0;
return result;
};
flash.addDescription("Box2D.Common.Math.b2Math",d,null,s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Mat22","Box2D.Common.Math.b2Transform"]);
}
());;
(function()
{
"use strict";
var d={};
d.localCenter=null;
d.c0=null;
d.c=null;
d.a0=0;
d.a=0;
d.t0=0;
d.Set=function(other)
{
this.localCenter.SetV(other.localCenter);
this.c0.SetV(other.c0);
this.c.SetV(other.c);
this.a0=other.a0;
this.a=other.a;
this.t0=other.t0;
};
d.Copy=function()
{
var copy=null;
copy=new Box2D.Common.Math.b2Sweep();
copy.localCenter.SetV(this.localCenter);
copy.c0.SetV(this.c0);
copy.c.SetV(this.c);
copy.a0=this.a0;
copy.a=this.a;
copy.t0=this.t0;
return copy;
};
d.GetTransform=function(xf,alpha)
{
var angle=0;
var tMat=null;
xf.position.x=(1.0-alpha)*this.c0.x+alpha*this.c.x;
xf.position.y=(1.0-alpha)*this.c0.y+alpha*this.c.y;
angle=(1.0-alpha)*this.a0+alpha*this.a;
xf.R.Set(angle);
tMat=xf.R;
xf.position.x-=(tMat.col1.x*this.localCenter.x+tMat.col2.x*this.localCenter.y);
xf.position.y-=(tMat.col1.y*this.localCenter.x+tMat.col2.y*this.localCenter.y);
};
d.Advance=function(t)
{
var alpha=0;
if(this.t0<t&&1.0-this.t0>Number.MIN_VALUE)
{
alpha=(t-this.t0)/(1.0-this.t0);
this.c0.x=(1.0-alpha)*this.c0.x+alpha*this.c.x;
this.c0.y=(1.0-alpha)*this.c0.y+alpha*this.c.y;
this.a0=(1.0-alpha)*this.a0+alpha*this.a;
this.t0=t
}
};
d.b2Sweep=function()
{
this.localCenter=new Box2D.Common.Math.b2Vec2();
this.c0=new Box2D.Common.Math.b2Vec2;
this.c=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Common.Math.b2Sweep",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Sweep"]);
}
());;
(function()
{
"use strict";
var d={};
d.position=null;
d.R=null;
d.b2Transform=function(pos,r)
{
this.position=new Box2D.Common.Math.b2Vec2;
this.R=new Box2D.Common.Math.b2Mat22();
if(pos==undefined)pos=null;
if(r==undefined)r=null;
if(pos)
{
this.position.SetV(pos);
this.R.SetM(r)
}
};
d.Initialize=function(pos,r)
{
this.position.SetV(pos);
this.R.SetM(r);
};
d.SetIdentity=function()
{
this.position.SetZero();
this.R.SetIdentity();
};
d.Set=function(x)
{
this.position.SetV(x.position);
this.R.SetM(x.R);
};
d.GetAngle=function()
{
return Math.atan2(this.R.col1.y,this.R.col1.x);
};
flash.addDescription("Box2D.Common.Math.b2Transform",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Mat22"]);
}
());;
(function()
{
"use strict";
var d={};
d.x=0;
d.y=0;
d.b2Vec2=function(x_,y_)
{
if(x_==undefined)x_=0;
if(y_==undefined)y_=0;
this.x=x_;
this.y=y_;
};
d.SetZero=function()
{
this.x=0.0;
this.y=0.0;
};
d.Set=function(x_,y_)
{
if(x_==undefined)x_=0;
if(y_==undefined)y_=0;
this.x=x_;
this.y=y_;
};
d.SetV=function(v)
{
this.x=v.x;
this.y=v.y;
};
d.GetNegative=function()
{
return new Box2D.Common.Math.b2Vec2(-this.x,-this.y);
};
d.NegativeSelf=function()
{
this.x=-this.x;
this.y=-this.y;
};
d.Copy=function()
{
return new Box2D.Common.Math.b2Vec2(this.x,this.y);
};
d.Add=function(v)
{
this.x+=v.x;
this.y+=v.y;
};
d.Subtract=function(v)
{
this.x-=v.x;
this.y-=v.y;
};
d.Multiply=function(a)
{
this.x*=a;
this.y*=a;
};
d.MulM=function(A)
{
var tX=0;
tX=this.x;
this.x=A.col1.x*tX+A.col2.x*this.y;
this.y=A.col1.y*tX+A.col2.y*this.y;
};
d.MulTM=function(A)
{
var tX=0;
tX=Box2D.Common.Math.b2Math.Dot(this,A.col1);
this.y=Box2D.Common.Math.b2Math.Dot(this,A.col2);
this.x=tX;
};
d.CrossVF=function(s)
{
var tX=0;
tX=this.x;
this.x=s*this.y;
this.y=-s*tX;
};
d.CrossFV=function(s)
{
var tX=0;
tX=this.x;
this.x=-s*this.y;
this.y=s*tX;
};
d.MinV=function(b)
{
this.x=this.x<b.x?this.x:b.x;
this.y=this.y<b.y?this.y:b.y;
};
d.MaxV=function(b)
{
this.x=this.x>b.x?this.x:b.x;
this.y=this.y>b.y?this.y:b.y;
};
d.Abs=function()
{
if(this.x<0)
{
this.x=-this.x
}
if(this.y<0)
{
this.y=-this.y
}
};
d.Length=function()
{
return Math.sqrt(this.x*this.x+this.y*this.y);
};
d.LengthSquared=function()
{
return(this.x*this.x+this.y*this.y);
};
d.Normalize=function()
{
var length=0;
var invLength=0;
length=Math.sqrt(this.x*this.x+this.y*this.y);
if(length<Number.MIN_VALUE)
{
return 0.0
}
invLength=1.0/length;
this.x*=invLength;
this.y*=invLength;
return length;
};
d.IsValid=function()
{
return Box2D.Common.Math.b2Math.IsValid(this.x)&&Box2D.Common.Math.b2Math.IsValid(this.y);
};
var s={};
s.Make=function(x_,y_)
{
return new Box2D.Common.Math.b2Vec2(x_,y_);
};
flash.addDescription("Box2D.Common.Math.b2Vec2",d,null,s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.features=null;
d._key=0;
d.get_key=function()
{
return this._key;
};
d.set_key=function(value)
{
value=flash.uint(value);
this._key=value;
this.features._referenceEdge=this._key&0x000000ff;
this.features._incidentEdge=((this._key&0x0000ff00)>>8)&0x000000ff;
this.features._incidentVertex=((this._key&0x00ff0000)>>16)&0x000000ff;
this.features._flip=((this._key&0xff000000)>>24)&0x000000ff;
};
d.b2ContactID=function()
{
this.features=new Box2D.Collision.Features();
this.features._m_id=this;
};
d.Set=function(id)
{
this.set_key(id._key);
};
d.Copy=function()
{
var id=null;
id=new Box2D.Collision.b2ContactID();
id.set_key(this.get_key());
return id;
};
flash.addDescription("Box2D.Collision.b2ContactID",d,null,null,null,["Box2D.Collision.Features","Box2D.Collision.b2ContactID"]);
}
());;
(function()
{
"use strict";
var d={};
d.pointA=null;
d.pointB=null;
d.distance=0;
d.iterations=0;
d.b2DistanceOutput=function()
{
this.pointA=new Box2D.Common.Math.b2Vec2();
this.pointB=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Collision.b2DistanceOutput",d,null,null,null,["Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.metric=0;
d.count=0;
d.indexA=null;
d.indexB=null;
d.b2SimplexCache=function()
{
this.indexA=new Array();
this.indexB=new Array();
};
flash.addDescription("Box2D.Collision.b2SimplexCache",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.lowerBound=null;
d.upperBound=null;
d.IsValid=function()
{
var dX=0;
var dY=0;
var valid=false;
dX=this.upperBound.x-this.lowerBound.x;
dY=this.upperBound.y-this.lowerBound.y;
valid=dX>=0.0&&dY>=0.0;
valid=valid&&this.lowerBound.IsValid()&&this.upperBound.IsValid();
return valid;
};
d.GetCenter=function()
{
return new Box2D.Common.Math.b2Vec2((this.lowerBound.x+this.upperBound.x)/2,(this.lowerBound.y+this.upperBound.y)/2);
};
d.GetExtents=function()
{
return new Box2D.Common.Math.b2Vec2((this.upperBound.x-this.lowerBound.x)/2,(this.upperBound.y-this.lowerBound.y)/2);
};
d.Contains=function(aabb)
{
return this.lowerBound.x<=aabb.lowerBound.x&&this.lowerBound.y<=aabb.lowerBound.y&&aabb.upperBound.x<=this.upperBound.x&&aabb.upperBound.y<=this.upperBound.y;
};
d.RayCast=function(output,input)
{
var tmin=0;
var tmax=0;
var pX=0;
var pY=0;
var dX=0;
var dY=0;
var absDX=0;
var absDY=0;
var normal=null;
var inv_d=0;
var t1=0;
var t2=0;
var t3=0;
var s=0;
tmin=-Number.MAX_VALUE;
tmax=Number.MAX_VALUE;
pX=input.p1.x;
pY=input.p1.y;
dX=input.p2.x-input.p1.x;
dY=input.p2.y-input.p1.y;
absDX=Math.abs(dX);
absDY=Math.abs(dY);
normal=output.normal;
inv_d;
t1;
t2;
t3;
s;
{
if(absDX<Number.MIN_VALUE)
{
if(pX<this.lowerBound.x||this.upperBound.x<pX)
{
return false
}
}
else
{
inv_d=1.0/dX;
t1=(this.lowerBound.x-pX)*inv_d;
t2=(this.upperBound.x-pX)*inv_d;
s=-1.0;
if(t1>t2)
{
t3=t1;
t1=t2;
t2=t3;
s=1.0
}
if(t1>tmin)
{
normal.x=s;
normal.y=0;
tmin=t1
}
tmax=Math.min(tmax,t2);
if(tmin>tmax)
{
return false
}
}
};
{
if(absDY<Number.MIN_VALUE)
{
if(pY<this.lowerBound.y||this.upperBound.y<pY)
{
return false
}
}
else
{
inv_d=1.0/dY;
t1=(this.lowerBound.y-pY)*inv_d;
t2=(this.upperBound.y-pY)*inv_d;
s=-1.0;
if(t1>t2)
{
t3=t1;
t1=t2;
t2=t3;
s=1.0
}
if(t1>tmin)
{
normal.y=s;
normal.x=0;
tmin=t1
}
tmax=Math.min(tmax,t2);
if(tmin>tmax)
{
return false
}
}
};
output.fraction=tmin;
return true;
};
d.TestOverlap=function(other)
{
var d1X=0;
var d1Y=0;
var d2X=0;
var d2Y=0;
d1X=other.lowerBound.x-this.upperBound.x;
d1Y=other.lowerBound.y-this.upperBound.y;
d2X=this.lowerBound.x-other.upperBound.x;
d2Y=this.lowerBound.y-other.upperBound.y;
if(d1X>0.0||d1Y>0.0)
{
return false
}
if(d2X>0.0||d2Y>0.0)
{
return false
}
return true;
};
d.Combine=function(aabb1,aabb2)
{
this.lowerBound.x=Math.min(aabb1.lowerBound.x,aabb2.lowerBound.x);
this.lowerBound.y=Math.min(aabb1.lowerBound.y,aabb2.lowerBound.y);
this.upperBound.x=Math.max(aabb1.upperBound.x,aabb2.upperBound.x);
this.upperBound.y=Math.max(aabb1.upperBound.y,aabb2.upperBound.y);
};
d.b2AABB=function()
{
this.lowerBound=new Box2D.Common.Math.b2Vec2();
this.upperBound=new Box2D.Common.Math.b2Vec2();
};
var s={};
s.Combine=function(aabb1,aabb2)
{
var aabb=null;
aabb=new Box2D.Collision.b2AABB();
aabb.Combine(aabb1,aabb2);
return aabb;
};
flash.addDescription("Box2D.Collision.b2AABB",d,null,s,null,["Box2D.Common.Math.b2Vec2","Box2D.Collision.b2AABB"]);
}
());;
(function()
{
"use strict";
var d={};
d.proxyA=null;
d.proxyB=null;
d.sweepA=null;
d.sweepB=null;
d.tolerance=0;
d.b2TOIInput=function()
{
this.proxyA=new Box2D.Collision.b2DistanceProxy();
this.proxyB=new Box2D.Collision.b2DistanceProxy();
this.sweepA=new Box2D.Common.Math.b2Sweep();
this.sweepB=new Box2D.Common.Math.b2Sweep();
};
flash.addDescription("Box2D.Collision.b2TOIInput",d,null,null,null,["Box2D.Collision.b2DistanceProxy","Box2D.Common.Math.b2Sweep"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_localPoint=null;
d.m_normalImpulse=0;
d.m_tangentImpulse=0;
d.m_id=null;
d.b2ManifoldPoint=function()
{
this.m_localPoint=new Box2D.Common.Math.b2Vec2();
this.m_id=new Box2D.Collision.b2ContactID();
this.Reset();
};
d.Reset=function()
{
this.m_localPoint.SetZero();
this.m_normalImpulse=0.0;
this.m_tangentImpulse=0.0;
this.m_id.set_key(0);
};
d.Set=function(m)
{
this.m_localPoint.SetV(m.m_localPoint);
this.m_normalImpulse=m.m_normalImpulse;
this.m_tangentImpulse=m.m_tangentImpulse;
this.m_id.Set(m.m_id);
};
flash.addDescription("Box2D.Collision.b2ManifoldPoint",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Collision.b2ContactID"]);
}
());;
(function()
{
"use strict";
var d={};
d.CreateProxy=function(aabb,userData)
{
};
d.DestroyProxy=function(proxy)
{
};
d.MoveProxy=function(proxy,aabb,displacement)
{
};
d.TestOverlap=function(proxyA,proxyB)
{
};
d.GetUserData=function(proxy)
{
};
d.GetFatAABB=function(proxy)
{
};
d.GetProxyCount=function()
{
};
d.UpdatePairs=function(callback)
{
};
d.Query=function(callback,aabb)
{
};
d.RayCast=function(callback,input)
{
};
d.Validate=function()
{
};
d.Rebalance=function(iterations)
{
};
d.IBroadPhase=function()
{
};
flash.addDescription("Box2D.Collision.IBroadPhase",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.b2TimeOfImpact=function()
{
};
var s={};
s.__init__=function()
{
this.b2_toiCalls=0;
this.b2_toiIters=0;
this.b2_toiMaxIters=0;
this.b2_toiRootIters=0;
this.b2_toiMaxRootIters=0;
this.s_cache=new Box2D.Collision.b2SimplexCache();
this.s_distanceInput=new Box2D.Collision.b2DistanceInput();
this.s_xfA=new Box2D.Common.Math.b2Transform();
this.s_xfB=new Box2D.Common.Math.b2Transform();
this.s_fcn=new Box2D.Collision.b2SeparationFunction();
this.s_distanceOutput=new Box2D.Collision.b2DistanceOutput();
};
s.TimeOfImpact=function(input)
{
var proxyA=null;
var proxyB=null;
var sweepA=null;
var sweepB=null;
var radius=0;
var tolerance=0;
var alpha=0;
var k_maxIterations=0;
var iter=0;
var target=0;
var separation=0;
var newAlpha=0;
var x1=0;
var x2=0;
var f1=0;
var f2=0;
var rootIterCount=0;
var x=0;
var f=0;
++Box2D.Collision.b2TimeOfImpact.b2_toiCalls;
proxyA=input.proxyA;
proxyB=input.proxyB;
sweepA=input.sweepA;
sweepB=input.sweepB;
Box2D.Common.b2Settings.b2Assert(sweepA.t0==sweepB.t0);
Box2D.Common.b2Settings.b2Assert(1.0-sweepA.t0>Number.MIN_VALUE);
radius=proxyA.m_radius+proxyB.m_radius;
tolerance=input.tolerance;
alpha=0.0;
k_maxIterations=1000;
iter=0;
target=0.0;
Box2D.Collision.b2TimeOfImpact.s_cache.count=0;
Box2D.Collision.b2TimeOfImpact.s_distanceInput.useRadii=false;
while(true)
{
sweepA.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfA,alpha);
sweepB.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfB,alpha);
Box2D.Collision.b2TimeOfImpact.s_distanceInput.proxyA=proxyA;
Box2D.Collision.b2TimeOfImpact.s_distanceInput.proxyB=proxyB;
Box2D.Collision.b2TimeOfImpact.s_distanceInput.transformA=Box2D.Collision.b2TimeOfImpact.s_xfA;
Box2D.Collision.b2TimeOfImpact.s_distanceInput.transformB=Box2D.Collision.b2TimeOfImpact.s_xfB;
Box2D.Collision.b2Distance.Distance(Box2D.Collision.b2TimeOfImpact.s_distanceOutput,Box2D.Collision.b2TimeOfImpact.s_cache,Box2D.Collision.b2TimeOfImpact.s_distanceInput);
if(Box2D.Collision.b2TimeOfImpact.s_distanceOutput.distance<=0.0)
{
alpha=1.0;
break;
;
}
Box2D.Collision.b2TimeOfImpact.s_fcn.Initialize(Box2D.Collision.b2TimeOfImpact.s_cache,proxyA,Box2D.Collision.b2TimeOfImpact.s_xfA,proxyB,Box2D.Collision.b2TimeOfImpact.s_xfB);
separation=Box2D.Collision.b2TimeOfImpact.s_fcn.Evaluate(Box2D.Collision.b2TimeOfImpact.s_xfA,Box2D.Collision.b2TimeOfImpact.s_xfB);
if(separation<=0.0)
{
alpha=1.0;
break;
;
}
if(iter==0)
{
if(separation>radius)
{
target=Box2D.Common.Math.b2Math.Max(radius-tolerance,0.75*radius)
}
else
{
target=Box2D.Common.Math.b2Math.Max(separation-tolerance,0.02*radius)
}
}
if(separation-target<0.5*tolerance)
{
if(iter==0)
{
alpha=1.0;
break;
;
}
break;
;
}
newAlpha=alpha;
{
x1=alpha;
x2=1.0;
f1=separation;
sweepA.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfA,x2);
sweepB.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfB,x2);
f2=Box2D.Collision.b2TimeOfImpact.s_fcn.Evaluate(Box2D.Collision.b2TimeOfImpact.s_xfA,Box2D.Collision.b2TimeOfImpact.s_xfB);
if(f2>=target)
{
alpha=1.0;
break;
;
}
rootIterCount=0;
while(true)
{
x;
if(rootIterCount&1)
{
x=x1+(target-f1)*(x2-x1)/(f2-f1)
}
else
{
x=0.5*(x1+x2)
}
sweepA.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfA,x);
sweepB.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfB,x);
f=Box2D.Collision.b2TimeOfImpact.s_fcn.Evaluate(Box2D.Collision.b2TimeOfImpact.s_xfA,Box2D.Collision.b2TimeOfImpact.s_xfB);
if(Box2D.Common.Math.b2Math.Abs(f-target)<0.025*tolerance)
{
newAlpha=x;
break;
;
}
if(f>target)
{
x1=x;
f1=f
}
else
{
x2=x;
f2=f
}
;++rootIterCount;
++Box2D.Collision.b2TimeOfImpact.b2_toiRootIters;
if(rootIterCount==50)
{
break;
;
}
}
Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters=flash.int(Box2D.Common.Math.b2Math.Max(Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters,rootIterCount))
};
if(newAlpha<(1.0+100.0*Number.MIN_VALUE)*alpha)
{
break;
;
}
alpha=newAlpha;
iter++;
++Box2D.Collision.b2TimeOfImpact.b2_toiIters;
if(iter==k_maxIterations)
{
break;
;
}
}
Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters=flash.int(Box2D.Common.Math.b2Math.Max(Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters,iter));
return alpha;
};
flash.addDescription("Box2D.Collision.b2TimeOfImpact",d,null,s,null,["Box2D.Collision.b2SimplexCache","Box2D.Collision.b2DistanceInput","Box2D.Common.Math.b2Transform","Box2D.Collision.b2SeparationFunction","Box2D.Collision.b2DistanceOutput","Box2D.Common.b2Settings","Box2D.Collision.b2Distance","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.p1=null;
d.p2=null;
d.maxFraction=0;
d.b2RayCastInput=function(p1,p2,maxFraction)
{
this.p1=new Box2D.Common.Math.b2Vec2();
this.p2=new Box2D.Common.Math.b2Vec2();
if(p1==undefined)p1=null;
if(p2==undefined)p2=null;
if(maxFraction==undefined)maxFraction=1;
if(p1)
{
this.p1.SetV(p1)
}
if(p2)
{
this.p2.SetV(p2)
}
this.maxFraction=maxFraction;
};
flash.addDescription("Box2D.Collision.b2RayCastInput",d,null,null,null,["Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.v=null;
d.id=null;
d.Set=function(other)
{
this.v.SetV(other.v);
this.id.Set(other.id);
};
d.ClipVertex=function()
{
this.v=new Box2D.Common.Math.b2Vec2();
this.id=new Box2D.Collision.b2ContactID();
};
flash.addDescription("Box2D.Collision.ClipVertex",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Collision.b2ContactID"]);
}
());;
(function()
{
"use strict";
var d={};
d.wA=null;
d.wB=null;
d.w=null;
d.a=0;
d.indexA=0;
d.indexB=0;
d.Set=function(other)
{
this.wA.SetV(other.wA);
this.wB.SetV(other.wB);
this.w.SetV(other.w);
this.a=other.a;
this.indexA=other.indexA;
this.indexB=other.indexB;
};
d.b2SimplexVertex=function()
{
};
flash.addDescription("Box2D.Collision.b2SimplexVertex",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.m_normal=null;
d.m_points=null;
d.b2WorldManifold=function()
{
this.m_normal=new Box2D.Common.Math.b2Vec2();
var i=0;
this.m_points=new Array();
this.m_points.length=Box2D.Common.b2Settings.b2_maxManifoldPoints;
for(i=0;i<Box2D.Common.b2Settings.b2_maxManifoldPoints;i++)
{
this.m_points[i]=new Box2D.Common.Math.b2Vec2()
}
};
d.Initialize=function(manifold,xfA,radiusA,xfB,radiusB)
{
var i=0;
var tVec=null;
var tMat=null;
var normalX=0;
var normalY=0;
var planePointX=0;
var planePointY=0;
var clipPointX=0;
var clipPointY=0;
var pointAX=0;
var pointAY=0;
var pointBX=0;
var pointBY=0;
var dX=0;
var dY=0;
var d2=0;
var d=0;
var cAX=0;
var cAY=0;
var cBX=0;
var cBY=0;
if(manifold.m_pointCount==0)
{
return
}
i;
tVec;
tMat;
normalX;
normalY;
planePointX;
planePointY;
clipPointX;
clipPointY;
switch(manifold.m_type)
{
case Box2D.Collision.b2Manifold.e_circles:
{
tMat=xfA.R;
tVec=manifold.m_localPoint;
pointAX=xfA.position.x+tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
pointAY=xfA.position.y+tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tMat=xfB.R;
tVec=manifold.m_points[0].m_localPoint;
pointBX=xfB.position.x+tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
pointBY=xfB.position.y+tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
dX=pointBX-pointAX;
dY=pointBY-pointAY;
d2=dX*dX+dY*dY;
if(d2>Number.MIN_VALUE*Number.MIN_VALUE)
{
d=Math.sqrt(d2);
this.m_normal.x=dX/d;
this.m_normal.y=dY/d
}
else
{
this.m_normal.x=1;
this.m_normal.y=0
}
cAX=pointAX+radiusA*this.m_normal.x;
cAY=pointAY+radiusA*this.m_normal.y;
cBX=pointBX-radiusB*this.m_normal.x;
cBY=pointBY-radiusB*this.m_normal.y;
this.m_points[0].x=0.5*(cAX+cBX);
this.m_points[0].y=0.5*(cAY+cBY)
};
break;
;case Box2D.Collision.b2Manifold.e_faceA:
{
tMat=xfA.R;
tVec=manifold.m_localPlaneNormal;
normalX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
normalY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tMat=xfA.R;
tVec=manifold.m_localPoint;
planePointX=xfA.position.x+tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
planePointY=xfA.position.y+tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
this.m_normal.x=normalX;
this.m_normal.y=normalY;
for(i=0;i<manifold.m_pointCount;i++)
{
tMat=xfB.R;
tVec=manifold.m_points[i].m_localPoint;
clipPointX=xfB.position.x+tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
clipPointY=xfB.position.y+tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
this.m_points[i].x=clipPointX+0.5*(radiusA-(clipPointX-planePointX)*normalX-(clipPointY-planePointY)*normalY-radiusB)*normalX;
this.m_points[i].y=clipPointY+0.5*(radiusA-(clipPointX-planePointX)*normalX-(clipPointY-planePointY)*normalY-radiusB)*normalY
}
};
break;
;case Box2D.Collision.b2Manifold.e_faceB:
{
tMat=xfB.R;
tVec=manifold.m_localPlaneNormal;
normalX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
normalY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tMat=xfB.R;
tVec=manifold.m_localPoint;
planePointX=xfB.position.x+tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
planePointY=xfB.position.y+tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
this.m_normal.x=-normalX;
this.m_normal.y=-normalY;
for(i=0;i<manifold.m_pointCount;i++)
{
tMat=xfA.R;
tVec=manifold.m_points[i].m_localPoint;
clipPointX=xfA.position.x+tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
clipPointY=xfA.position.y+tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
this.m_points[i].x=clipPointX+0.5*(radiusB-(clipPointX-planePointX)*normalX-(clipPointY-planePointY)*normalY-radiusA)*normalX;
this.m_points[i].y=clipPointY+0.5*(radiusB-(clipPointX-planePointX)*normalX-(clipPointY-planePointY)*normalY-radiusA)*normalY
}
};
break;
;
}
};
flash.addDescription("Box2D.Collision.b2WorldManifold",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.b2Settings","Box2D.Collision.b2Manifold"]);
}
());;
(function()
{
"use strict";
var d={};
d.shape1=null;
d.shape2=null;
d.position=null;
d.velocity=null;
d.normal=null;
d.separation=0;
d.friction=0;
d.restitution=0;
d.id=null;
d.b2ContactPoint=function()
{
this.position=new Box2D.Common.Math.b2Vec2();
this.velocity=new Box2D.Common.Math.b2Vec2();
this.normal=new Box2D.Common.Math.b2Vec2();
this.id=new Box2D.Collision.b2ContactID();
};
flash.addDescription("Box2D.Collision.b2ContactPoint",d,null,null,null,["Box2D.Common.Math.b2Vec2","Box2D.Collision.b2ContactID"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_tree=null;
d.m_proxyCount=0;
d.m_moveBuffer=null;
d.m_pairBuffer=null;
d.m_pairCount=0;
d.CreateProxy=function(aabb,userData)
{
var proxy=null;
proxy=this.m_tree.CreateProxy(aabb,userData);
++this.m_proxyCount;
this.BufferMove(proxy);
return proxy;
};
d.DestroyProxy=function(proxy)
{
this.UnBufferMove(proxy);
--this.m_proxyCount;
this.m_tree.DestroyProxy(proxy);
};
d.MoveProxy=function(proxy,aabb,displacement)
{
var buffer=false;
buffer=this.m_tree.MoveProxy(proxy,aabb,displacement);
if(buffer)
{
this.BufferMove(proxy)
}
};
d.TestOverlap=function(proxyA,proxyB)
{
var aabbA=null;
var aabbB=null;
aabbA=this.m_tree.GetFatAABB(proxyA);
aabbB=this.m_tree.GetFatAABB(proxyB);
return aabbA.TestOverlap(aabbB);
};
d.GetUserData=function(proxy)
{
return this.m_tree.GetUserData(proxy);
};
d.GetFatAABB=function(proxy)
{
return this.m_tree.GetFatAABB(proxy);
};
d.GetProxyCount=function()
{
return this.m_proxyCount;
};
d.UpdatePairs=function(callback)
{
var queryProxy=null;
var QueryCallback=null;
var fatAABB=null;
var i=0;
var primaryPair=null;
var userDataA=null;
var userDataB=null;
var pair=null;
var t0=null;
this.m_pairCount=0;
for(t0 in this.m_moveBuffer)
{
queryProxy=this.m_moveBuffer[t0];
QueryCallback=flash.bindFunction(this,function(proxy)
{
var pair=null;
if(proxy==queryProxy)
{
return true
}
if(this.m_pairCount==this.m_pairBuffer.length)
{
this.m_pairBuffer[this.m_pairCount]=new Box2D.Collision.b2DynamicTreePair()
}
pair=this.m_pairBuffer[this.m_pairCount];
pair.proxyA=proxy<queryProxy?proxy:queryProxy;
pair.proxyB=proxy>=queryProxy?proxy:queryProxy;
++this.m_pairCount;
return true;
}
);
;fatAABB=this.m_tree.GetFatAABB(queryProxy);
this.m_tree.Query(flash.bindFunction(null,QueryCallback),fatAABB)
}
this.m_moveBuffer.length=0;
i=0;
while(i<this.m_pairCount)
{
primaryPair=this.m_pairBuffer[i];
userDataA=this.m_tree.GetUserData(primaryPair.proxyA);
userDataB=this.m_tree.GetUserData(primaryPair.proxyB);
callback(userDataA,userDataB);
++i;
while(i<this.m_pairCount)
{
pair=this.m_pairBuffer[i];
if(pair.proxyA!=primaryPair.proxyA||pair.proxyB!=primaryPair.proxyB)
{
break;
;
}
;++i
}
}
};
d.Query=function(callback,aabb)
{
this.m_tree.Query(callback,aabb);
};
d.RayCast=function(callback,input)
{
this.m_tree.RayCast(callback,input);
};
d.Validate=function()
{
};
d.Rebalance=function(iterations)
{
iterations=flash.int(iterations);
this.m_tree.Rebalance(iterations);
};
d.BufferMove=function(proxy)
{
this.m_moveBuffer[this.m_moveBuffer.length]=proxy;
};
d.UnBufferMove=function(proxy)
{
var i=0;
i=this.m_moveBuffer.indexOf(proxy);
this.m_moveBuffer.splice(i,1);
};
d.ComparePairs=function(pair1,pair2)
{
return 0;
};
d.b2DynamicTreeBroadPhase=function()
{
this.m_tree=new Box2D.Collision.b2DynamicTree();
this.m_moveBuffer=new Array();
this.m_pairBuffer=new Array();
};
flash.addDescription("Box2D.Collision.b2DynamicTreeBroadPhase",d,null,null,["Box2D.Collision.IBroadPhase"],["Box2D.Collision.b2DynamicTree","Box2D.Collision.b2DynamicTreeNode","Box2D.Collision.b2DynamicTreePair"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_v1=null;
d.m_v2=null;
d.m_coreV1=null;
d.m_coreV2=null;
d.m_length=0;
d.m_normal=null;
d.m_direction=null;
d.m_cornerDir1=null;
d.m_cornerDir2=null;
d.m_cornerConvex1=false;
d.m_cornerConvex2=false;
d.m_nextEdge=null;
d.m_prevEdge=null;
d.s_supportVec=null;
d.b2EdgeShape=function(v1,v2)
{
this.m_v1=new Box2D.Common.Math.b2Vec2();
this.m_v2=new Box2D.Common.Math.b2Vec2();
this.m_coreV1=new Box2D.Common.Math.b2Vec2();
this.m_coreV2=new Box2D.Common.Math.b2Vec2();
this.m_normal=new Box2D.Common.Math.b2Vec2();
this.m_direction=new Box2D.Common.Math.b2Vec2();
this.m_cornerDir1=new Box2D.Common.Math.b2Vec2();
this.m_cornerDir2=new Box2D.Common.Math.b2Vec2();
this.s_supportVec=new Box2D.Common.Math.b2Vec2();
this.b2Shape_constructor();
this.m_type=Box2D.Collision.Shapes.b2Shape.e_edgeShape;
this.m_prevEdge=null;
this.m_nextEdge=null;
this.m_v1=v1;
this.m_v2=v2;
this.m_direction.Set(this.m_v2.x-this.m_v1.x,this.m_v2.y-this.m_v1.y);
this.m_length=this.m_direction.Normalize();
this.m_normal.Set(this.m_direction.y,-this.m_direction.x);
this.m_coreV1.Set(-Box2D.Common.b2Settings.b2_toiSlop*(this.m_normal.x-this.m_direction.x)+this.m_v1.x,-Box2D.Common.b2Settings.b2_toiSlop*(this.m_normal.y-this.m_direction.y)+this.m_v1.y);
this.m_coreV2.Set(-Box2D.Common.b2Settings.b2_toiSlop*(this.m_normal.x+this.m_direction.x)+this.m_v2.x,-Box2D.Common.b2Settings.b2_toiSlop*(this.m_normal.y+this.m_direction.y)+this.m_v2.y);
this.m_cornerDir1=this.m_normal;
this.m_cornerDir2.Set(-this.m_normal.x,-this.m_normal.y);
};
d.TestPoint=function(transform,p)
{
return false;
};
d.RayCast=function(output,input,transform)
{
var tMat=null;
var rX=0;
var rY=0;
var v1X=0;
var v1Y=0;
var nX=0;
var nY=0;
var k_slop=0;
var denom=0;
var bX=0;
var bY=0;
var a=0;
var mu2=0;
var nLen=0;
tMat;
rX=input.p2.x-input.p1.x;
rY=input.p2.y-input.p1.y;
tMat=transform.R;
v1X=transform.position.x+(tMat.col1.x*this.m_v1.x+tMat.col2.x*this.m_v1.y);
v1Y=transform.position.y+(tMat.col1.y*this.m_v1.x+tMat.col2.y*this.m_v1.y);
nX=transform.position.y+(tMat.col1.y*this.m_v2.x+tMat.col2.y*this.m_v2.y)-v1Y;
nY=-(transform.position.x+(tMat.col1.x*this.m_v2.x+tMat.col2.x*this.m_v2.y)-v1X);
k_slop=100.0*Number.MIN_VALUE;
denom=-(rX*nX+rY*nY);
if(denom>k_slop)
{
bX=input.p1.x-v1X;
bY=input.p1.y-v1Y;
a=(bX*nX+bY*nY);
if(0.0<=a&&a<=input.maxFraction*denom)
{
mu2=-rX*bY+rY*bX;
if(-k_slop*denom<=mu2&&mu2<=denom*(1.0+k_slop))
{
a/=denom;
output.fraction=a;
nLen=Math.sqrt(nX*nX+nY*nY);
output.normal.x=nX/nLen;
output.normal.y=nY/nLen;
return true
}
}
}
return false;
};
d.ComputeAABB=function(aabb,transform)
{
var tMat=null;
var v1X=0;
var v1Y=0;
var v2X=0;
var v2Y=0;
tMat=transform.R;
v1X=transform.position.x+(tMat.col1.x*this.m_v1.x+tMat.col2.x*this.m_v1.y);
v1Y=transform.position.y+(tMat.col1.y*this.m_v1.x+tMat.col2.y*this.m_v1.y);
v2X=transform.position.x+(tMat.col1.x*this.m_v2.x+tMat.col2.x*this.m_v2.y);
v2Y=transform.position.y+(tMat.col1.y*this.m_v2.x+tMat.col2.y*this.m_v2.y);
if(v1X<v2X)
{
aabb.lowerBound.x=v1X;
aabb.upperBound.x=v2X
}
else
{
aabb.lowerBound.x=v2X;
aabb.upperBound.x=v1X
}
if(v1Y<v2Y)
{
aabb.lowerBound.y=v1Y;
aabb.upperBound.y=v2Y
}
else
{
aabb.lowerBound.y=v2Y;
aabb.upperBound.y=v1Y
}
};
d.ComputeMass=function(massData,density)
{
massData.mass=0;
massData.center.SetV(this.m_v1);
massData.I=0;
};
d.ComputeSubmergedArea=function(normal,offset,xf,c)
{
var v0=null;
var v1=null;
var v2=null;
var d1=0;
var d2=0;
v0=new Box2D.Common.Math.b2Vec2(normal.x*offset,normal.y*offset);
v1=Box2D.Common.Math.b2Math.MulX(xf,this.m_v1);
v2=Box2D.Common.Math.b2Math.MulX(xf,this.m_v2);
d1=Box2D.Common.Math.b2Math.Dot(normal,v1)-offset;
d2=Box2D.Common.Math.b2Math.Dot(normal,v2)-offset;
if(d1>0)
{
if(d2>0)
{
return 0
}
else
{
v1.x=-d2/(d1-d2)*v1.x+d1/(d1-d2)*v2.x;
v1.y=-d2/(d1-d2)*v1.y+d1/(d1-d2)*v2.y
}
}
else
{
if(d2>0)
{
v2.x=-d2/(d1-d2)*v1.x+d1/(d1-d2)*v2.x;
v2.y=-d2/(d1-d2)*v1.y+d1/(d1-d2)*v2.y
}
else
{
}
}
c.x=(v0.x+v1.x+v2.x)/3;
c.y=(v0.y+v1.y+v2.y)/3;
return 0.5*((v1.x-v0.x)*(v2.y-v0.y)-(v1.y-v0.y)*(v2.x-v0.x));
};
d.GetLength=function()
{
return this.m_length;
};
d.GetVertex1=function()
{
return this.m_v1;
};
d.GetVertex2=function()
{
return this.m_v2;
};
d.GetCoreVertex1=function()
{
return this.m_coreV1;
};
d.GetCoreVertex2=function()
{
return this.m_coreV2;
};
d.GetNormalVector=function()
{
return this.m_normal;
};
d.GetDirectionVector=function()
{
return this.m_direction;
};
d.GetCorner1Vector=function()
{
return this.m_cornerDir1;
};
d.GetCorner2Vector=function()
{
return this.m_cornerDir2;
};
d.Corner1IsConvex=function()
{
return this.m_cornerConvex1;
};
d.Corner2IsConvex=function()
{
return this.m_cornerConvex2;
};
d.GetFirstVertex=function(xf)
{
var tMat=null;
tMat=xf.R;
return new Box2D.Common.Math.b2Vec2(xf.position.x+(tMat.col1.x*this.m_coreV1.x+tMat.col2.x*this.m_coreV1.y),xf.position.y+(tMat.col1.y*this.m_coreV1.x+tMat.col2.y*this.m_coreV1.y));
};
d.GetNextEdge=function()
{
return this.m_nextEdge;
};
d.GetPrevEdge=function()
{
return this.m_prevEdge;
};
d.Support=function(xf,dX,dY)
{
var tMat=null;
var v1X=0;
var v1Y=0;
var v2X=0;
var v2Y=0;
tMat=xf.R;
v1X=xf.position.x+(tMat.col1.x*this.m_coreV1.x+tMat.col2.x*this.m_coreV1.y);
v1Y=xf.position.y+(tMat.col1.y*this.m_coreV1.x+tMat.col2.y*this.m_coreV1.y);
v2X=xf.position.x+(tMat.col1.x*this.m_coreV2.x+tMat.col2.x*this.m_coreV2.y);
v2Y=xf.position.y+(tMat.col1.y*this.m_coreV2.x+tMat.col2.y*this.m_coreV2.y);
if((v1X*dX+v1Y*dY)>(v2X*dX+v2Y*dY))
{
this.s_supportVec.x=v1X;
this.s_supportVec.y=v1Y
}
else
{
this.s_supportVec.x=v2X;
this.s_supportVec.y=v2Y
}
return this.s_supportVec;
};
d.SetPrevEdge=function(edge,core,cornerDir,convex)
{
this.m_prevEdge=edge;
this.m_coreV1=core;
this.m_cornerDir1=cornerDir;
this.m_cornerConvex1=convex;
};
d.SetNextEdge=function(edge,core,cornerDir,convex)
{
this.m_nextEdge=edge;
this.m_coreV2=core;
this.m_cornerDir2=cornerDir;
this.m_cornerConvex2=convex;
};
var s={};
s.__init__=function()
{
this.prototype.b2Shape_constructor=this.__base__;
};
flash.addDescription("Box2D.Collision.Shapes.b2EdgeShape",d,"Box2D.Collision.Shapes.b2Shape",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_type=0;
d.m_radius=0;
d.b2Shape=function()
{
this.m_type=Box2D.Collision.Shapes.b2Shape.e_unknownShape;
this.m_radius=Box2D.Common.b2Settings.b2_linearSlop;
};
d.Copy=function()
{
return null;
};
d.Set=function(other)
{
this.m_radius=other.m_radius;
};
d.GetType=function()
{
return this.m_type;
};
d.TestPoint=function(xf,p)
{
return false;
};
d.RayCast=function(output,input,transform)
{
return false;
};
d.ComputeAABB=function(aabb,xf)
{
};
d.ComputeMass=function(massData,density)
{
};
d.ComputeSubmergedArea=function(normal,offset,xf,c)
{
return 0;
};
var s={};
s.__init__=function()
{
this.e_circleShape=0;
this.e_polygonShape=1;
this.e_edgeShape=2;
this.e_shapeTypeCount=3;
this.e_hitCollide=1;
this.e_missCollide=0;
this.e_startsInsideCollide=-1;
this.e_unknownShape=-1;
};
s.TestOverlap=function(shape1,transform1,shape2,transform2)
{
var input=null;
var simplexCache=null;
var output=null;
input=new Box2D.Collision.b2DistanceInput();
input.proxyA=new Box2D.Collision.b2DistanceProxy();
input.proxyA.Set(shape1);
input.proxyB=new Box2D.Collision.b2DistanceProxy();
input.proxyB.Set(shape2);
input.transformA=transform1;
input.transformB=transform2;
input.useRadii=true;
simplexCache=new Box2D.Collision.b2SimplexCache();
simplexCache.count=0;
output=new Box2D.Collision.b2DistanceOutput();
Box2D.Collision.b2Distance.Distance(output,simplexCache,input);
return output.distance<10.0*Number.MIN_VALUE;
};
flash.addDescription("Box2D.Collision.Shapes.b2Shape",d,null,s,null,["Box2D.Collision.b2DistanceInput","Box2D.Collision.b2DistanceProxy","Box2D.Collision.b2SimplexCache","Box2D.Collision.b2DistanceOutput","Box2D.Collision.b2Distance","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_centroid=null;
d.m_vertices=null;
d.m_normals=null;
d.m_vertexCount=0;
d.b2PolygonShape=function()
{
this.b2Shape_constructor();
this.m_type=Box2D.Collision.Shapes.b2Shape.e_polygonShape;
this.m_centroid=new Box2D.Common.Math.b2Vec2();
this.m_vertices=new Array();
this.m_normals=new Array();
};
d.Copy=function()
{
var s=null;
s=new Box2D.Collision.Shapes.b2PolygonShape();
s.Set(this);
return s;
};
d.Set=function(other)
{
var other2=null;
var i=0;
this.b2Shape_Set(other);
if(other instanceof Box2D.Collision.Shapes.b2PolygonShape)
{
other2=other;
this.m_centroid.SetV(other2.m_centroid);
this.m_vertexCount=other2.m_vertexCount;
this.Reserve(this.m_vertexCount);
for(i=0;i<this.m_vertexCount;i++)
{
this.m_vertices[i].SetV(other2.m_vertices[i]);
this.m_normals[i].SetV(other2.m_normals[i])
}
}
};
d.TestPoint=function(xf,p)
{
var tVec=null;
var tMat=null;
var tX=0;
var tY=0;
var pLocalX=0;
var pLocalY=0;
var i=0;
var dot=0;
tVec;
tMat=xf.R;
tX=p.x-xf.position.x;
tY=p.y-xf.position.y;
pLocalX=(tX*tMat.col1.x+tY*tMat.col1.y);
pLocalY=(tX*tMat.col2.x+tY*tMat.col2.y);
for(i=0;i<this.m_vertexCount;++i)
{
tVec=this.m_vertices[i];
tX=pLocalX-tVec.x;
tY=pLocalY-tVec.y;
tVec=this.m_normals[i];
dot=(tVec.x*tX+tVec.y*tY);
if(dot>0.0)
{
return false
}
}
return true;
};
d.RayCast=function(output,input,transform)
{
var lower=0;
var upper=0;
var tX=0;
var tY=0;
var tMat=null;
var tVec=null;
var p1X=0;
var p1Y=0;
var p2X=0;
var p2Y=0;
var dX=0;
var dY=0;
var index=0;
var i=0;
var numerator=0;
var denominator=0;
lower=0.0;
upper=input.maxFraction;
tX;
tY;
tMat;
tVec;
tX=input.p1.x-transform.position.x;
tY=input.p1.y-transform.position.y;
tMat=transform.R;
p1X=(tX*tMat.col1.x+tY*tMat.col1.y);
p1Y=(tX*tMat.col2.x+tY*tMat.col2.y);
tX=input.p2.x-transform.position.x;
tY=input.p2.y-transform.position.y;
tMat=transform.R;
p2X=(tX*tMat.col1.x+tY*tMat.col1.y);
p2Y=(tX*tMat.col2.x+tY*tMat.col2.y);
dX=p2X-p1X;
dY=p2Y-p1Y;
index=-1;
for(i=0;i<this.m_vertexCount;++i)
{
tVec=this.m_vertices[i];
tX=tVec.x-p1X;
tY=tVec.y-p1Y;
tVec=this.m_normals[i];
numerator=(tVec.x*tX+tVec.y*tY);
denominator=(tVec.x*dX+tVec.y*dY);
if(denominator==0.0)
{
if(numerator<0.0)
{
return false
}
}
else
{
if(denominator<0.0&&numerator<lower*denominator)
{
lower=numerator/denominator;
index=i
}
else if(denominator>0.0&&numerator<upper*denominator)
{
upper=numerator/denominator
}
}
if(upper<lower-Number.MIN_VALUE)
{
return false
}
}
if(index>=0)
{
output.fraction=lower;
tMat=transform.R;
tVec=this.m_normals[index];
output.normal.x=(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
output.normal.y=(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
return true
}
return false;
};
d.ComputeAABB=function(aabb,xf)
{
var tMat=null;
var tVec=null;
var lowerX=0;
var lowerY=0;
var upperX=0;
var upperY=0;
var i=0;
var vX=0;
var vY=0;
tMat=xf.R;
tVec=this.m_vertices[0];
lowerX=xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
lowerY=xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
upperX=lowerX;
upperY=lowerY;
for(i=1;i<this.m_vertexCount;++i)
{
tVec=this.m_vertices[i];
vX=xf.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
vY=xf.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
lowerX=lowerX<vX?lowerX:vX;
lowerY=lowerY<vY?lowerY:vY;
upperX=upperX>vX?upperX:vX;
upperY=upperY>vY?upperY:vY
}
aabb.lowerBound.x=lowerX-this.m_radius;
aabb.lowerBound.y=lowerY-this.m_radius;
aabb.upperBound.x=upperX+this.m_radius;
aabb.upperBound.y=upperY+this.m_radius;
};
d.ComputeMass=function(massData,density)
{
var centerX=0;
var centerY=0;
var area=0;
var I=0;
var p1X=0;
var p1Y=0;
var k_inv3=0;
var i=0;
var p2=null;
var p3=null;
var e1X=0;
var e1Y=0;
var e2X=0;
var e2Y=0;
var D=0;
var triangleArea=0;
var px=0;
var py=0;
var ex1=0;
var ey1=0;
var ex2=0;
var ey2=0;
var intx2=0;
var inty2=0;
if(this.m_vertexCount==2)
{
massData.center.x=0.5*(this.m_vertices[0].x+this.m_vertices[1].x);
massData.center.y=0.5*(this.m_vertices[0].y+this.m_vertices[1].y);
massData.mass=0.0;
massData.I=0.0;
return
}
centerX=0.0;
centerY=0.0;
area=0.0;
I=0.0;
p1X=0.0;
p1Y=0.0;
k_inv3=1.0/3.0;
for(i=0;i<this.m_vertexCount;++i)
{
p2=this.m_vertices[i];
p3=i+1<this.m_vertexCount?this.m_vertices[flash.int(i+1)]:this.m_vertices[0];
e1X=p2.x-p1X;
e1Y=p2.y-p1Y;
e2X=p3.x-p1X;
e2Y=p3.y-p1Y;
D=e1X*e2Y-e1Y*e2X;
triangleArea=0.5*D;
area+=triangleArea;
centerX+=triangleArea*k_inv3*(p1X+p2.x+p3.x);
centerY+=triangleArea*k_inv3*(p1Y+p2.y+p3.y);
px=p1X;
py=p1Y;
ex1=e1X;
ey1=e1Y;
ex2=e2X;
ey2=e2Y;
intx2=k_inv3*(0.25*(ex1*ex1+ex2*ex1+ex2*ex2)+(px*ex1+px*ex2))+0.5*px*px;
inty2=k_inv3*(0.25*(ey1*ey1+ey2*ey1+ey2*ey2)+(py*ey1+py*ey2))+0.5*py*py;
I+=D*(intx2+inty2)
}
massData.mass=density*area;
centerX*=1.0/area;
centerY*=1.0/area;
massData.center.Set(centerX,centerY);
massData.I=density*I;
};
d.ComputeSubmergedArea=function(normal,offset,xf,c)
{
var normalL=null;
var offsetL=0;
var depths=null;
var diveCount=0;
var intoIndex=0;
var outoIndex=0;
var lastSubmerged=false;
var i=0;
var isSubmerged=false;
var md=null;
var intoIndex2=0;
var outoIndex2=0;
var intoLamdda=0;
var outoLamdda=0;
var intoVec=null;
var outoVec=null;
var area=0;
var center=null;
var p2=null;
var p3=null;
var triangleArea=0;
normalL=Box2D.Common.Math.b2Math.MulTMV(xf.R,normal);
offsetL=offset-Box2D.Common.Math.b2Math.Dot(normal,xf.position);
depths=new Array();
diveCount=0;
intoIndex=-1;
outoIndex=-1;
lastSubmerged=false;
i;
for(i=0;i<this.m_vertexCount;++i)
{
depths[i]=Box2D.Common.Math.b2Math.Dot(normalL,this.m_vertices[i])-offsetL;
isSubmerged=depths[i]<-Number.MIN_VALUE;
if(i>0)
{
if(isSubmerged)
{
if(!lastSubmerged)
{
intoIndex=i-1;
diveCount++
}
}
else
{
if(lastSubmerged)
{
outoIndex=i-1;
diveCount++
}
}
}
lastSubmerged=isSubmerged
}
switch(diveCount)
{
case 0:
if(lastSubmerged)
{
md=new Box2D.Collision.Shapes.b2MassData();
this.ComputeMass(md,1);
c.SetV(Box2D.Common.Math.b2Math.MulX(xf,md.center));
return md.mass
}
else
{
return 0
}
break;
;case 1:
if(intoIndex==-1)
{
intoIndex=this.m_vertexCount-1
}
else
{
outoIndex=this.m_vertexCount-1
}
break;
;
}
intoIndex2=(intoIndex+1)%this.m_vertexCount;
outoIndex2=(outoIndex+1)%this.m_vertexCount;
intoLamdda=(0-depths[intoIndex])/(depths[intoIndex2]-depths[intoIndex]);
outoLamdda=(0-depths[outoIndex])/(depths[outoIndex2]-depths[outoIndex]);
intoVec=new Box2D.Common.Math.b2Vec2(this.m_vertices[intoIndex].x*(1-intoLamdda)+this.m_vertices[intoIndex2].x*intoLamdda,this.m_vertices[intoIndex].y*(1-intoLamdda)+this.m_vertices[intoIndex2].y*intoLamdda);
outoVec=new Box2D.Common.Math.b2Vec2(this.m_vertices[outoIndex].x*(1-outoLamdda)+this.m_vertices[outoIndex2].x*outoLamdda,this.m_vertices[outoIndex].y*(1-outoLamdda)+this.m_vertices[outoIndex2].y*outoLamdda);
area=0;
center=new Box2D.Common.Math.b2Vec2();
p2=this.m_vertices[intoIndex2];
p3;
i=intoIndex2;
while(i!=outoIndex2)
{
i=(i+1)%this.m_vertexCount;
if(i==outoIndex2)
{
p3=outoVec
}
else
{
p3=this.m_vertices[i]
}
triangleArea=0.5*((p2.x-intoVec.x)*(p3.y-intoVec.y)-(p2.y-intoVec.y)*(p3.x-intoVec.x));
area+=triangleArea;
center.x+=triangleArea*(intoVec.x+p2.x+p3.x)/3;
center.y+=triangleArea*(intoVec.y+p2.y+p3.y)/3;
p2=p3
}
center.Multiply(1/area);
c.SetV(Box2D.Common.Math.b2Math.MulX(xf,center));
return area;
};
d.SetAsArray=function(vertices,vertexCount)
{
if(vertexCount==undefined)vertexCount=0;
var v=null;
var tVec=null;
var t0=null;
v=new Array();
for(t0 in vertices)
{
tVec=vertices[t0];
v.push(tVec)
}
this.SetAsVector(v,vertexCount);
};
d.SetAsVector=function(vertices,vertexCount)
{
if(vertexCount==undefined)vertexCount=0;
var i=0;
var i1=0;
var i2=0;
var edge=null;
if(vertexCount==0)
{
vertexCount=vertices.length
}
Box2D.Common.b2Settings.b2Assert(2<=vertexCount);
this.m_vertexCount=flash.int(vertexCount);
this.Reserve(vertexCount);
i;
for(i=0;i<this.m_vertexCount;i++)
{
this.m_vertices[i].SetV(vertices[i])
}
for(i=0;i<this.m_vertexCount;++i)
{
i1=i;
i2=flash.int(i+1<this.m_vertexCount?i+1:0);
edge=Box2D.Common.Math.b2Math.SubtractVV(this.m_vertices[i2],this.m_vertices[i1]);
Box2D.Common.b2Settings.b2Assert(edge.LengthSquared()>Number.MIN_VALUE);
this.m_normals[i].SetV(Box2D.Common.Math.b2Math.CrossVF(edge,1.0));
this.m_normals[i].Normalize()
}
this.m_centroid=Box2D.Collision.Shapes.b2PolygonShape.ComputeCentroid(this.m_vertices,this.m_vertexCount);
};
d.SetAsBox=function(hx,hy)
{
this.m_vertexCount=4;
this.Reserve(4);
this.m_vertices[0].Set(-hx,-hy);
this.m_vertices[1].Set(hx,-hy);
this.m_vertices[2].Set(hx,hy);
this.m_vertices[3].Set(-hx,hy);
this.m_normals[0].Set(0.0,-1.0);
this.m_normals[1].Set(1.0,0.0);
this.m_normals[2].Set(0.0,1.0);
this.m_normals[3].Set(-1.0,0.0);
this.m_centroid.SetZero();
};
d.SetAsOrientedBox=function(hx,hy,center,angle)
{
if(center==undefined)center=null;
if(angle==undefined)angle=0.0;
var xf=null;
var i=0;
this.m_vertexCount=4;
this.Reserve(4);
this.m_vertices[0].Set(-hx,-hy);
this.m_vertices[1].Set(hx,-hy);
this.m_vertices[2].Set(hx,hy);
this.m_vertices[3].Set(-hx,hy);
this.m_normals[0].Set(0.0,-1.0);
this.m_normals[1].Set(1.0,0.0);
this.m_normals[2].Set(0.0,1.0);
this.m_normals[3].Set(-1.0,0.0);
this.m_centroid=center;
xf=new Box2D.Common.Math.b2Transform();
xf.position=center;
xf.R.Set(angle);
for(i=0;i<this.m_vertexCount;++i)
{
this.m_vertices[i]=Box2D.Common.Math.b2Math.MulX(xf,this.m_vertices[i]);
this.m_normals[i]=Box2D.Common.Math.b2Math.MulMV(xf.R,this.m_normals[i])
}
};
d.SetAsEdge=function(v1,v2)
{
this.m_vertexCount=2;
this.Reserve(2);
this.m_vertices[0].SetV(v1);
this.m_vertices[1].SetV(v2);
this.m_centroid.x=0.5*(v1.x+v2.x);
this.m_centroid.y=0.5*(v1.y+v2.y);
this.m_normals[0]=Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(v2,v1),1.0);
this.m_normals[0].Normalize();
this.m_normals[1].x=-this.m_normals[0].x;
this.m_normals[1].y=-this.m_normals[0].y;
};
d.GetVertexCount=function()
{
return this.m_vertexCount;
};
d.GetVertices=function()
{
return this.m_vertices;
};
d.GetNormals=function()
{
return this.m_normals;
};
d.GetSupport=function(d)
{
var bestIndex=0;
var bestValue=0;
var i=0;
var value=0;
bestIndex=0;
bestValue=this.m_vertices[0].x*d.x+this.m_vertices[0].y*d.y;
for(i=1;i<this.m_vertexCount;++i)
{
value=this.m_vertices[i].x*d.x+this.m_vertices[i].y*d.y;
if(value>bestValue)
{
bestIndex=i;
bestValue=value
}
}
return bestIndex;
};
d.GetSupportVertex=function(d)
{
var bestIndex=0;
var bestValue=0;
var i=0;
var value=0;
bestIndex=0;
bestValue=this.m_vertices[0].x*d.x+this.m_vertices[0].y*d.y;
for(i=1;i<this.m_vertexCount;++i)
{
value=this.m_vertices[i].x*d.x+this.m_vertices[i].y*d.y;
if(value>bestValue)
{
bestIndex=i;
bestValue=value
}
}
return this.m_vertices[bestIndex];
};
d.Validate=function()
{
return false;
};
d.Reserve=function(count)
{
count=flash.int(count);
var i=0;
for(i=this.m_vertices.length;i<count;i++)
{
this.m_vertices[i]=new Box2D.Common.Math.b2Vec2();
this.m_normals[i]=new Box2D.Common.Math.b2Vec2()
}
};
var s={};
s.__init__=function()
{
this.prototype.b2Shape_constructor=this.__base__;
this.prototype.b2Shape_Set=this.__base__.prototype.Set;
this.s_mat=new Box2D.Common.Math.b2Mat22();
};
s.AsArray=function(vertices,vertexCount)
{
var polygonShape=null;
polygonShape=new Box2D.Collision.Shapes.b2PolygonShape();
polygonShape.SetAsArray(vertices,vertexCount);
return polygonShape;
};
s.AsVector=function(vertices,vertexCount)
{
var polygonShape=null;
polygonShape=new Box2D.Collision.Shapes.b2PolygonShape();
polygonShape.SetAsVector(vertices,vertexCount);
return polygonShape;
};
s.AsBox=function(hx,hy)
{
var polygonShape=null;
polygonShape=new Box2D.Collision.Shapes.b2PolygonShape();
polygonShape.SetAsBox(hx,hy);
return polygonShape;
};
s.AsOrientedBox=function(hx,hy,center,angle)
{
if(center==undefined)center=null;
if(angle==undefined)angle=0.0;
var polygonShape=null;
polygonShape=new Box2D.Collision.Shapes.b2PolygonShape();
polygonShape.SetAsOrientedBox(hx,hy,center,angle);
return polygonShape;
};
s.AsEdge=function(v1,v2)
{
var polygonShape=null;
polygonShape=new Box2D.Collision.Shapes.b2PolygonShape();
polygonShape.SetAsEdge(v1,v2);
return polygonShape;
};
s.ComputeCentroid=function(vs,count)
{
count=flash.uint(count);
var c=null;
var area=0;
var p1X=0;
var p1Y=0;
var inv3=0;
var i=0;
var p2=null;
var p3=null;
var e1X=0;
var e1Y=0;
var e2X=0;
var e2Y=0;
var D=0;
var triangleArea=0;
c=new Box2D.Common.Math.b2Vec2();
area=0.0;
p1X=0.0;
p1Y=0.0;
inv3=1.0/3.0;
for(i=0;i<count;++i)
{
p2=vs[i];
p3=i+1<count?vs[flash.int(i+1)]:vs[0];
e1X=p2.x-p1X;
e1Y=p2.y-p1Y;
e2X=p3.x-p1X;
e2Y=p3.y-p1Y;
D=(e1X*e2Y-e1Y*e2X);
triangleArea=0.5*D;
area+=triangleArea;
c.x+=triangleArea*inv3*(p1X+p2.x+p3.x);
c.y+=triangleArea*inv3*(p1Y+p2.y+p3.y)
}
c.x*=1.0/area;
c.y*=1.0/area;
return c;
};
s.ComputeOBB=function(obb,vs,count)
{
count=flash.int(count);
var i=0;
var p=null;
var minArea=0;
var root=null;
var uxX=0;
var uxY=0;
var length=0;
var uyX=0;
var uyY=0;
var lowerX=0;
var lowerY=0;
var upperX=0;
var upperY=0;
var j=0;
var dX=0;
var dY=0;
var rX=0;
var rY=0;
var area=0;
var centerX=0;
var centerY=0;
var tMat=null;
i;
p=new Array();
for(i=0;i<count;++i)
{
p[i]=vs[i]
}
p[count]=p[0];
minArea=Number.MAX_VALUE;
for(i=1;i<=count;++i)
{
root=p[flash.int(i-1)];
uxX=p[i].x-root.x;
uxY=p[i].y-root.y;
length=Math.sqrt(uxX*uxX+uxY*uxY);
uxX/=length;
uxY/=length;
uyX=-uxY;
uyY=uxX;
lowerX=Number.MAX_VALUE;
lowerY=Number.MAX_VALUE;
upperX=-Number.MAX_VALUE;
upperY=-Number.MAX_VALUE;
for(j=0;j<count;++j)
{
dX=p[j].x-root.x;
dY=p[j].y-root.y;
rX=(uxX*dX+uxY*dY);
rY=(uyX*dX+uyY*dY);
if(rX<lowerX)
{
lowerX=rX
}
if(rY<lowerY)
{
lowerY=rY
}
if(rX>upperX)
{
upperX=rX
}
if(rY>upperY)
{
upperY=rY
}
}
area=(upperX-lowerX)*(upperY-lowerY);
if(area<0.95*minArea)
{
minArea=area;
obb.R.col1.x=uxX;
obb.R.col1.y=uxY;
obb.R.col2.x=uyX;
obb.R.col2.y=uyY;
centerX=0.5*(lowerX+upperX);
centerY=0.5*(lowerY+upperY);
tMat=obb.R;
obb.center.x=root.x+(tMat.col1.x*centerX+tMat.col2.x*centerY);
obb.center.y=root.y+(tMat.col1.y*centerX+tMat.col2.y*centerY);
obb.extents.x=0.5*(upperX-lowerX);
obb.extents.y=0.5*(upperY-lowerY)
}
}
};
flash.addDescription("Box2D.Collision.Shapes.b2PolygonShape",d,"Box2D.Collision.Shapes.b2Shape",s,null,["Box2D.Common.Math.b2Mat22","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Common.Math.b2Vec2","Box2D.Common.Math.b2Math","Box2D.Collision.Shapes.b2MassData","Box2D.Common.b2Settings","Box2D.Common.Math.b2Transform"]);
}
());;
(function()
{
"use strict";
var d={};
d.mass=0;
d.center=null;
d.I=0;
d.b2MassData=function()
{
this.mass=0.0;
this.center=new Box2D.Common.Math.b2Vec2(0,0);
this.I=0.0;
};
flash.addDescription("Box2D.Collision.Shapes.b2MassData",d,null,null,null,["Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_p=null;
d.b2CircleShape=function(radius)
{
this.m_p=new Box2D.Common.Math.b2Vec2();
if(radius==undefined)radius=0;
this.b2Shape_constructor();
this.m_type=Box2D.Collision.Shapes.b2Shape.e_circleShape;
this.m_radius=radius;
};
d.Copy=function()
{
var s=null;
s=new Box2D.Collision.Shapes.b2CircleShape();
s.Set(this);
return s;
};
d.Set=function(other)
{
var other2=null;
this.b2Shape_Set(other);
if(other instanceof Box2D.Collision.Shapes.b2CircleShape)
{
other2=other;
this.m_p.SetV(other2.m_p)
}
};
d.TestPoint=function(transform,p)
{
var tMat=null;
var dX=0;
var dY=0;
tMat=transform.R;
dX=transform.position.x+(tMat.col1.x*this.m_p.x+tMat.col2.x*this.m_p.y);
dY=transform.position.y+(tMat.col1.y*this.m_p.x+tMat.col2.y*this.m_p.y);
dX=p.x-dX;
dY=p.y-dY;
return(dX*dX+dY*dY)<=this.m_radius*this.m_radius;
};
d.RayCast=function(output,input,transform)
{
var tMat=null;
var positionX=0;
var positionY=0;
var sX=0;
var sY=0;
var b=0;
var rX=0;
var rY=0;
var c=0;
var rr=0;
var sigma=0;
var a=0;
tMat=transform.R;
positionX=transform.position.x+(tMat.col1.x*this.m_p.x+tMat.col2.x*this.m_p.y);
positionY=transform.position.y+(tMat.col1.y*this.m_p.x+tMat.col2.y*this.m_p.y);
sX=input.p1.x-positionX;
sY=input.p1.y-positionY;
b=(sX*sX+sY*sY)-this.m_radius*this.m_radius;
rX=input.p2.x-input.p1.x;
rY=input.p2.y-input.p1.y;
c=(sX*rX+sY*rY);
rr=(rX*rX+rY*rY);
sigma=c*c-rr*b;
if(sigma<0.0||rr<Number.MIN_VALUE)
{
return false
}
a=-(c+Math.sqrt(sigma));
if(0.0<=a&&a<=input.maxFraction*rr)
{
a/=rr;
output.fraction=a;
output.normal.x=sX+a*rX;
output.normal.y=sY+a*rY;
output.normal.Normalize();
return true
}
return false;
};
d.ComputeAABB=function(aabb,transform)
{
var tMat=null;
var pX=0;
var pY=0;
tMat=transform.R;
pX=transform.position.x+(tMat.col1.x*this.m_p.x+tMat.col2.x*this.m_p.y);
pY=transform.position.y+(tMat.col1.y*this.m_p.x+tMat.col2.y*this.m_p.y);
aabb.lowerBound.Set(pX-this.m_radius,pY-this.m_radius);
aabb.upperBound.Set(pX+this.m_radius,pY+this.m_radius);
};
d.ComputeMass=function(massData,density)
{
massData.mass=density*Box2D.Common.b2Settings.b2_pi*this.m_radius*this.m_radius;
massData.center.SetV(this.m_p);
massData.I=massData.mass*(0.5*this.m_radius*this.m_radius+(this.m_p.x*this.m_p.x+this.m_p.y*this.m_p.y));
};
d.ComputeSubmergedArea=function(normal,offset,xf,c)
{
var p=null;
var l=0;
var r2=0;
var l2=0;
var area=0;
var com=0;
p=Box2D.Common.Math.b2Math.MulX(xf,this.m_p);
l=-(Box2D.Common.Math.b2Math.Dot(normal,p)-offset);
if(l<-this.m_radius+Number.MIN_VALUE)
{
return 0
}
if(l>this.m_radius)
{
c.SetV(p);
return Math.PI*this.m_radius*this.m_radius
}
r2=this.m_radius*this.m_radius;
l2=l*l;
area=r2*(Math.asin(l/this.m_radius)+Math.PI/2)+l*Math.sqrt(r2-l2);
com=-2/3*Math.pow(r2-l2,1.5)/area;
c.x=p.x+normal.x*com;
c.y=p.y+normal.y*com;
return area;
};
d.GetLocalPosition=function()
{
return this.m_p;
};
d.SetLocalPosition=function(position)
{
this.m_p.SetV(position);
};
d.GetRadius=function()
{
return this.m_radius;
};
d.SetRadius=function(radius)
{
this.m_radius=radius;
};
var s={};
s.__init__=function()
{
this.prototype.b2Shape_constructor=this.__base__;
this.prototype.b2Shape_Set=this.__base__.prototype.Set;
};
flash.addDescription("Box2D.Collision.Shapes.b2CircleShape",d,"Box2D.Collision.Shapes.b2Shape",s,null,["Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2CircleShape","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.proxyA=null;
d.proxyB=null;
d.transformA=null;
d.transformB=null;
d.useRadii=false;
d.b2DistanceInput=function()
{
};
flash.addDescription("Box2D.Collision.b2DistanceInput",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.b2Collision=function()
{
};
var s={};
s.__init__=function()
{
this.b2_nullFeature=0x000000ff;
this.s_incidentEdge=Box2D.Collision.b2Collision.MakeClipPointVector();
this.s_clipPoints1=Box2D.Collision.b2Collision.MakeClipPointVector();
this.s_clipPoints2=Box2D.Collision.b2Collision.MakeClipPointVector();
this.s_edgeAO=new Array();
this.s_edgeBO=new Array();
this.s_localTangent=new Box2D.Common.Math.b2Vec2();
this.s_localNormal=new Box2D.Common.Math.b2Vec2();
this.s_planePoint=new Box2D.Common.Math.b2Vec2();
this.s_normal=new Box2D.Common.Math.b2Vec2();
this.s_tangent=new Box2D.Common.Math.b2Vec2();
this.s_tangent2=new Box2D.Common.Math.b2Vec2();
this.s_v11=new Box2D.Common.Math.b2Vec2();
this.s_v12=new Box2D.Common.Math.b2Vec2();
this.b2CollidePolyTempVec=new Box2D.Common.Math.b2Vec2();
};
s.ClipSegmentToLine=function(vOut,vIn,normal,offset)
{
var cv=null;
var numOut=0;
var vIn0=null;
var vIn1=null;
var distance0=0;
var distance1=0;
var interp=0;
var tVec=null;
var cv2=null;
cv;
numOut=0;
cv=vIn[0];
vIn0=cv.v;
cv=vIn[1];
vIn1=cv.v;
distance0=normal.x*vIn0.x+normal.y*vIn0.y-offset;
distance1=normal.x*vIn1.x+normal.y*vIn1.y-offset;
if(distance0<=0.0)
{
vOut[numOut++].Set(vIn[0])
}
if(distance1<=0.0)
{
vOut[numOut++].Set(vIn[1])
}
if(distance0*distance1<0.0)
{
interp=distance0/(distance0-distance1);
cv=vOut[numOut];
tVec=cv.v;
tVec.x=vIn0.x+interp*(vIn1.x-vIn0.x);
tVec.y=vIn0.y+interp*(vIn1.y-vIn0.y);
cv=vOut[numOut];
cv2;
if(distance0>0.0)
{
cv2=vIn[0];
cv.id=cv2.id
}
else
{
cv2=vIn[1];
cv.id=cv2.id
}
;++numOut
}
return numOut;
};
s.EdgeSeparation=function(poly1,xf1,edge1,poly2,xf2)
{
edge1=flash.int(edge1);
var count1=0;
var vertices1=null;
var normals1=null;
var count2=0;
var vertices2=null;
var tMat=null;
var tVec=null;
var normal1WorldX=0;
var normal1WorldY=0;
var normal1X=0;
var normal1Y=0;
var index=0;
var minDot=0;
var i=0;
var dot=0;
var v1X=0;
var v1Y=0;
var v2X=0;
var v2Y=0;
var separation=0;
count1=poly1.m_vertexCount;
vertices1=poly1.m_vertices;
normals1=poly1.m_normals;
count2=poly2.m_vertexCount;
vertices2=poly2.m_vertices;
tMat;
tVec;
tMat=xf1.R;
tVec=normals1[edge1];
normal1WorldX=(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
normal1WorldY=(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tMat=xf2.R;
normal1X=(tMat.col1.x*normal1WorldX+tMat.col1.y*normal1WorldY);
normal1Y=(tMat.col2.x*normal1WorldX+tMat.col2.y*normal1WorldY);
index=0;
minDot=Number.MAX_VALUE;
for(i=0;i<count2;++i)
{
tVec=vertices2[i];
dot=tVec.x*normal1X+tVec.y*normal1Y;
if(dot<minDot)
{
minDot=dot;
index=i
}
}
tVec=vertices1[edge1];
tMat=xf1.R;
v1X=xf1.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
v1Y=xf1.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tVec=vertices2[index];
tMat=xf2.R;
v2X=xf2.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
v2Y=xf2.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
v2X-=v1X;
v2Y-=v1Y;
separation=v2X*normal1WorldX+v2Y*normal1WorldY;
return separation;
};
s.FindMaxSeparation=function(edgeIndex,poly1,xf1,poly2,xf2)
{
var count1=0;
var normals1=null;
var tVec=null;
var tMat=null;
var dX=0;
var dY=0;
var dLocal1X=0;
var dLocal1Y=0;
var edge=0;
var maxDot=0;
var i=0;
var dot=0;
var s=0;
var prevEdge=0;
var sPrev=0;
var nextEdge=0;
var sNext=0;
var bestEdge=0;
var bestSeparation=0;
var increment=0;
count1=poly1.m_vertexCount;
normals1=poly1.m_normals;
tVec;
tMat;
tMat=xf2.R;
tVec=poly2.m_centroid;
dX=xf2.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
dY=xf2.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tMat=xf1.R;
tVec=poly1.m_centroid;
dX-=xf1.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
dY-=xf1.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
dLocal1X=(dX*xf1.R.col1.x+dY*xf1.R.col1.y);
dLocal1Y=(dX*xf1.R.col2.x+dY*xf1.R.col2.y);
edge=0;
maxDot=-Number.MAX_VALUE;
for(i=0;i<count1;++i)
{
tVec=normals1[i];
dot=(tVec.x*dLocal1X+tVec.y*dLocal1Y);
if(dot>maxDot)
{
maxDot=dot;
edge=i
}
}
s=Box2D.Collision.b2Collision.EdgeSeparation(poly1,xf1,edge,poly2,xf2);
prevEdge=flash.int(edge-1>=0?edge-1:count1-1);
sPrev=Box2D.Collision.b2Collision.EdgeSeparation(poly1,xf1,prevEdge,poly2,xf2);
nextEdge=flash.int(edge+1<count1?edge+1:0);
sNext=Box2D.Collision.b2Collision.EdgeSeparation(poly1,xf1,nextEdge,poly2,xf2);
bestEdge;
bestSeparation;
increment;
if(sPrev>s&&sPrev>sNext)
{
increment=-1;
bestEdge=prevEdge;
bestSeparation=sPrev
}
else if(sNext>s)
{
increment=1;
bestEdge=nextEdge;
bestSeparation=sNext
}
else
{
edgeIndex[0]=edge;
return s
}
while(true)
{
if(increment==-1)
{
edge=flash.int(bestEdge-1>=0?bestEdge-1:count1-1)
}
else
{
edge=flash.int(bestEdge+1<count1?bestEdge+1:0)
}
s=Box2D.Collision.b2Collision.EdgeSeparation(poly1,xf1,edge,poly2,xf2);
if(s>bestSeparation)
{
bestEdge=edge;
bestSeparation=s
}
else
{
break;
;
}
}
edgeIndex[0]=bestEdge;
return bestSeparation;
};
s.FindIncidentEdge=function(c,poly1,xf1,edge1,poly2,xf2)
{
edge1=flash.int(edge1);
var count1=0;
var normals1=null;
var count2=0;
var vertices2=null;
var normals2=null;
var tMat=null;
var tVec=null;
var normal1X=0;
var normal1Y=0;
var tX=0;
var index=0;
var minDot=0;
var i=0;
var dot=0;
var tClip=null;
var i1=0;
var i2=0;
count1=poly1.m_vertexCount;
normals1=poly1.m_normals;
count2=poly2.m_vertexCount;
vertices2=poly2.m_vertices;
normals2=poly2.m_normals;
tMat;
tVec;
tMat=xf1.R;
tVec=normals1[edge1];
normal1X=(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
normal1Y=(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tMat=xf2.R;
tX=(tMat.col1.x*normal1X+tMat.col1.y*normal1Y);
normal1Y=(tMat.col2.x*normal1X+tMat.col2.y*normal1Y);
normal1X=tX;
index=0;
minDot=Number.MAX_VALUE;
for(i=0;i<count2;++i)
{
tVec=normals2[i];
dot=(normal1X*tVec.x+normal1Y*tVec.y);
if(dot<minDot)
{
minDot=dot;
index=i
}
}
tClip;
i1=index;
i2=flash.int(i1+1<count2?i1+1:0);
tClip=c[0];
tVec=vertices2[i1];
tMat=xf2.R;
tClip.v.x=xf2.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
tClip.v.y=xf2.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tClip.id.features.set_referenceEdge(edge1);
tClip.id.features.set_incidentEdge(i1);
tClip.id.features.set_incidentVertex(0);
tClip=c[1];
tVec=vertices2[i2];
tMat=xf2.R;
tClip.v.x=xf2.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
tClip.v.y=xf2.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tClip.id.features.set_referenceEdge(edge1);
tClip.id.features.set_incidentEdge(i2);
tClip.id.features.set_incidentVertex(1);
};
s.CollidePolygons=function(manifold,polyA,xfA,polyB,xfB)
{
var cv=null;
var totalRadius=0;
var edgeA=0;
var separationA=0;
var edgeB=0;
var separationB=0;
var poly1=null;
var poly2=null;
var xf1=null;
var xf2=null;
var edge1=0;
var flip=0;
var k_relativeTol=0;
var k_absoluteTol=0;
var tMat=null;
var incidentEdge=null;
var count1=0;
var vertices1=null;
var local_v11=null;
var local_v12=null;
var localTangent=null;
var localNormal=null;
var planePoint=null;
var tangent=null;
var tangent2=null;
var normal=null;
var v11=null;
var v12=null;
var frontOffset=0;
var sideOffset1=0;
var sideOffset2=0;
var clipPoints1=null;
var clipPoints2=null;
var np=0;
var pointCount=0;
var i=0;
var separation=0;
var cp=null;
var tX=0;
var tY=0;
cv;
manifold.m_pointCount=0;
totalRadius=polyA.m_radius+polyB.m_radius;
edgeA=0;
Box2D.Collision.b2Collision.s_edgeAO[0]=edgeA;
separationA=Box2D.Collision.b2Collision.FindMaxSeparation(Box2D.Collision.b2Collision.s_edgeAO,polyA,xfA,polyB,xfB);
edgeA=Box2D.Collision.b2Collision.s_edgeAO[0];
if(separationA>totalRadius)
{
return
}
edgeB=0;
Box2D.Collision.b2Collision.s_edgeBO[0]=edgeB;
separationB=Box2D.Collision.b2Collision.FindMaxSeparation(Box2D.Collision.b2Collision.s_edgeBO,polyB,xfB,polyA,xfA);
edgeB=Box2D.Collision.b2Collision.s_edgeBO[0];
if(separationB>totalRadius)
{
return
}
poly1;
poly2;
xf1;
xf2;
edge1;
flip;
k_relativeTol=0.98;
k_absoluteTol=0.001;
tMat;
if(separationB>k_relativeTol*separationA+k_absoluteTol)
{
poly1=polyB;
poly2=polyA;
xf1=xfB;
xf2=xfA;
edge1=edgeB;
manifold.m_type=Box2D.Collision.b2Manifold.e_faceB;
flip=1
}
else
{
poly1=polyA;
poly2=polyB;
xf1=xfA;
xf2=xfB;
edge1=edgeA;
manifold.m_type=Box2D.Collision.b2Manifold.e_faceA;
flip=0
}
incidentEdge=Box2D.Collision.b2Collision.s_incidentEdge;
Box2D.Collision.b2Collision.FindIncidentEdge(incidentEdge,poly1,xf1,edge1,poly2,xf2);
count1=poly1.m_vertexCount;
vertices1=poly1.m_vertices;
local_v11=vertices1[edge1];
local_v12;
if(edge1+1<count1)
{
local_v12=vertices1[flash.int(edge1+1)]
}
else
{
local_v12=vertices1[0]
}
localTangent=Box2D.Collision.b2Collision.s_localTangent;
localTangent.Set(local_v12.x-local_v11.x,local_v12.y-local_v11.y);
localTangent.Normalize();
localNormal=Box2D.Collision.b2Collision.s_localNormal;
localNormal.x=localTangent.y;
localNormal.y=-localTangent.x;
planePoint=Box2D.Collision.b2Collision.s_planePoint;
planePoint.Set(0.5*(local_v11.x+local_v12.x),0.5*(local_v11.y+local_v12.y));
tangent=Box2D.Collision.b2Collision.s_tangent;
tMat=xf1.R;
tangent.x=(tMat.col1.x*localTangent.x+tMat.col2.x*localTangent.y);
tangent.y=(tMat.col1.y*localTangent.x+tMat.col2.y*localTangent.y);
tangent2=Box2D.Collision.b2Collision.s_tangent2;
tangent2.x=-tangent.x;
tangent2.y=-tangent.y;
normal=Box2D.Collision.b2Collision.s_normal;
normal.x=tangent.y;
normal.y=-tangent.x;
v11=Box2D.Collision.b2Collision.s_v11;
v12=Box2D.Collision.b2Collision.s_v12;
v11.x=xf1.position.x+(tMat.col1.x*local_v11.x+tMat.col2.x*local_v11.y);
v11.y=xf1.position.y+(tMat.col1.y*local_v11.x+tMat.col2.y*local_v11.y);
v12.x=xf1.position.x+(tMat.col1.x*local_v12.x+tMat.col2.x*local_v12.y);
v12.y=xf1.position.y+(tMat.col1.y*local_v12.x+tMat.col2.y*local_v12.y);
frontOffset=normal.x*v11.x+normal.y*v11.y;
sideOffset1=-tangent.x*v11.x-tangent.y*v11.y+totalRadius;
sideOffset2=tangent.x*v12.x+tangent.y*v12.y+totalRadius;
clipPoints1=Box2D.Collision.b2Collision.s_clipPoints1;
clipPoints2=Box2D.Collision.b2Collision.s_clipPoints2;
np;
np=Box2D.Collision.b2Collision.ClipSegmentToLine(clipPoints1,incidentEdge,tangent2,sideOffset1);
if(np<2)
{
return
}
np=Box2D.Collision.b2Collision.ClipSegmentToLine(clipPoints2,clipPoints1,tangent,sideOffset2);
if(np<2)
{
return
}
manifold.m_localPlaneNormal.SetV(localNormal);
manifold.m_localPoint.SetV(planePoint);
pointCount=0;
for(i=0;i<Box2D.Common.b2Settings.b2_maxManifoldPoints;++i)
{
cv=clipPoints2[i];
separation=normal.x*cv.v.x+normal.y*cv.v.y-frontOffset;
if(separation<=totalRadius)
{
cp=manifold.m_points[pointCount];
tMat=xf2.R;
tX=cv.v.x-xf2.position.x;
tY=cv.v.y-xf2.position.y;
cp.m_localPoint.x=(tX*tMat.col1.x+tY*tMat.col1.y);
cp.m_localPoint.y=(tX*tMat.col2.x+tY*tMat.col2.y);
cp.m_id.Set(cv.id);
cp.m_id.features.set_flip(flip);
++pointCount
}
}
manifold.m_pointCount=pointCount;
};
s.CollideCircles=function(manifold,circle1,xf1,circle2,xf2)
{
var tMat=null;
var tVec=null;
var p1X=0;
var p1Y=0;
var p2X=0;
var p2Y=0;
var dX=0;
var dY=0;
var distSqr=0;
var radius=0;
manifold.m_pointCount=0;
tMat;
tVec;
tMat=xf1.R;
tVec=circle1.m_p;
p1X=xf1.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
p1Y=xf1.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tMat=xf2.R;
tVec=circle2.m_p;
p2X=xf2.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
p2Y=xf2.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
dX=p2X-p1X;
dY=p2Y-p1Y;
distSqr=dX*dX+dY*dY;
radius=circle1.m_radius+circle2.m_radius;
if(distSqr>radius*radius)
{
return
}
manifold.m_type=Box2D.Collision.b2Manifold.e_circles;
manifold.m_localPoint.SetV(circle1.m_p);
manifold.m_localPlaneNormal.SetZero();
manifold.m_pointCount=1;
manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
manifold.m_points[0].m_id.set_key(0);
};
s.CollidePolygonAndCircle=function(manifold,polygon,xf1,circle,xf2)
{
var tPoint=null;
var dX=0;
var dY=0;
var positionX=0;
var positionY=0;
var tVec=null;
var tMat=null;
var cX=0;
var cY=0;
var cLocalX=0;
var cLocalY=0;
var dist=0;
var normalIndex=0;
var separation=0;
var radius=0;
var vertexCount=0;
var vertices=null;
var normals=null;
var i=0;
var s=0;
var vertIndex1=0;
var vertIndex2=0;
var v1=null;
var v2=null;
var u1=0;
var u2=0;
var faceCenterX=0;
var faceCenterY=0;
manifold.m_pointCount=0;
tPoint;
dX;
dY;
positionX;
positionY;
tVec;
tMat;
tMat=xf2.R;
tVec=circle.m_p;
cX=xf2.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
cY=xf2.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
dX=cX-xf1.position.x;
dY=cY-xf1.position.y;
tMat=xf1.R;
cLocalX=(dX*tMat.col1.x+dY*tMat.col1.y);
cLocalY=(dX*tMat.col2.x+dY*tMat.col2.y);
dist;
normalIndex=0;
separation=-Number.MAX_VALUE;
radius=polygon.m_radius+circle.m_radius;
vertexCount=polygon.m_vertexCount;
vertices=polygon.m_vertices;
normals=polygon.m_normals;
for(i=0;i<vertexCount;++i)
{
tVec=vertices[i];
dX=cLocalX-tVec.x;
dY=cLocalY-tVec.y;
tVec=normals[i];
s=tVec.x*dX+tVec.y*dY;
if(s>radius)
{
return
}
if(s>separation)
{
separation=s;
normalIndex=i
}
}
vertIndex1=normalIndex;
vertIndex2=flash.int(vertIndex1+1<vertexCount?vertIndex1+1:0);
v1=vertices[vertIndex1];
v2=vertices[vertIndex2];
if(separation<Number.MIN_VALUE)
{
manifold.m_pointCount=1;
manifold.m_type=Box2D.Collision.b2Manifold.e_faceA;
manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
manifold.m_localPoint.x=0.5*(v1.x+v2.x);
manifold.m_localPoint.y=0.5*(v1.y+v2.y);
manifold.m_points[0].m_localPoint.SetV(circle.m_p);
manifold.m_points[0].m_id.set_key(0);
return
}
u1=(cLocalX-v1.x)*(v2.x-v1.x)+(cLocalY-v1.y)*(v2.y-v1.y);
u2=(cLocalX-v2.x)*(v1.x-v2.x)+(cLocalY-v2.y)*(v1.y-v2.y);
if(u1<=0.0)
{
if((cLocalX-v1.x)*(cLocalX-v1.x)+(cLocalY-v1.y)*(cLocalY-v1.y)>radius*radius)
{
return
}
manifold.m_pointCount=1;
manifold.m_type=Box2D.Collision.b2Manifold.e_faceA;
manifold.m_localPlaneNormal.x=cLocalX-v1.x;
manifold.m_localPlaneNormal.y=cLocalY-v1.y;
manifold.m_localPlaneNormal.Normalize();
manifold.m_localPoint.SetV(v1);
manifold.m_points[0].m_localPoint.SetV(circle.m_p);
manifold.m_points[0].m_id.set_key(0)
}
else if(u2<=0)
{
if((cLocalX-v2.x)*(cLocalX-v2.x)+(cLocalY-v2.y)*(cLocalY-v2.y)>radius*radius)
{
return
}
manifold.m_pointCount=1;
manifold.m_type=Box2D.Collision.b2Manifold.e_faceA;
manifold.m_localPlaneNormal.x=cLocalX-v2.x;
manifold.m_localPlaneNormal.y=cLocalY-v2.y;
manifold.m_localPlaneNormal.Normalize();
manifold.m_localPoint.SetV(v2);
manifold.m_points[0].m_localPoint.SetV(circle.m_p);
manifold.m_points[0].m_id.set_key(0)
}
else
{
faceCenterX=0.5*(v1.x+v2.x);
faceCenterY=0.5*(v1.y+v2.y);
separation=(cLocalX-faceCenterX)*normals[vertIndex1].x+(cLocalY-faceCenterY)*normals[vertIndex1].y;
if(separation>radius)
{
return
}
manifold.m_pointCount=1;
manifold.m_type=Box2D.Collision.b2Manifold.e_faceA;
manifold.m_localPlaneNormal.x=normals[vertIndex1].x;
manifold.m_localPlaneNormal.y=normals[vertIndex1].y;
manifold.m_localPlaneNormal.Normalize();
manifold.m_localPoint.Set(faceCenterX,faceCenterY);
manifold.m_points[0].m_localPoint.SetV(circle.m_p);
manifold.m_points[0].m_id.set_key(0)
}
};
s.TestOverlap=function(a,b)
{
var t1=null;
var t2=null;
var d1X=0;
var d1Y=0;
var d2X=0;
var d2Y=0;
t1=b.lowerBound;
t2=a.upperBound;
d1X=t1.x-t2.x;
d1Y=t1.y-t2.y;
t1=a.lowerBound;
t2=b.upperBound;
d2X=t1.x-t2.x;
d2Y=t1.y-t2.y;
if(d1X>0.0||d1Y>0.0)
{
return false
}
if(d2X>0.0||d2Y>0.0)
{
return false
}
return true;
};
s.MakeClipPointVector=function()
{
var r=null;
r=new Array();
r[0]=new Box2D.Collision.ClipVertex();
r[1]=new Box2D.Collision.ClipVertex();
return r;
};
flash.addDescription("Box2D.Collision.b2Collision",d,null,s,null,["Box2D.Common.Math.b2Vec2","Box2D.Collision.b2Manifold","Box2D.Common.b2Settings","Box2D.Collision.ClipVertex"]);
}
());;
(function()
{
"use strict";
var d={};
d.proxyA=null;
d.proxyB=null;
d.b2DynamicTreePair=function()
{
};
flash.addDescription("Box2D.Collision.b2DynamicTreePair",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.R=null;
d.center=null;
d.extents=null;
d.b2OBB=function()
{
this.R=new Box2D.Common.Math.b2Mat22();
this.center=new Box2D.Common.Math.b2Vec2();
this.extents=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Collision.b2OBB",d,null,null,null,["Box2D.Common.Math.b2Mat22","Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_vertices=null;
d.m_count=0;
d.m_radius=0;
d.Set=function(shape)
{
var circle=null;
var polygon=null;
switch(shape.GetType())
{
case Box2D.Collision.Shapes.b2Shape.e_circleShape:
{
circle=shape;
this.m_vertices=new Array();
this.m_vertices[0]=circle.m_p;
this.m_count=1;
this.m_radius=circle.m_radius
};
break;
;case Box2D.Collision.Shapes.b2Shape.e_polygonShape:
{
polygon=shape;
this.m_vertices=polygon.m_vertices;
this.m_count=polygon.m_vertexCount;
this.m_radius=polygon.m_radius
};
break;
;default:
Box2D.Common.b2Settings.b2Assert(false)
}
};
d.GetSupport=function(d)
{
var bestIndex=0;
var bestValue=0;
var i=0;
var value=0;
bestIndex=0;
bestValue=this.m_vertices[0].x*d.x+this.m_vertices[0].y*d.y;
for(i=1;i<this.m_count;++i)
{
value=this.m_vertices[i].x*d.x+this.m_vertices[i].y*d.y;
if(value>bestValue)
{
bestIndex=i;
bestValue=value
}
}
return bestIndex;
};
d.GetSupportVertex=function(d)
{
var bestIndex=0;
var bestValue=0;
var i=0;
var value=0;
bestIndex=0;
bestValue=this.m_vertices[0].x*d.x+this.m_vertices[0].y*d.y;
for(i=1;i<this.m_count;++i)
{
value=this.m_vertices[i].x*d.x+this.m_vertices[i].y*d.y;
if(value>bestValue)
{
bestIndex=i;
bestValue=value
}
}
return this.m_vertices[bestIndex];
};
d.GetVertexCount=function()
{
return this.m_count;
};
d.GetVertex=function(index)
{
index=flash.int(index);
Box2D.Common.b2Settings.b2Assert(0<=index&&index<this.m_count);
return this.m_vertices[index];
};
d.b2DistanceProxy=function()
{
};
flash.addDescription("Box2D.Collision.b2DistanceProxy",d,null,null,null,["Box2D.Collision.Shapes.b2Shape","Box2D.Collision.Shapes.b2CircleShape","Box2D.Common.Math.b2Vec2","Box2D.Collision.Shapes.b2PolygonShape","Box2D.Common.b2Settings"]);
}
());;
(function()
{
"use strict";
var d={};
d.normal=null;
d.fraction=0;
d.b2RayCastOutput=function()
{
this.normal=new Box2D.Common.Math.b2Vec2();
};
flash.addDescription("Box2D.Collision.b2RayCastOutput",d,null,null,null,["Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.b2Distance=function()
{
};
var s={};
s.__init__=function()
{
this.b2_gjkCalls=0;
this.b2_gjkIters=0;
this.b2_gjkMaxIters=0;
this.s_simplex=new Box2D.Collision.b2Simplex();
this.s_saveA=new Array();
this.s_saveB=new Array();
};
s.Distance=function(output,cache,input)
{
var proxyA=null;
var proxyB=null;
var transformA=null;
var transformB=null;
var simplex=null;
var vertices=null;
var k_maxIters=0;
var saveA=null;
var saveB=null;
var saveCount=0;
var closestPoint=null;
var distanceSqr1=0;
var distanceSqr2=0;
var i=0;
var p=null;
var iter=0;
var d=null;
var vertex=null;
var duplicate=false;
var rA=0;
var rB=0;
var normal=null;
++Box2D.Collision.b2Distance.b2_gjkCalls;
proxyA=input.proxyA;
proxyB=input.proxyB;
transformA=input.transformA;
transformB=input.transformB;
simplex=Box2D.Collision.b2Distance.s_simplex;
simplex.ReadCache(cache,proxyA,transformA,proxyB,transformB);
vertices=simplex.m_vertices;
k_maxIters=20;
saveA=Box2D.Collision.b2Distance.s_saveA;
saveB=Box2D.Collision.b2Distance.s_saveB;
saveCount=0;
closestPoint=simplex.GetClosestPoint();
distanceSqr1=closestPoint.LengthSquared();
distanceSqr2=distanceSqr1;
i;
p;
iter=0;
while(iter<k_maxIters)
{
saveCount=simplex.m_count;
for(i=0;i<saveCount;i++)
{
saveA[i]=vertices[i].indexA;
saveB[i]=vertices[i].indexB
}
switch(simplex.m_count)
{
case 1:
break;
;case 2:
simplex.Solve2();
break;
;case 3:
simplex.Solve3();
break;
;default:
Box2D.Common.b2Settings.b2Assert(false)
}
if(simplex.m_count==3)
{
break;
;
}
p=simplex.GetClosestPoint();
distanceSqr2=p.LengthSquared();
if(distanceSqr2>distanceSqr1)
{
}
distanceSqr1=distanceSqr2;
d=simplex.GetSearchDirection();
if(d.LengthSquared()<Number.MIN_VALUE*Number.MIN_VALUE)
{
break;
;
}
vertex=vertices[simplex.m_count];
vertex.indexA=flash.int(proxyA.GetSupport(Box2D.Common.Math.b2Math.MulTMV(transformA.R,d.GetNegative())));
vertex.wA=Box2D.Common.Math.b2Math.MulX(transformA,proxyA.GetVertex(vertex.indexA));
vertex.indexB=flash.int(proxyB.GetSupport(Box2D.Common.Math.b2Math.MulTMV(transformB.R,d)));
vertex.wB=Box2D.Common.Math.b2Math.MulX(transformB,proxyB.GetVertex(vertex.indexB));
vertex.w=Box2D.Common.Math.b2Math.SubtractVV(vertex.wB,vertex.wA);
++iter;
++Box2D.Collision.b2Distance.b2_gjkIters;
duplicate=false;
for(i=0;i<saveCount;i++)
{
if(vertex.indexA==saveA[i]&&vertex.indexB==saveB[i])
{
duplicate=true;
break;
;
}
}
if(duplicate)
{
break;
;
}
;++simplex.m_count
}
Box2D.Collision.b2Distance.b2_gjkMaxIters=flash.int(Box2D.Common.Math.b2Math.Max(Box2D.Collision.b2Distance.b2_gjkMaxIters,iter));
simplex.GetWitnessPoints(output.pointA,output.pointB);
output.distance=Box2D.Common.Math.b2Math.SubtractVV(output.pointA,output.pointB).Length();
output.iterations=iter;
simplex.WriteCache(cache);
if(input.useRadii)
{
rA=proxyA.m_radius;
rB=proxyB.m_radius;
if(output.distance>rA+rB&&output.distance>Number.MIN_VALUE)
{
output.distance-=rA+rB;
normal=Box2D.Common.Math.b2Math.SubtractVV(output.pointB,output.pointA);
normal.Normalize();
output.pointA.x+=rA*normal.x;
output.pointA.y+=rA*normal.y;
output.pointB.x-=rB*normal.x;
output.pointB.y-=rB*normal.y
}
else
{
p=new Box2D.Common.Math.b2Vec2();
p.x=.5*(output.pointA.x+output.pointB.x);
p.y=.5*(output.pointA.y+output.pointB.y);
output.pointA.x=output.pointB.x=p.x;
output.pointA.y=output.pointB.y=p.y;
output.distance=0.0
}
}
};
flash.addDescription("Box2D.Collision.b2Distance",d,null,s,null,["Box2D.Collision.b2Simplex","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math","Box2D.Common.Math.b2Vec2"]);
}
());;
(function()
{
"use strict";
var d={};
d.userData=null;
d.aabb=null;
d.parent=null;
d.child1=null;
d.child2=null;
d.IsLeaf=function()
{
return this.child1==null;
};
d.b2DynamicTreeNode=function()
{
this.aabb=new Box2D.Collision.b2AABB();
};
flash.addDescription("Box2D.Collision.b2DynamicTreeNode",d,null,null,null,["Box2D.Collision.b2AABB"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_proxyA=null;
d.m_proxyB=null;
d.m_type=0;
d.m_localPoint=null;
d.m_axis=null;
d.Initialize=function(cache,proxyA,transformA,proxyB,transformB)
{
var count=0;
var localPointA=null;
var localPointA1=null;
var localPointA2=null;
var localPointB=null;
var localPointB1=null;
var localPointB2=null;
var pointAX=0;
var pointAY=0;
var pointBX=0;
var pointBY=0;
var normalX=0;
var normalY=0;
var tMat=null;
var tVec=null;
var s=0;
var sgn=0;
var pA=null;
var dA=null;
var pB=null;
var dB=null;
var a=0;
var e=0;
var r=null;
var c=0;
var f=0;
var b=0;
var denom=0;
var t=0;
this.m_proxyA=proxyA;
this.m_proxyB=proxyB;
count=cache.count;
Box2D.Common.b2Settings.b2Assert(0<count&&count<3);
localPointA;
localPointA1;
localPointA2;
localPointB;
localPointB1;
localPointB2;
pointAX;
pointAY;
pointBX;
pointBY;
normalX;
normalY;
tMat;
tVec;
s;
sgn;
if(count==1)
{
this.m_type=Box2D.Collision.b2SeparationFunction.e_points;
localPointA=this.m_proxyA.GetVertex(cache.indexA[0]);
localPointB=this.m_proxyB.GetVertex(cache.indexB[0]);
tVec=localPointA;
tMat=transformA.R;
pointAX=transformA.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointAY=transformA.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tVec=localPointB;
tMat=transformB.R;
pointBX=transformB.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointBY=transformB.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
this.m_axis.x=pointBX-pointAX;
this.m_axis.y=pointBY-pointAY;
this.m_axis.Normalize()
}
else if(cache.indexB[0]==cache.indexB[1])
{
this.m_type=Box2D.Collision.b2SeparationFunction.e_faceA;
localPointA1=this.m_proxyA.GetVertex(cache.indexA[0]);
localPointA2=this.m_proxyA.GetVertex(cache.indexA[1]);
localPointB=this.m_proxyB.GetVertex(cache.indexB[0]);
this.m_localPoint.x=0.5*(localPointA1.x+localPointA2.x);
this.m_localPoint.y=0.5*(localPointA1.y+localPointA2.y);
this.m_axis=Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointA2,localPointA1),1.0);
this.m_axis.Normalize();
tVec=this.m_axis;
tMat=transformA.R;
normalX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
normalY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tVec=this.m_localPoint;
tMat=transformA.R;
pointAX=transformA.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointAY=transformA.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tVec=localPointB;
tMat=transformB.R;
pointBX=transformB.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointBY=transformB.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
s=(pointBX-pointAX)*normalX+(pointBY-pointAY)*normalY;
if(s<0.0)
{
this.m_axis.NegativeSelf()
}
}
else if(cache.indexA[0]==cache.indexA[0])
{
this.m_type=Box2D.Collision.b2SeparationFunction.e_faceB;
localPointB1=this.m_proxyB.GetVertex(cache.indexB[0]);
localPointB2=this.m_proxyB.GetVertex(cache.indexB[1]);
localPointA=this.m_proxyA.GetVertex(cache.indexA[0]);
this.m_localPoint.x=0.5*(localPointB1.x+localPointB2.x);
this.m_localPoint.y=0.5*(localPointB1.y+localPointB2.y);
this.m_axis=Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointB2,localPointB1),1.0);
this.m_axis.Normalize();
tVec=this.m_axis;
tMat=transformB.R;
normalX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
normalY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tVec=this.m_localPoint;
tMat=transformB.R;
pointBX=transformB.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointBY=transformB.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tVec=localPointA;
tMat=transformA.R;
pointAX=transformA.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointAY=transformA.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
s=(pointAX-pointBX)*normalX+(pointAY-pointBY)*normalY;
if(s<0.0)
{
this.m_axis.NegativeSelf()
}
}
else
{
localPointA1=this.m_proxyA.GetVertex(cache.indexA[0]);
localPointA2=this.m_proxyA.GetVertex(cache.indexA[1]);
localPointB1=this.m_proxyB.GetVertex(cache.indexB[0]);
localPointB2=this.m_proxyB.GetVertex(cache.indexB[1]);
pA=Box2D.Common.Math.b2Math.MulX(transformA,localPointA);
dA=Box2D.Common.Math.b2Math.MulMV(transformA.R,Box2D.Common.Math.b2Math.SubtractVV(localPointA2,localPointA1));
pB=Box2D.Common.Math.b2Math.MulX(transformB,localPointB);
dB=Box2D.Common.Math.b2Math.MulMV(transformB.R,Box2D.Common.Math.b2Math.SubtractVV(localPointB2,localPointB1));
a=dA.x*dA.x+dA.y*dA.y;
e=dB.x*dB.x+dB.y*dB.y;
r=Box2D.Common.Math.b2Math.SubtractVV(dB,dA);
c=dA.x*r.x+dA.y*r.y;
f=dB.x*r.x+dB.y*r.y;
b=dA.x*dB.x+dA.y*dB.y;
denom=a*e-b*b;
s=0.0;
if(denom!=0.0)
{
s=Box2D.Common.Math.b2Math.Clamp((b*f-c*e)/denom,0.0,1.0)
}
t=(b*s+f)/e;
if(t<0.0)
{
t=0.0;
s=Box2D.Common.Math.b2Math.Clamp((b-c)/a,0.0,1.0)
}
localPointA=new Box2D.Common.Math.b2Vec2();
localPointA.x=localPointA1.x+s*(localPointA2.x-localPointA1.x);
localPointA.y=localPointA1.y+s*(localPointA2.y-localPointA1.y);
localPointB=new Box2D.Common.Math.b2Vec2();
localPointB.x=localPointB1.x+s*(localPointB2.x-localPointB1.x);
localPointB.y=localPointB1.y+s*(localPointB2.y-localPointB1.y);
if(s==0.0||s==1.0)
{
this.m_type=Box2D.Collision.b2SeparationFunction.e_faceB;
this.m_axis=Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointB2,localPointB1),1.0);
this.m_axis.Normalize();
this.m_localPoint=localPointB;
tVec=this.m_axis;
tMat=transformB.R;
normalX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
normalY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tVec=this.m_localPoint;
tMat=transformB.R;
pointBX=transformB.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointBY=transformB.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tVec=localPointA;
tMat=transformA.R;
pointAX=transformA.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointAY=transformA.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
sgn=(pointAX-pointBX)*normalX+(pointAY-pointBY)*normalY;
if(s<0.0)
{
this.m_axis.NegativeSelf()
}
}
else
{
this.m_type=Box2D.Collision.b2SeparationFunction.e_faceA;
this.m_axis=Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointA2,localPointA1),1.0);
this.m_localPoint=localPointA;
tVec=this.m_axis;
tMat=transformA.R;
normalX=tMat.col1.x*tVec.x+tMat.col2.x*tVec.y;
normalY=tMat.col1.y*tVec.x+tMat.col2.y*tVec.y;
tVec=this.m_localPoint;
tMat=transformA.R;
pointAX=transformA.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointAY=transformA.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
tVec=localPointB;
tMat=transformB.R;
pointBX=transformB.position.x+(tMat.col1.x*tVec.x+tMat.col2.x*tVec.y);
pointBY=transformB.position.y+(tMat.col1.y*tVec.x+tMat.col2.y*tVec.y);
sgn=(pointBX-pointAX)*normalX+(pointBY-pointAY)*normalY;
if(s<0.0)
{
this.m_axis.NegativeSelf()
}
}
}
};
d.Evaluate=function(transformA,transformB)
{
var axisA=null;
var axisB=null;
var localPointA=null;
var localPointB=null;
var pointA=null;
var pointB=null;
var seperation=0;
var normal=null;
axisA;
axisB;
localPointA;
localPointB;
pointA;
pointB;
seperation;
normal;
switch(this.m_type)
{
case Box2D.Collision.b2SeparationFunction.e_points:
{
axisA=Box2D.Common.Math.b2Math.MulTMV(transformA.R,this.m_axis);
axisB=Box2D.Common.Math.b2Math.MulTMV(transformB.R,this.m_axis.GetNegative());
localPointA=this.m_proxyA.GetSupportVertex(axisA);
localPointB=this.m_proxyB.GetSupportVertex(axisB);
pointA=Box2D.Common.Math.b2Math.MulX(transformA,localPointA);
pointB=Box2D.Common.Math.b2Math.MulX(transformB,localPointB);
seperation=(pointB.x-pointA.x)*this.m_axis.x+(pointB.y-pointA.y)*this.m_axis.y;
return seperation
};
case Box2D.Collision.b2SeparationFunction.e_faceA:
{
normal=Box2D.Common.Math.b2Math.MulMV(transformA.R,this.m_axis);
pointA=Box2D.Common.Math.b2Math.MulX(transformA,this.m_localPoint);
axisB=Box2D.Common.Math.b2Math.MulTMV(transformB.R,normal.GetNegative());
localPointB=this.m_proxyB.GetSupportVertex(axisB);
pointB=Box2D.Common.Math.b2Math.MulX(transformB,localPointB);
seperation=(pointB.x-pointA.x)*normal.x+(pointB.y-pointA.y)*normal.y;
return seperation
};
case Box2D.Collision.b2SeparationFunction.e_faceB:
{
normal=Box2D.Common.Math.b2Math.MulMV(transformB.R,this.m_axis);
pointB=Box2D.Common.Math.b2Math.MulX(transformB,this.m_localPoint);
axisA=Box2D.Common.Math.b2Math.MulTMV(transformA.R,normal.GetNegative());
localPointA=this.m_proxyA.GetSupportVertex(axisA);
pointA=Box2D.Common.Math.b2Math.MulX(transformA,localPointA);
seperation=(pointA.x-pointB.x)*normal.x+(pointA.y-pointB.y)*normal.y;
return seperation
};
default:
Box2D.Common.b2Settings.b2Assert(false);
return 0.0
}
};
d.b2SeparationFunction=function()
{
this.m_localPoint=new Box2D.Common.Math.b2Vec2();
this.m_axis=new Box2D.Common.Math.b2Vec2();
};
var s={};
s.__init__=function()
{
this.e_points=0x01;
this.e_faceA=0x02;
this.e_faceB=0x04;
};
flash.addDescription("Box2D.Collision.b2SeparationFunction",d,null,s,null,["Box2D.Common.Math.b2Vec2","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_points=null;
d.m_localPlaneNormal=null;
d.m_localPoint=null;
d.m_type=0;
d.m_pointCount=0;
d.b2Manifold=function()
{
var i=0;
this.m_points=new Array();
for(i=0;i<Box2D.Common.b2Settings.b2_maxManifoldPoints;i++)
{
this.m_points[i]=new Box2D.Collision.b2ManifoldPoint()
}
this.m_localPlaneNormal=new Box2D.Common.Math.b2Vec2();
this.m_localPoint=new Box2D.Common.Math.b2Vec2();
};
d.Reset=function()
{
var i=0;
for(i=0;i<Box2D.Common.b2Settings.b2_maxManifoldPoints;i++)
{
(this.m_points[i]).Reset()
}
this.m_localPlaneNormal.SetZero();
this.m_localPoint.SetZero();
this.m_type=0;
this.m_pointCount=0;
};
d.Set=function(m)
{
var i=0;
this.m_pointCount=m.m_pointCount;
for(i=0;i<Box2D.Common.b2Settings.b2_maxManifoldPoints;i++)
{
(this.m_points[i]).Set(m.m_points[i])
}
this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
this.m_localPoint.SetV(m.m_localPoint);
this.m_type=m.m_type;
};
d.Copy=function()
{
var copy=null;
copy=new Box2D.Collision.b2Manifold();
copy.Set(this);
return copy;
};
var s={};
s.__init__=function()
{
this.e_circles=0x0001;
this.e_faceA=0x0002;
this.e_faceB=0x0004;
};
flash.addDescription("Box2D.Collision.b2Manifold",d,null,s,null,["Box2D.Collision.b2ManifoldPoint","Box2D.Common.b2Settings","Box2D.Common.Math.b2Vec2","Box2D.Collision.b2Manifold"]);
}
());;
(function()
{
"use strict";
var d={};
d._m_id=null;
d._referenceEdge=0;
d._incidentEdge=0;
d._incidentVertex=0;
d._flip=0;
d.get_referenceEdge=function()
{
return this._referenceEdge;
};
d.set_referenceEdge=function(value)
{
value=flash.int(value);
this._referenceEdge=value;
this._m_id._key=(this._m_id._key&0xffffff00)|(this._referenceEdge&0x000000ff);
};
d.get_incidentEdge=function()
{
return this._incidentEdge;
};
d.set_incidentEdge=function(value)
{
value=flash.int(value);
this._incidentEdge=value;
this._m_id._key=(this._m_id._key&0xffff00ff)|((this._incidentEdge<<8)&0x0000ff00);
};
d.get_incidentVertex=function()
{
return this._incidentVertex;
};
d.set_incidentVertex=function(value)
{
value=flash.int(value);
this._incidentVertex=value;
this._m_id._key=(this._m_id._key&0xff00ffff)|((this._incidentVertex<<16)&0x00ff0000);
};
d.get_flip=function()
{
return this._flip;
};
d.set_flip=function(value)
{
value=flash.int(value);
this._flip=value;
this._m_id._key=(this._m_id._key&0x00ffffff)|((this._flip<<24)&0xff000000);
};
d.Features=function()
{
};
flash.addDescription("Box2D.Collision.Features",d,null,null,null,null);
}
());;
(function()
{
"use strict";
var d={};
d.m_root=null;
d.m_freeList=null;
d.m_path=0;
d.m_insertionCount=0;
d.b2DynamicTree=function()
{
this.m_root=null;
this.m_freeList=null;
this.m_path=0;
this.m_insertionCount=0;
};
d.CreateProxy=function(aabb,userData)
{
var node=null;
var extendX=0;
var extendY=0;
node=this.AllocateNode();
extendX=Box2D.Common.b2Settings.b2_aabbExtension;
extendY=Box2D.Common.b2Settings.b2_aabbExtension;
node.aabb.lowerBound.x=aabb.lowerBound.x-extendX;
node.aabb.lowerBound.y=aabb.lowerBound.y-extendY;
node.aabb.upperBound.x=aabb.upperBound.x+extendX;
node.aabb.upperBound.y=aabb.upperBound.y+extendY;
node.userData=userData;
this.InsertLeaf(node);
return node;
};
d.DestroyProxy=function(proxy)
{
this.RemoveLeaf(proxy);
this.FreeNode(proxy);
};
d.MoveProxy=function(proxy,aabb,displacement)
{
var extendX=0;
var extendY=0;
Box2D.Common.b2Settings.b2Assert(proxy.IsLeaf());
if(proxy.aabb.Contains(aabb))
{
return false
}
this.RemoveLeaf(proxy);
extendX=Box2D.Common.b2Settings.b2_aabbExtension+Box2D.Common.b2Settings.b2_aabbMultiplier*(displacement.x>0?displacement.x:-displacement.x);
extendY=Box2D.Common.b2Settings.b2_aabbExtension+Box2D.Common.b2Settings.b2_aabbMultiplier*(displacement.y>0?displacement.y:-displacement.y);
proxy.aabb.lowerBound.x=aabb.lowerBound.x-extendX;
proxy.aabb.lowerBound.y=aabb.lowerBound.y-extendY;
proxy.aabb.upperBound.x=aabb.upperBound.x+extendX;
proxy.aabb.upperBound.y=aabb.upperBound.y+extendY;
this.InsertLeaf(proxy);
return true;
};
d.Rebalance=function(iterations)
{
iterations=flash.int(iterations);
var i=0;
var node=null;
var bit=0;
if(this.m_root==null)
{
return
}
for(i=0;i<iterations;i++)
{
node=this.m_root;
bit=0;
while(node.IsLeaf()==false)
{
node=(this.m_path>>bit)&1?node.child2:node.child1;
bit=(bit+1)&31
}
;++this.m_path;
this.RemoveLeaf(node);
this.InsertLeaf(node)
}
};
d.GetFatAABB=function(proxy)
{
return proxy.aabb;
};
d.GetUserData=function(proxy)
{
return proxy.userData;
};
d.Query=function(callback,aabb)
{
var stack=null;
var count=0;
var node=null;
var proceed=false;
if(this.m_root==null)
{
return
}
stack=new Array();
count=0;
stack[count++]=this.m_root;
while(count>0)
{
node=stack[--count];
if(node.aabb.TestOverlap(aabb))
{
if(node.IsLeaf())
{
proceed=callback(node);
if(!proceed)
{
return
}
}
else
{
stack[count++]=node.child1;
stack[count++]=node.child2
}
}
}
};
d.RayCast=function(callback,input)
{
var p1=null;
var p2=null;
var r=null;
var v=null;
var abs_v=null;
var maxFraction=0;
var segmentAABB=null;
var tX=0;
var tY=0;
var stack=null;
var count=0;
var node=null;
var c=null;
var h=null;
var separation=0;
var subInput=null;
if(this.m_root==null)
{
return
}
p1=input.p1;
p2=input.p2;
r=Box2D.Common.Math.b2Math.SubtractVV(p1,p2);
r.Normalize();
v=Box2D.Common.Math.b2Math.CrossFV(1.0,r);
abs_v=Box2D.Common.Math.b2Math.AbsV(v);
maxFraction=input.maxFraction;
segmentAABB=new Box2D.Collision.b2AABB();
tX;
tY;
{
tX=p1.x+maxFraction*(p2.x-p1.x);
tY=p1.y+maxFraction*(p2.y-p1.y);
segmentAABB.lowerBound.x=Math.min(p1.x,tX);
segmentAABB.lowerBound.y=Math.min(p1.y,tY);
segmentAABB.upperBound.x=Math.max(p1.x,tX);
segmentAABB.upperBound.y=Math.max(p1.y,tY)
};
stack=new Array();
count=0;
stack[count++]=this.m_root;
while(count>0)
{
node=stack[--count];
if(node.aabb.TestOverlap(segmentAABB)==false)
{
continue;
;
}
c=node.aabb.GetCenter();
h=node.aabb.GetExtents();
separation=Math.abs(v.x*(p1.x-c.x)+v.y*(p1.y-c.y))-abs_v.x*h.x-abs_v.y*h.y;
if(separation>0.0)
{
continue
}
;if(node.IsLeaf())
{
subInput=new Box2D.Collision.b2RayCastInput();
subInput.p1=input.p1;
subInput.p2=input.p2;
subInput.maxFraction=input.maxFraction;
maxFraction=callback(subInput,node);
if(maxFraction==0.0)
{
return
}
{
tX=p1.x+maxFraction*(p2.x-p1.x);
tY=p1.y+maxFraction*(p2.y-p1.y);
segmentAABB.lowerBound.x=Math.min(p1.x,tX);
segmentAABB.lowerBound.y=Math.min(p1.y,tY);
segmentAABB.upperBound.x=Math.max(p1.x,tX);
segmentAABB.upperBound.y=Math.max(p1.y,tY)
}
}
else
{
stack[count++]=node.child1;
stack[count++]=node.child2
}
}
};
d.AllocateNode=function()
{
var node=null;
if(this.m_freeList)
{
node=this.m_freeList;
this.m_freeList=node.parent;
node.parent=null;
node.child1=null;
node.child2=null;
return node
}
return new Box2D.Collision.b2DynamicTreeNode();
};
d.FreeNode=function(node)
{
node.parent=this.m_freeList;
this.m_freeList=node;
};
d.InsertLeaf=function(leaf)
{
var center=null;
var sibling=null;
var child1=null;
var child2=null;
var norm1=0;
var norm2=0;
var node1=null;
var node2=null;
++this.m_insertionCount;
if(this.m_root==null)
{
this.m_root=leaf;
this.m_root.parent=null;
return
}
center=leaf.aabb.GetCenter();
sibling=this.m_root;
if(sibling.IsLeaf()==false)
{
do
{
child1=sibling.child1;
child2=sibling.child2;
norm1=Math.abs((child1.aabb.lowerBound.x+child1.aabb.upperBound.x)/2-center.x)+Math.abs((child1.aabb.lowerBound.y+child1.aabb.upperBound.y)/2-center.y);
norm2=Math.abs((child2.aabb.lowerBound.x+child2.aabb.upperBound.x)/2-center.x)+Math.abs((child2.aabb.lowerBound.y+child2.aabb.upperBound.y)/2-center.y);
if(norm1<norm2)
{
sibling=child1
}
else
{
sibling=child2
}
}
while(sibling.IsLeaf()==false)
;
}
node1=sibling.parent;
node2=this.AllocateNode();
node2.parent=node1;
node2.userData=null;
node2.aabb.Combine(leaf.aabb,sibling.aabb);
if(node1)
{
if(sibling.parent.child1==sibling)
{
node1.child1=node2
}
else
{
node1.child2=node2
}
node2.child1=sibling;
node2.child2=leaf;
sibling.parent=node2;
leaf.parent=node2;
do
{
if(node1.aabb.Contains(node2.aabb))
{
break
}
;node1.aabb.Combine(node1.child1.aabb,node1.child2.aabb);
node2=node1;
node1=node1.parent
}
while(node1)
;
}
else
{
node2.child1=sibling;
node2.child2=leaf;
sibling.parent=node2;
leaf.parent=node2;
this.m_root=node2
}
};
d.RemoveLeaf=function(leaf)
{
var node2=null;
var node1=null;
var sibling=null;
var oldAABB=null;
if(leaf==this.m_root)
{
this.m_root=null;
return
}
node2=leaf.parent;
node1=node2.parent;
sibling;
if(node2.child1==leaf)
{
sibling=node2.child2
}
else
{
sibling=node2.child1
}
if(node1)
{
if(node1.child1==node2)
{
node1.child1=sibling
}
else
{
node1.child2=sibling
}
sibling.parent=node1;
this.FreeNode(node2);
while(node1)
{
oldAABB=node1.aabb;
node1.aabb=Box2D.Collision.b2AABB.Combine(node1.child1.aabb,node1.child2.aabb);
if(oldAABB.Contains(node1.aabb))
{
break
}
;node1=node1.parent
}
}
else
{
this.m_root=sibling;
sibling.parent=null;
this.FreeNode(node2)
}
};
flash.addDescription("Box2D.Collision.b2DynamicTree",d,null,null,null,["Box2D.Common.b2Settings","Box2D.Collision.b2DynamicTreeNode","Box2D.Common.Math.b2Math","Box2D.Collision.b2AABB","Box2D.Collision.b2RayCastInput"]);
}
());;
(function()
{
"use strict";
var d={};
d.m_v1=null;
d.m_v2=null;
d.m_v3=null;
d.m_vertices=null;
d.m_count=0;
d.b2Simplex=function()
{
this.m_v1=new Box2D.Collision.b2SimplexVertex();
this.m_v2=new Box2D.Collision.b2SimplexVertex();
this.m_v3=new Box2D.Collision.b2SimplexVertex();
this.m_vertices=new Array();
this.m_vertices[0]=this.m_v1;
this.m_vertices[1]=this.m_v2;
this.m_vertices[2]=this.m_v3;
};
d.ReadCache=function(cache,proxyA,transformA,proxyB,transformB)
{
var wALocal=null;
var wBLocal=null;
var vertices=null;
var i=0;
var v=null;
var metric1=0;
var metric2=0;
Box2D.Common.b2Settings.b2Assert(0<=cache.count&&cache.count<=3);
wALocal;
wBLocal;
this.m_count=cache.count;
vertices=this.m_vertices;
for(i=0;i<this.m_count;i++)
{
v=vertices[i];
v.indexA=cache.indexA[i];
v.indexB=cache.indexB[i];
wALocal=proxyA.GetVertex(v.indexA);
wBLocal=proxyB.GetVertex(v.indexB);
v.wA=Box2D.Common.Math.b2Math.MulX(transformA,wALocal);
v.wB=Box2D.Common.Math.b2Math.MulX(transformB,wBLocal);
v.w=Box2D.Common.Math.b2Math.SubtractVV(v.wB,v.wA);
v.a=0
}
if(this.m_count>1)
{
metric1=cache.metric;
metric2=this.GetMetric();
if(metric2<.5*metric1||2.0*metric1<metric2||metric2<Number.MIN_VALUE)
{
this.m_count=0
}
}
if(this.m_count==0)
{
v=vertices[0];
v.indexA=0;
v.indexB=0;
wALocal=proxyA.GetVertex(0);
wBLocal=proxyB.GetVertex(0);
v.wA=Box2D.Common.Math.b2Math.MulX(transformA,wALocal);
v.wB=Box2D.Common.Math.b2Math.MulX(transformB,wBLocal);
v.w=Box2D.Common.Math.b2Math.SubtractVV(v.wB,v.wA);
this.m_count=1
}
};
d.WriteCache=function(cache)
{
var vertices=null;
var i=0;
cache.metric=this.GetMetric();
cache.count=flash.uint(this.m_count);
vertices=this.m_vertices;
for(i=0;i<this.m_count;i++)
{
cache.indexA[i]=flash.uint(vertices[i].indexA);
cache.indexB[i]=flash.uint(vertices[i].indexB)
}
};
d.GetSearchDirection=function()
{
var e12=null;
var sgn=0;
switch(this.m_count)
{
case 1:
return this.m_v1.w.GetNegative();
case 2:
{
e12=Box2D.Common.Math.b2Math.SubtractVV(this.m_v2.w,this.m_v1.w);
sgn=Box2D.Common.Math.b2Math.CrossVV(e12,this.m_v1.w.GetNegative());
if(sgn>0.0)
{
return Box2D.Common.Math.b2Math.CrossFV(1.0,e12)
}
else
{
return Box2D.Common.Math.b2Math.CrossVF(e12,1.0)
}
};
default:
Box2D.Common.b2Settings.b2Assert(false);
return new Box2D.Common.Math.b2Vec2()
}
};
d.GetClosestPoint=function()
{
switch(this.m_count)
{
case 0:
Box2D.Common.b2Settings.b2Assert(false);
return new Box2D.Common.Math.b2Vec2();
case 1:
return this.m_v1.w;
case 2:
return new Box2D.Common.Math.b2Vec2(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y);
default:
Box2D.Common.b2Settings.b2Assert(false);
return new Box2D.Common.Math.b2Vec2()
}
};
d.GetWitnessPoints=function(pA,pB)
{
switch(this.m_count)
{
case 0:
Box2D.Common.b2Settings.b2Assert(false);
break;
;case 1:
pA.SetV(this.m_v1.wA);
pB.SetV(this.m_v1.wB);
break;
;case 2:
pA.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x;
pA.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y;
pB.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x;
pB.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;
break;
;case 3:
pB.x=pA.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x;
pB.y=pA.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y;
break;
;default:
Box2D.Common.b2Settings.b2Assert(false);
break;
;
}
};
d.GetMetric=function()
{
switch(this.m_count)
{
case 0:
Box2D.Common.b2Settings.b2Assert(false);
return 0.0;
case 1:
return 0.0;
case 2:
return Box2D.Common.Math.b2Math.SubtractVV(this.m_v1.w,this.m_v2.w).Length();
case 3:
return Box2D.Common.Math.b2Math.CrossVV(Box2D.Common.Math.b2Math.SubtractVV(this.m_v2.w,this.m_v1.w),Box2D.Common.Math.b2Math.SubtractVV(this.m_v3.w,this.m_v1.w));
default:
Box2D.Common.b2Settings.b2Assert(false);
return 0.0
}
};
d.Solve2=function()
{
var w1=null;
var w2=null;
var e12=null;
var d12_2=0;
var d12_1=0;
var inv_d12=0;
w1=this.m_v1.w;
w2=this.m_v2.w;
e12=Box2D.Common.Math.b2Math.SubtractVV(w2,w1);
d12_2=-(w1.x*e12.x+w1.y*e12.y);
if(d12_2<=0.0)
{
this.m_v1.a=1.0;
this.m_count=1;
return
}
d12_1=(w2.x*e12.x+w2.y*e12.y);
if(d12_1<=0.0)
{
this.m_v2.a=1.0;
this.m_count=1;
this.m_v1.Set(this.m_v2);
return
}
inv_d12=1.0/(d12_1+d12_2);
this.m_v1.a=d12_1*inv_d12;
this.m_v2.a=d12_2*inv_d12;
this.m_count=2;
};
d.Solve3=function()
{
var w1=null;
var w2=null;
var w3=null;
var e12=null;
var w1e12=0;
var w2e12=0;
var d12_1=0;
var d12_2=0;
var e13=null;
var w1e13=0;
var w3e13=0;
var d13_1=0;
var d13_2=0;
var e23=null;
var w2e23=0;
var w3e23=0;
var d23_1=0;
var d23_2=0;
var n123=0;
var d123_1=0;
var d123_2=0;
var d123_3=0;
var inv_d12=0;
var inv_d13=0;
var inv_d23=0;
var inv_d123=0;
w1=this.m_v1.w;
w2=this.m_v2.w;
w3=this.m_v3.w;
e12=Box2D.Common.Math.b2Math.SubtractVV(w2,w1);
w1e12=Box2D.Common.Math.b2Math.Dot(w1,e12);
w2e12=Box2D.Common.Math.b2Math.Dot(w2,e12);
d12_1=w2e12;
d12_2=-w1e12;
e13=Box2D.Common.Math.b2Math.SubtractVV(w3,w1);
w1e13=Box2D.Common.Math.b2Math.Dot(w1,e13);
w3e13=Box2D.Common.Math.b2Math.Dot(w3,e13);
d13_1=w3e13;
d13_2=-w1e13;
e23=Box2D.Common.Math.b2Math.SubtractVV(w3,w2);
w2e23=Box2D.Common.Math.b2Math.Dot(w2,e23);
w3e23=Box2D.Common.Math.b2Math.Dot(w3,e23);
d23_1=w3e23;
d23_2=-w2e23;
n123=Box2D.Common.Math.b2Math.CrossVV(e12,e13);
d123_1=n123*Box2D.Common.Math.b2Math.CrossVV(w2,w3);
d123_2=n123*Box2D.Common.Math.b2Math.CrossVV(w3,w1);
d123_3=n123*Box2D.Common.Math.b2Math.CrossVV(w1,w2);
if(d12_2<=0.0&&d13_2<=0.0)
{
this.m_v1.a=1.0;
this.m_count=1;
return
}
if(d12_1>0.0&&d12_2>0.0&&d123_3<=0.0)
{
inv_d12=1.0/(d12_1+d12_2);
this.m_v1.a=d12_1*inv_d12;
this.m_v2.a=d12_2*inv_d12;
this.m_count=2;
return
}
if(d13_1>0.0&&d13_2>0.0&&d123_2<=0.0)
{
inv_d13=1.0/(d13_1+d13_2);
this.m_v1.a=d13_1*inv_d13;
this.m_v3.a=d13_2*inv_d13;
this.m_count=2;
this.m_v2.Set(this.m_v3);
return
}
if(d12_1<=0.0&&d23_2<=0.0)
{
this.m_v2.a=1.0;
this.m_count=1;
this.m_v1.Set(this.m_v2);
return
}
if(d13_1<=0.0&&d23_1<=0.0)
{
this.m_v3.a=1.0;
this.m_count=1;
this.m_v1.Set(this.m_v3);
return
}
if(d23_1>0.0&&d23_2>0.0&&d123_1<=0.0)
{
inv_d23=1.0/(d23_1+d23_2);
this.m_v2.a=d23_1*inv_d23;
this.m_v3.a=d23_2*inv_d23;
this.m_count=2;
this.m_v1.Set(this.m_v3);
return
}
inv_d123=1.0/(d123_1+d123_2+d123_3);
this.m_v1.a=d123_1*inv_d123;
this.m_v2.a=d123_2*inv_d123;
this.m_v3.a=d123_3*inv_d123;
this.m_count=3;
};
flash.addDescription("Box2D.Collision.b2Simplex",d,null,null,null,["Box2D.Collision.b2SimplexVertex","Box2D.Common.b2Settings","Box2D.Common.Math.b2Math","Box2D.Common.Math.b2Vec2"]);
}
());